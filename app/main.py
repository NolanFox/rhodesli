"""
Rhodesli Forensic Workstation.

A triage-focused interface for identity verification with epistemic humility.
The UI reflects backend state - it never calculates probabilities.

Error Semantics:
- 409 = Variance Explosion (faces too dissimilar)
- 423 = Lock Contention (another process is writing)
- 404 = Identity or face not found
"""

import hashlib
import io
import json
import logging
import os
import random
import re
import sys
import uuid
import zipfile
from datetime import datetime, timedelta, timezone
from pathlib import Path
from urllib.parse import quote

import numpy as np
from fasthtml.common import *
from PIL import Image
from starlette.datastructures import UploadFile
from starlette.responses import FileResponse

# Add project root to path for imports
project_root = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(project_root))

from core.registry import IdentityRegistry, IdentityState
from core.config import (
    MATCH_THRESHOLD_HIGH,
    MATCH_THRESHOLD_LOW,
    MATCH_THRESHOLD_MEDIUM,
    MATCH_THRESHOLD_MODERATE,
    MATCH_THRESHOLD_VERY_HIGH,
    HOST,
    PORT,
    DEBUG,
    PROCESSING_ENABLED,
    DATA_DIR,
    PHOTOS_DIR,
    SYNC_API_TOKEN,
)
from core.ui_safety import ensure_utf8_display
from core import storage
from app.auth import (
    is_auth_enabled, SESSION_SECRET, INVITE_CODES,
    get_current_user, User, ADMIN_EMAILS,
    login_with_supabase, signup_with_supabase, validate_invite_code,
    send_password_reset, update_password, get_oauth_url, get_user_from_token,
    exchange_code_for_session,
)

# --- INSTRUMENTATION IMPORT ---
from core.event_recorder import get_event_recorder

static_path = Path(__file__).resolve().parent / "static"
# Data and photos paths come from config, which handles STORAGE_DIR for Railway
data_path = Path(DATA_DIR) if Path(DATA_DIR).is_absolute() else project_root / DATA_DIR
photos_path = Path(PHOTOS_DIR) if Path(PHOTOS_DIR).is_absolute() else project_root / PHOTOS_DIR

# Canonical site URL for Open Graph tags and sharing
SITE_URL = os.getenv("SITE_URL", "https://rhodesli.nolanandrewfox.com")

# App version — read from CHANGELOG.md first line matching [vX.Y.Z]
def _read_app_version() -> str:
    """Extract version from CHANGELOG.md header."""
    changelog = project_root / "CHANGELOG.md"
    if changelog.exists():
        try:
            with open(changelog) as f:
                for line in f:
                    m = re.search(r'\[v(\d+\.\d+\.\d+)\]', line)
                    if m:
                        return f"v{m.group(1)}"
        except Exception:
            pass
    return "v0.0.0"

APP_VERSION = _read_app_version()

# No blanket auth — all GET routes are public.
# Specific POST routes use @require_admin or @require_login decorators.

app, rt = fast_app(
    pico=False,
    secret_key=SESSION_SECRET,
    hdrs=(
        Meta(name="viewport", content="width=device-width, initial-scale=1"),
        Script(src="https://cdn.tailwindcss.com"),
        # Hyperscript required for _="on click..." modal interactions
        Script(src="https://unpkg.com/hyperscript.org@0.9.12"),
        # Global: handle auth error hash fragments and recovery redirects
        Script("""
            document.addEventListener('DOMContentLoaded', function() {
                var hash = window.location.hash.substring(1);
                if (!hash) return;
                var params = new URLSearchParams(hash);
                var error = params.get('error');
                var errorCode = params.get('error_code');
                var errorDesc = params.get('error_description');

                // If user lands on wrong page with a valid recovery token, redirect
                var type = params.get('type');
                if (type === 'recovery' && params.get('access_token')) {
                    window.location.href = '/reset-password' + window.location.hash;
                    return;
                }

                if (error) {
                    var messages = {
                        'otp_expired': 'This link has expired. Please request a new one.',
                        'access_denied': 'There was a problem with your login link. Please try again.'
                    };
                    var msg = messages[errorCode] || (errorDesc ? errorDesc.replace(/\\+/g, ' ') : 'An error occurred.');

                    var container = document.getElementById('toast-container');
                    if (container) {
                        var toast = document.createElement('div');
                        toast.className = 'px-4 py-3 rounded shadow-lg flex items-center bg-red-600 text-white';
                        toast.innerHTML = '<span class="mr-2">&#10007;</span><span>' + msg + '</span>';
                        container.appendChild(toast);
                        setTimeout(function() { toast.remove(); }, 8000);
                    }

                    history.replaceState(null, '', window.location.pathname + window.location.search);
                }
            });
        """),
        # Global: intercept HTMX 401 responses to show login modal instead of swapping content
        Script("""
            document.body.addEventListener('htmx:beforeSwap', function(evt) {
                if (evt.detail.xhr.status === 401) {
                    evt.detail.shouldSwap = false;
                    var modal = document.getElementById('login-modal');
                    if (modal) {
                        // Update the modal message based on the triggering element
                        var trigger = evt.detail.elt;
                        var msgEl = document.getElementById('login-modal-message');
                        if (msgEl && trigger) {
                            var action = trigger.getAttribute('data-auth-action') ||
                                         trigger.innerText.trim() || 'do that';
                            msgEl.textContent = 'You need to sign in to ' + action.toLowerCase() + '.';
                        }
                        modal.classList.remove('hidden');
                    }
                }
            });
        """),
        # Global: styled confirmation dialog replacing native confirm()
        Script("""
            document.body.addEventListener('htmx:confirm', function(evt) {
                evt.preventDefault();
                var modal = document.getElementById('confirm-modal');
                if (!modal) { evt.detail.issueRequest(true); return; }
                document.getElementById('confirm-modal-message').textContent = evt.detail.question;
                modal.classList.remove('hidden');
                document.getElementById('confirm-modal-yes').onclick = function() {
                    modal.classList.add('hidden');
                    evt.detail.issueRequest(true);
                };
                document.getElementById('confirm-modal-no').onclick = function() {
                    modal.classList.add('hidden');
                };
            });
        """),
        # Mobile sidebar toggle
        Script("""
            function toggleSidebar() {
                var sidebar = document.getElementById('sidebar');
                var overlay = document.getElementById('sidebar-overlay');
                if (sidebar && overlay) {
                    sidebar.classList.toggle('-translate-x-full');
                    overlay.classList.toggle('hidden');
                }
            }
            function closeSidebar() {
                var sidebar = document.getElementById('sidebar');
                var overlay = document.getElementById('sidebar-overlay');
                if (sidebar && overlay) {
                    sidebar.classList.add('-translate-x-full');
                    overlay.classList.add('hidden');
                }
            }
        """),
    ),
    static_path=str(static_path),
)

# --- INSTRUMENTATION LIFECYCLE HOOKS ---
@app.on_event("startup")
async def startup_event():
    """Initialize required directories and log the start of a session/run."""
    # Deployment safety: ensure all required directories exist
    required_dirs = [
        data_path / "staging",
        data_path / "inbox",
        data_path / "cleanup_backups",
        static_path / "crops",
        Path(__file__).resolve().parent.parent / "logs",
    ]
    for dir_path in required_dirs:
        dir_path.mkdir(parents=True, exist_ok=True)

    get_event_recorder().record("RUN_START", {
        "action": "server_start",
        "timestamp_utc": datetime.utcnow().isoformat()
    }, actor="system")

@app.on_event("shutdown")
async def shutdown_event():
    """Log the end of a session/run."""
    get_event_recorder().record("RUN_END", {
        "action": "server_shutdown",
        "timestamp_utc": datetime.utcnow().isoformat()
    }, actor="system")
# ---------------------------------------

@app.get("/photos/{filename:path}")
async def serve_photo(filename: str):
    """
    Serve photos from raw_photos/.

    All photos (original and uploaded) live in a single directory.
    """
    photo_path = photos_path / filename
    if photo_path.exists() and photo_path.is_file():
        return FileResponse(photo_path)

    return Response(
        content=f"Photo not found: {filename}",
        status_code=404,
        media_type="text/plain"
    )


# IMPORTANT: Move photos route to position 0 to take precedence over
# FastHTML's catch-all static route (/{fname:path}.{ext:static})
for i, route in enumerate(app.routes):
    if getattr(route, "path", None) == "/photos/{filename:path}":
        photos_route = app.routes.pop(i)
        app.routes.insert(0, photos_route)
        break

# Registry path - single source of truth
REGISTRY_PATH = data_path / "identities.json"


def load_registry():
    """Load the identity registry (backend authority).

    Returns an empty registry if the file is missing or corrupted,
    so the server never crashes on bad data.
    """
    if REGISTRY_PATH.exists():
        try:
            return IdentityRegistry.load(REGISTRY_PATH)
        except (ValueError, OSError) as e:
            logging.error(f"Failed to load identity registry from {REGISTRY_PATH}: {e}")
            return IdentityRegistry()
    return IdentityRegistry()


def save_registry(registry):
    """Save registry with atomic write (backend handles locking)."""
    registry.save(REGISTRY_PATH)


# =============================================================================
# DISPLAY HELPERS
# =============================================================================

def _pl(count, singular, plural=None):
    """Pluralize: _pl(3, 'face') -> '3 faces', _pl(1, 'face') -> '1 face'."""
    plural = plural or f"{singular}s"
    return f"{count} {singular}" if count == 1 else f"{count} {plural}"


# =============================================================================
# USER ACTION LOGGING (LEGACY - REPLACED BY EVENT RECORDER)
# =============================================================================
# We keep this for backward compatibility if needed, but EventRecorder is primary now.

logs_path = Path(__file__).resolve().parent.parent / "logs"


def _check_admin(sess) -> Response | None:
    """Return a 401/403/redirect Response if user is not admin, else None.
    When auth is disabled, always allows access.
    Returns 401 (not 303) so HTMX beforeSwap handler can show login modal."""
    if not is_auth_enabled():
        return None  # Auth disabled — everyone has access
    user = get_current_user(sess or {})
    if not user:
        return Response("", status_code=401)
    if not user.is_admin:
        return Response(
            to_xml(toast("You don't have permission to do this.", "error")),
            status_code=403,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"},
        )
    return None


def _check_login(sess) -> Response | None:
    """Return a 401/redirect Response if user is not logged in, else None.
    When auth is disabled, always allows access.
    Returns 401 (not 303) so HTMX beforeSwap handler can show login modal."""
    if not is_auth_enabled():
        return None  # Auth disabled — everyone has access
    user = get_current_user(sess or {})
    if not user:
        return Response("", status_code=401)
    return None


def _get_user_role(sess) -> str:
    """Get the user's role string for UI rendering. Returns 'admin' when auth disabled."""
    if not is_auth_enabled():
        return "admin"
    user = get_current_user(sess or {})
    if not user:
        return "viewer"
    return user.role


def _check_contributor(sess) -> Response | None:
    """ROLE-002: Return 401/403 if user is not at least a contributor, else None.
    Allows admin and contributor roles. Rejects viewers and anonymous users.
    When auth is disabled, always allows access."""
    if not is_auth_enabled():
        return None
    user = get_current_user(sess or {})
    if not user:
        return Response("", status_code=401)
    if user.role in ("admin", "contributor"):
        return None
    return Response(
        to_xml(toast("Contributor access required.", "error")),
        status_code=403,
        headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"},
    )


def log_user_action(action: str, **kwargs) -> None:
    """
    Log a user action to the append-only user_actions.log.

    Format: ISO_TIMESTAMP | ACTION | key=value key=value ...

    Args:
        action: Action name (e.g., "DETACH", "MERGE", "RENAME")
        kwargs: Key-value pairs to log
    """
    logs_path.mkdir(parents=True, exist_ok=True)
    log_file = logs_path / "user_actions.log"

    timestamp = datetime.now(timezone.utc).isoformat()
    kvs = " ".join(f"{k}={v}" for k, v in kwargs.items())
    line = f"{timestamp} | {action} | {kvs}\n"

    with open(log_file, "a") as f:
        f.write(line)


# =============================================================================
# PENDING UPLOADS REGISTRY
# =============================================================================

def _load_pending_uploads() -> dict:
    """Load pending uploads registry."""
    path = data_path / "pending_uploads.json"
    if not path.exists():
        return {"uploads": {}}
    with open(path) as f:
        return json.load(f)


def _save_pending_uploads(data: dict) -> None:
    """Save pending uploads registry (atomic write)."""
    path = data_path / "pending_uploads.json"
    tmp = path.with_suffix(".tmp")
    with open(tmp, "w") as f:
        json.dump(data, f, indent=2)
    tmp.rename(path)


def _count_pending_uploads() -> int:
    """Count pending uploads awaiting review or processing."""
    data = _load_pending_uploads()
    return sum(1 for u in data["uploads"].values() if u["status"] in ("pending", "staged"))


# =============================================================================
# CLUSTERING PROPOSALS (from data/proposals.json)
# =============================================================================

_proposals_cache = None


def _load_proposals() -> dict:
    """Load clustering proposals generated by cluster_new_faces.py."""
    global _proposals_cache
    if _proposals_cache is not None:
        return _proposals_cache
    path = data_path / "proposals.json"
    if not path.exists():
        _proposals_cache = {"proposals": [], "generated_at": ""}
        return _proposals_cache
    with open(path) as f:
        _proposals_cache = json.load(f)
    return _proposals_cache


def _get_proposals_for_identity(identity_id: str) -> list[dict]:
    """Get all clustering proposals where this identity is the source."""
    data = _load_proposals()
    return [p for p in data.get("proposals", [])
            if p.get("source_identity_id") == identity_id]


def _get_proposal_targets_for_identity(identity_id: str) -> list[dict]:
    """Get all clustering proposals where this identity is the target."""
    data = _load_proposals()
    return [p for p in data.get("proposals", [])
            if p.get("target_identity_id") == identity_id]


def _get_identities_with_proposals() -> set[str]:
    """Get set of source identity IDs that have clustering proposals."""
    data = _load_proposals()
    return {p["source_identity_id"] for p in data.get("proposals", [])}


def _get_best_proposal_for_identity(identity_id: str) -> dict | None:
    """Get the highest-confidence proposal for an identity."""
    proposals = _get_proposals_for_identity(identity_id)
    if not proposals:
        return None
    return min(proposals, key=lambda p: p.get("distance", float("inf")))


# =============================================================================
# DISCOVERY LAYER CACHES (date labels + search index)
# =============================================================================

_date_labels_cache = None
_search_index_cache = None
_birth_year_cache = None
_ml_review_decisions_cache = None


def _load_date_labels() -> dict:
    """Load date labels from ML pipeline output, keyed by photo_id for O(1) lookup.

    Labels are indexed by BOTH their original photo_index ID (e.g. inbox_*)
    AND the SHA256 cache ID used by _photo_cache. This dual-keying handles
    the ID mismatch between photo_index.json and the embeddings-based cache.
    """
    global _date_labels_cache
    if _date_labels_cache is not None:
        return _date_labels_cache

    _date_labels_cache = {}
    ml_data_path = data_path / "date_labels.json"
    if not ml_data_path.exists():
        return _date_labels_cache

    # Build filename → photo_index_id mapping for cross-referencing
    filename_to_index_id = {}
    try:
        from core.photo_registry import PhotoRegistry
        photo_registry = PhotoRegistry.load(data_path / "photo_index.json")
        for pid in photo_registry._photos:
            path = photo_registry.get_photo_path(pid)
            if path:
                filename_to_index_id[Path(path).name] = pid
    except Exception:
        pass

    try:
        with open(ml_data_path) as f:
            data = json.load(f)
        for label in data.get("labels", []):
            pid = label.get("photo_id", "")
            if pid:
                _date_labels_cache[pid] = label
                # Also key by SHA256 cache ID if the original is an inbox_* ID
                if pid.startswith("inbox_"):
                    # Extract filename from photo_index path, compute SHA256 ID
                    path = None
                    try:
                        path = photo_registry.get_photo_path(pid)
                    except Exception:
                        pass
                    if path:
                        fname = Path(path).name
                        sha_id = hashlib.sha256(fname.encode("utf-8")).hexdigest()[:16]
                        _date_labels_cache[sha_id] = label
    except Exception as e:
        logging.warning(f"Failed to load date labels: {e}")

    return _date_labels_cache


def _load_search_index() -> list:
    """Load photo search index for in-memory keyword search.

    For inbox photos, adds a SHA256-based alias photo_id so that
    _photo_cache lookups match search results.
    """
    global _search_index_cache
    if _search_index_cache is not None:
        return _search_index_cache

    _search_index_cache = []
    search_path = data_path / "photo_search_index.json"
    if not search_path.exists():
        return _search_index_cache

    # Build inbox_id → SHA256 ID mapping for cross-referencing
    index_to_sha = {}
    try:
        from core.photo_registry import PhotoRegistry
        photo_registry = PhotoRegistry.load(data_path / "photo_index.json")
        for pid in photo_registry._photos:
            if pid.startswith("inbox_"):
                path = photo_registry.get_photo_path(pid)
                if path:
                    fname = Path(path).name
                    sha_id = hashlib.sha256(fname.encode("utf-8")).hexdigest()[:16]
                    index_to_sha[pid] = sha_id
    except Exception:
        pass

    try:
        with open(search_path) as f:
            data = json.load(f)
        docs = data.get("documents", [])
        # Add SHA256 alias for inbox photos so _photo_cache keys match
        for doc in docs:
            pid = doc.get("photo_id", "")
            if pid in index_to_sha:
                doc["cache_photo_id"] = index_to_sha[pid]
            else:
                doc["cache_photo_id"] = pid
        _search_index_cache = docs
    except Exception as e:
        logging.warning(f"Failed to load search index: {e}")

    return _search_index_cache


def _load_birth_year_estimates() -> dict:
    """Load ML-inferred birth year estimates, keyed by identity_id.

    Returns dict mapping identity_id -> {birth_year_estimate, birth_year_confidence, ...}.
    Human-confirmed metadata.birth_year always takes priority over these estimates.
    """
    global _birth_year_cache
    if _birth_year_cache is not None:
        return _birth_year_cache

    _birth_year_cache = {}
    # Check both possible locations (ML output dir and data dir)
    for candidate in [
        Path("rhodesli_ml/data/birth_year_estimates.json"),
        data_path / "birth_year_estimates.json",
    ]:
        if candidate.exists():
            try:
                with open(candidate) as f:
                    data = json.load(f)
                for est in data.get("estimates", []):
                    iid = est.get("identity_id", "")
                    if iid:
                        _birth_year_cache[iid] = est
            except Exception as e:
                logging.warning(f"Failed to load birth year estimates: {e}")
            break

    return _birth_year_cache


def _get_birth_year(identity_id: str, identity: dict = None, include_unreviewed: bool = True) -> tuple:
    """Get birth year for an identity, checking metadata first then ML estimates.

    Args:
        identity_id: The identity UUID
        identity: Optional identity dict (avoids re-lookup)
        include_unreviewed: If False, only return confirmed metadata birth years.
            Public-facing code should pass False (Gatekeeper pattern: AD-097).
            Admin code can pass True to see pending ML estimates.

    Returns:
        (birth_year: int or None, source: str, confidence: str or None)
        source is "confirmed" (metadata) or "ml_inferred"
    """
    # Priority 1: Human-confirmed metadata (check both top-level and nested)
    if identity:
        # Some contexts flatten metadata to top level, some nest it
        for by in [
            identity.get("birth_year"),
            (identity.get("metadata") or {}).get("birth_year"),
        ]:
            if by:
                try:
                    return int(by), "confirmed", None
                except (ValueError, TypeError):
                    pass

    # Priority 2: ML-inferred estimate (only if caller allows unreviewed data)
    if include_unreviewed:
        # Skip rejected estimates
        decisions = _load_ml_review_decisions()
        decision = decisions.get(identity_id)
        if decision and decision.get("action") == "rejected":
            return None, None, None

        estimates = _load_birth_year_estimates()
        est = estimates.get(identity_id)
        if est:
            return est["birth_year_estimate"], "ml_inferred", est.get("birth_year_confidence")

    return None, None, None


def _load_ml_review_decisions() -> dict:
    """Load ML birth year review decisions (accept/reject).

    Returns dict mapping identity_id -> decision record.
    """
    global _ml_review_decisions_cache
    if _ml_review_decisions_cache is not None:
        return _ml_review_decisions_cache

    decisions_path = data_path / "ml_review_decisions.json"
    _ml_review_decisions_cache = {}
    if decisions_path.exists():
        try:
            with open(decisions_path) as f:
                data = json.load(f)
            _ml_review_decisions_cache = data.get("decisions", {})
        except Exception as e:
            logging.warning(f"Failed to load ML review decisions: {e}")

    return _ml_review_decisions_cache


def _save_ml_review_decisions(decisions: dict):
    """Save ML review decisions with atomic write."""
    global _ml_review_decisions_cache
    decisions_path = data_path / "ml_review_decisions.json"
    payload = {
        "schema_version": 1,
        "decisions": decisions,
    }
    import tempfile
    tmp_fd, tmp_path = tempfile.mkstemp(dir=str(data_path), suffix=".json")
    try:
        with os.fdopen(tmp_fd, "w") as f:
            json.dump(payload, f, indent=2)
        os.replace(tmp_path, str(decisions_path))
    except Exception:
        if os.path.exists(tmp_path):
            os.unlink(tmp_path)
        raise
    _ml_review_decisions_cache = decisions


def _save_ground_truth_birth_year(identity_id: str, identity: dict, birth_year: int,
                                   source: str, source_detail: str = "",
                                   original_ml_estimate: int = None,
                                   confirmed_by: str = "admin"):
    """Write confirmed birth year to ground truth file for ML feedback loop.

    Each confirmed identity x photo appearance = one labeled training sample.
    This is the bridge between the app and the ML pipeline (AD-099).
    """
    gt_path = data_path / "ground_truth_birth_years.json"

    # Load existing
    gt_data = {"schema_version": 1, "entries": {}}
    if gt_path.exists():
        try:
            with open(gt_path) as f:
                gt_data = json.load(f)
        except Exception:
            pass

    # Build face appearances from photo data
    photo_reg = load_photo_registry()
    face_ids = [f if isinstance(f, str) else f.get("face_id", "")
                for f in identity.get("anchor_ids", []) + identity.get("candidate_ids", [])]
    photo_ids = photo_reg.get_photos_for_faces(face_ids)

    face_appearances = []
    labels = _load_date_labels()
    for pid in photo_ids:
        pm = get_photo_metadata(pid)
        if not pm:
            continue
        label = labels.get(pid, {})
        photo_year = label.get("best_year_estimate") or pm.get("date_taken", "")[:4]
        if photo_year:
            try:
                py = int(str(photo_year)[:4])
                face_appearances.append({
                    "photo_id": pid,
                    "photo_filename": pm.get("filename", ""),
                    "photo_year": py,
                    "true_age": py - birth_year,
                })
            except (ValueError, TypeError):
                pass

    gt_data["entries"][identity_id] = {
        "name": ensure_utf8_display(identity.get("name", "")),
        "birth_year": birth_year,
        "source": source,
        "source_detail": source_detail,
        "original_ml_estimate": original_ml_estimate,
        "confirmed_at": datetime.now(timezone.utc).isoformat(),
        "confirmed_by": confirmed_by,
        "face_appearances": face_appearances,
    }

    import tempfile
    tmp_fd, tmp_path = tempfile.mkstemp(dir=str(data_path), suffix=".json")
    try:
        with os.fdopen(tmp_fd, "w") as f:
            json.dump(gt_data, f, indent=2)
        os.replace(tmp_path, str(gt_path))
    except Exception:
        if os.path.exists(tmp_path):
            os.unlink(tmp_path)
        raise


def _get_pending_ml_birth_year_suggestions() -> list:
    """Get all ML birth year estimates that haven't been reviewed yet.

    Returns list of dicts with identity_id, name, estimate info.
    Excludes identities that already have confirmed birth years or review decisions.
    """
    estimates = _load_birth_year_estimates()
    decisions = _load_ml_review_decisions()
    registry = load_registry()

    pending = []
    for iid, est in estimates.items():
        # Skip if already reviewed
        if iid in decisions:
            continue
        # Skip if identity already has confirmed birth year
        try:
            identity = registry.get_identity(iid)
        except KeyError:
            continue
        if identity.get("merged_into"):
            continue
        for by in [identity.get("birth_year"), (identity.get("metadata") or {}).get("birth_year")]:
            if by:
                break
        else:
            by = None
        if by:
            continue
        pending.append({
            "identity_id": iid,
            "name": ensure_utf8_display(identity.get("name", "")),
            "state": identity.get("state", ""),
            "birth_year_estimate": est["birth_year_estimate"],
            "birth_year_confidence": est.get("birth_year_confidence", "low"),
            "birth_year_range": est.get("birth_year_range", []),
            "birth_year_std": est.get("birth_year_std"),
            "n_appearances": est.get("n_appearances", 0),
            "n_with_age_data": est.get("n_with_age_data", 0),
            "evidence": est.get("evidence", []),
        })

    # Sort by confidence (high first), then by evidence count
    conf_order = {"high": 0, "medium": 1, "low": 2}
    pending.sort(key=lambda x: (conf_order.get(x["birth_year_confidence"], 3), -x["n_with_age_data"]))
    return pending


def _get_decade_counts() -> dict:
    """Compute photo counts per decade from the search index."""
    docs = _load_search_index()
    counts = {}
    for doc in docs:
        decade = doc.get("estimated_decade")
        if decade:
            counts[decade] = counts.get(decade, 0) + 1
    return dict(sorted(counts.items()))


def _get_tag_counts() -> dict:
    """Compute photo counts per controlled tag from the search index."""
    docs = _load_search_index()
    counts = {}
    for doc in docs:
        for tag in doc.get("controlled_tags", []):
            counts[tag] = counts.get(tag, 0) + 1
    return dict(sorted(counts.items(), key=lambda x: -x[1]))


_context_events_cache = None


def _load_context_events() -> list:
    """Load Rhodes historical context events from JSON file.

    Returns list of event dicts with year, title, description, category, source.
    Cached after first load.
    """
    global _context_events_cache
    if _context_events_cache is not None:
        return _context_events_cache

    context_path = data_path / "rhodes_context_events.json"
    try:
        if context_path.exists():
            with open(context_path) as f:
                data = json.load(f)
            _context_events_cache = data.get("events", [])
        else:
            _context_events_cache = []
    except Exception as e:
        logging.warning(f"Failed to load context events: {e}")
        _context_events_cache = []

    return _context_events_cache


_place_options_cache = None

def _get_place_options() -> list:
    """Load place names from location_dictionary.json for autocomplete.

    Returns list of (value, label) tuples. Includes historical name aliases.
    Cached after first load.
    """
    global _place_options_cache
    if _place_options_cache is not None:
        return _place_options_cache

    loc_path = data_path / "location_dictionary.json"
    options = []
    # Historical name mappings (alias → modern name)
    historical_aliases = {
        "Salonika": "Thessaloniki, Greece",
        "Salonica": "Thessaloniki, Greece",
        "Smyrna": "İzmir, Turkey",
        "Constantinople": "Istanbul, Turkey",
        "La Judería": "Rhodes, Greece",
        "Rodos": "Rhodes, Greece",
        "Rodas": "Rhodes, Greece",
        "Salisbury": "Harare, Zimbabwe",
        "Usumbura": "Bujumbura, Burundi",
        "Elisabethville": "Lubumbashi, Congo",
    }
    try:
        if loc_path.exists():
            with open(loc_path) as f:
                data = json.load(f)
            for loc in data.get("locations", {}).values():
                name = loc.get("name", "")
                if name:
                    options.append((name, name))
    except Exception:
        pass

    # Add historical aliases as separate options pointing to modern names
    for alias, modern in historical_aliases.items():
        options.append((modern, f"{modern} ({alias})"))

    # Deduplicate by value
    seen = set()
    deduped = []
    for val, label in options:
        if val not in seen:
            seen.add(val)
            deduped.append((val, label))
        elif label != val:  # Add alias labels even if value exists
            deduped.append((val, label))

    _place_options_cache = sorted(deduped, key=lambda x: x[0])
    return _place_options_cache


def _place_datalist() -> tuple:
    """Return a Datalist element with place options for autocomplete."""
    options = _get_place_options()
    return Datalist(
        *[Option(value=val, label=label) for val, label in options],
        id="places-list",
    )


def _photo_collection_datalist():
    """Return a Datalist with known collection names for inline photo editing."""
    collections = set()
    if _photo_cache:
        for pdata in _photo_cache.values():
            c = pdata.get("collection", "")
            if c:
                collections.add(c)
    return Datalist(
        *[Option(value=c) for c in sorted(collections)],
        id="photo-collections",
    )


def _search_photos(query: str = "", decade: int = None, tag: str = None) -> list:
    """Search photos using in-memory index. Returns matching documents with match reason."""
    docs = _load_search_index()
    results = []
    query_lower = query.lower().strip() if query else ""

    for doc in docs:
        # Apply decade filter
        if decade and doc.get("estimated_decade") != decade:
            continue

        # Apply tag filter
        if tag and tag not in doc.get("controlled_tags", []):
            continue

        # Apply text search
        match_reason = None
        if query_lower:
            searchable = doc.get("searchable_text", "").lower()
            if query_lower not in searchable:
                continue
            # Determine match reason
            tags_lower = " ".join(doc.get("controlled_tags", [])).lower()
            if query_lower in tags_lower:
                match_reason = "tags"
            else:
                match_reason = "scene"
        elif not decade and not tag:
            pass  # No filters, include all

        results.append({**doc, "match_reason": match_reason})

    return results


def _get_date_badge(photo_id: str) -> tuple:
    """Get date badge text, confidence, and tooltip for a photo.

    Returns (badge_text, confidence, tooltip) or (None, None, None) if no label.
    """
    labels = _load_date_labels()
    label = labels.get(photo_id)
    if not label:
        return None, None, None

    decade = label.get("estimated_decade")
    if not decade:
        return None, None, None

    badge_text = f"c. {decade}s"
    confidence = label.get("confidence", "medium")
    best_year = label.get("best_year_estimate", "")
    prob_range = label.get("probable_range", [])
    range_str = f"{prob_range[0]}\u2013{prob_range[1]}" if len(prob_range) == 2 else ""
    tooltip = f"Best estimate: {best_year} (range: {range_str})" if best_year and range_str else f"Estimated: {decade}s"

    return badge_text, confidence, tooltip


def _build_ai_analysis_section(photo_id: str, is_admin: bool = False):
    """Build the AI Analysis metadata panel for a photo detail page.

    Shows date estimate, scene description, tags, visible text, evidence, subject ages.
    Each subsection has provenance styling (AI = indigo, human = emerald).
    Returns None if no AI data available for this photo.
    """
    labels = _load_date_labels()
    label = labels.get(photo_id)
    if not label:
        return None

    # Build search index entry for tags/scene (check both photo_id and cache_photo_id)
    docs = _load_search_index()
    search_doc = next((d for d in docs if d.get("photo_id") == photo_id or d.get("cache_photo_id") == photo_id), None)

    # Track which specific fields have been human-corrected
    _date_is_human = label.get("source") == "human"

    def _field(title, content, field_key="ai", expanded=False):
        """Render a collapsible subsection with provenance styling.

        field_key: 'ai' (default), 'human' (force verified), or 'date' (uses date-specific source).
        """
        is_human = field_key == "human" or (field_key == "date" and _date_is_human)
        border_cls = "border-emerald-500/40 bg-emerald-950/20" if is_human else "border-indigo-500/40 bg-indigo-950/20"
        icon = "\u2713" if is_human else "\u2728"
        provenance_text = "Verified" if is_human else "AI Estimated"
        provenance_cls = "text-emerald-400" if is_human else "text-indigo-400"

        return Details(
            Summary(
                Div(
                    Span(icon, cls="mr-1.5"),
                    Span(title, cls="text-sm font-medium text-white"),
                    Span(f" \u2014 {provenance_text}", cls=f"text-[10px] {provenance_cls} ml-2"),
                    cls="flex items-center"
                ),
                cls="cursor-pointer list-none select-none py-2 px-3 hover:bg-slate-800/50 rounded-lg transition-colors"
            ),
            Div(content, cls="px-3 pb-3 text-sm text-slate-300 leading-relaxed"),
            cls=f"border-l-2 {border_cls} rounded-lg mb-2",
            open=expanded,
            data_provenance="human" if is_human else "ai",
            data_testid="verified-field" if is_human else None,
        )

    sections = []

    # Date estimate
    decade = label.get("estimated_decade")
    best_year = label.get("best_year_estimate")
    confidence = label.get("confidence", "medium")
    prob_range = label.get("probable_range", [])
    if decade:
        range_str = f"{prob_range[0]}\u2013{prob_range[1]}" if len(prob_range) == 2 else ""
        conf_badge_cls = {
            "high": "bg-emerald-500/20 text-emerald-400",
            "medium": "bg-amber-500/20 text-amber-400",
            "low": "bg-red-500/20 text-red-400",
        }.get(confidence, "bg-slate-500/20 text-slate-400")
        # Correction pencil button (visible to all, triggers form or login prompt)
        pencil_btn = Button(
            "\u270f\ufe0f",
            cls="text-xs text-slate-500 hover:text-white transition-colors ml-2 px-1",
            data_testid="correct-date",
            data_action="toggle-date-correction",
            data_photo_id=photo_id,
            title="Correct this date",
            type="button",
        )
        # Inline correction form (hidden by default, shown on pencil click)
        correction_form = Div(
            Form(
                Div(
                    Label("Actual year:", fr="correction-year-input", cls="text-[11px] text-slate-400 mr-2"),
                    Input(
                        type="number",
                        name="correction_year",
                        id="correction-year-input",
                        min="1850", max="2030",
                        placeholder=str(best_year or decade),
                        cls="w-20 bg-slate-800 border border-slate-600 rounded px-2 py-1 text-sm text-white",
                        data_testid="correction-year",
                    ),
                    Button(
                        "Submit",
                        cls="ml-2 px-3 py-1 text-xs bg-emerald-600 hover:bg-emerald-500 text-white rounded transition-colors",
                        data_testid="correction-submit",
                        type="submit",
                    ),
                    Button(
                        "Cancel",
                        cls="ml-1 px-2 py-1 text-xs text-slate-400 hover:text-white transition-colors",
                        type="button",
                        data_action="toggle-date-correction",
                    ),
                    cls="flex items-center mt-2",
                ),
                hx_post=f"/api/photo/{photo_id}/correct-date",
                hx_target=f"#date-section-{photo_id[:8]}",
                hx_swap="outerHTML",
            ),
            id=f"date-correction-form-{photo_id[:8]}",
            cls="hidden",
        )
        date_content = Div(
            Div(
                P(f"circa {best_year}" if best_year else f"{decade}s", cls="text-lg font-serif text-amber-200 mb-1 inline"),
                pencil_btn,
                cls="flex items-center",
            ),
            Div(
                Span(f"Confidence: {confidence}", cls=f"text-[11px] px-2 py-0.5 rounded-full {conf_badge_cls}"),
                Span(f"Range: {range_str}", cls="text-[11px] text-slate-500 ml-2") if range_str else None,
                cls="flex items-center gap-2"
            ),
            correction_form,
            id=f"date-section-{photo_id[:8]}",
        )
        sections.append(_field("Date Estimate", date_content, field_key="date", expanded=True))

    # Scene description
    scene = label.get("scene_description", "")
    if not scene and search_doc:
        # Fall back to searchable text (first sentence)
        st = search_doc.get("searchable_text", "")
        scene = st.split(".")[0] + "." if "." in st else st[:200]
    if scene:
        sections.append(_field("Scene", P(scene)))

    # Visible text (OCR)
    visible_text = label.get("visible_text", "")
    if visible_text:
        sections.append(_field("Visible Text", P(visible_text, cls="italic font-mono text-xs text-slate-400")))

    # Tags
    tags = label.get("controlled_tags") or (search_doc.get("controlled_tags") if search_doc else None)
    if tags:
        tag_pills = [
            A(
                t.replace("_", " "),
                href=f"/photos?tag={quote(t)}",
                cls="px-2 py-0.5 text-[11px] bg-slate-700/60 text-slate-300 rounded-full hover:bg-indigo-600/40 hover:text-white transition-colors",
                data_testid="ai-tag",
            )
            for t in tags
        ]
        sections.append(_field("Tags", Div(*tag_pills, cls="flex flex-wrap gap-1.5")))

    # Dating evidence
    evidence = label.get("evidence", {})
    if evidence:
        evidence_items = []
        for category, cues in evidence.items():
            if not isinstance(cues, list):
                continue
            for cue in cues[:3]:  # Max 3 per category
                cue_text = cue.get("cue", "") if isinstance(cue, dict) else str(cue)
                strength = cue.get("strength", "") if isinstance(cue, dict) else ""
                if cue_text:
                    strength_cls = {"strong": "text-emerald-400", "moderate": "text-amber-400", "weak": "text-slate-500"}.get(strength, "text-slate-500")
                    evidence_items.append(
                        Li(
                            Span(cue_text, cls="text-slate-400"),
                            Span(f" ({strength})", cls=f"text-[10px] {strength_cls}") if strength else None,
                            cls="text-xs mb-1"
                        )
                    )
        if evidence_items:
            sections.append(_field("Dating Evidence", Ul(*evidence_items, cls="list-disc list-inside space-y-0.5")))

    # Subject ages
    ages = label.get("subject_ages")
    if ages:
        if isinstance(ages, list):
            ages_text = ", ".join(str(a) for a in ages)
        elif isinstance(ages, str):
            ages_text = ages
        else:
            ages_text = str(ages)
        if ages_text:
            sections.append(_field("Subject Ages", P(ages_text)))

    if not sections:
        return None

    return Section(
        Div(
            Div(
                Span("\u2728", cls="text-lg mr-2"),
                H2("AI Analysis", cls="text-lg font-serif font-semibold text-white inline"),
                cls="flex items-center mb-1",
            ),
            P("Estimated by AI \u2014 help us verify", cls="text-[11px] text-indigo-400/70 mb-4"),
            *sections,
            cls="max-w-[900px] mx-auto",
            data_testid="ai-analysis",
        ),
        cls="px-4 sm:px-6 py-6 border-t border-slate-800/50",
    )


def _render_date_badge_overlay(photo_id: str) -> Span:
    """Render a date badge overlay for a photo card. Returns None if no label."""
    date_text, date_conf, date_tooltip = _get_date_badge(photo_id)
    if not date_text:
        return None

    if date_conf == "high":
        cls = "bg-amber-800/80 text-amber-100"
    elif date_conf == "medium":
        cls = "bg-amber-800/50 border border-amber-600/50 text-amber-200/90"
    else:
        cls = "border border-dashed border-amber-600/40 text-amber-400/60"

    return Span(
        date_text,
        cls=f"absolute bottom-2 right-2 text-[11px] font-serif px-1.5 py-0.5 rounded backdrop-blur-sm {cls}",
        title=date_tooltip,
        data_testid="date-badge",
        data_confidence=date_conf,
    )


def _compute_triage_counts(to_review: list) -> dict:
    """Categorize inbox identities by actionability for the triage bar.

    Returns:
        {
            "ready_to_confirm": int,  # Has Very High or High proposal to confirmed
            "rediscovered": int,      # Promoted from SKIPPED (has promoted_from field)
            "unmatched": int,         # No proposals, no promotion
        }
    """
    ids_with_proposals = _get_identities_with_proposals()
    ready = 0
    rediscovered = 0
    unmatched = 0

    for identity in to_review:
        iid = identity.get("identity_id", "")
        has_promotion = identity.get("promoted_from") is not None

        if iid in ids_with_proposals:
            best = _get_best_proposal_for_identity(iid)
            if best and best.get("confidence") in ("VERY HIGH", "HIGH"):
                ready += 1
                continue

        if has_promotion:
            rediscovered += 1
        elif iid in ids_with_proposals:
            # Has proposals but not high-confidence
            ready += 1
        else:
            unmatched += 1

    return {
        "ready_to_confirm": ready,
        "rediscovered": rediscovered,
        "unmatched": unmatched,
    }


def _triage_category(identity: dict) -> str:
    """Determine triage category for a single identity.

    Returns: "ready", "rediscovered", or "unmatched"
    """
    iid = identity.get("identity_id", "")
    ids_with_proposals = _get_identities_with_proposals()

    if iid in ids_with_proposals:
        return "ready"

    if identity.get("promoted_from") is not None:
        return "rediscovered"

    return "unmatched"


def _build_triage_bar(to_review: list, view_mode: str, active_filter: str = "") -> Div:
    """Build the triage summary bar for the inbox."""
    counts = _compute_triage_counts(to_review)

    items = []
    categories = [
        ("ready", "Ready to Confirm", counts["ready_to_confirm"],
         "bg-emerald-900/40 border-emerald-600/40 text-emerald-300 hover:bg-emerald-900/60",
         "ring-2 ring-emerald-400 bg-emerald-800/60 font-bold"),
        ("rediscovered", "Rediscovered", counts["rediscovered"],
         "bg-amber-900/40 border-amber-600/40 text-amber-300 hover:bg-amber-900/60",
         "ring-2 ring-amber-400 bg-amber-800/60 font-bold"),
        ("unmatched", "Unmatched", counts["unmatched"],
         "bg-slate-700/40 border-slate-600/40 text-slate-300 hover:bg-slate-700/60",
         "ring-2 ring-slate-400 bg-slate-600/60 font-bold"),
    ]

    for filter_val, label, count, color_cls, active_cls in categories:
        if count == 0:
            continue
        is_active = (filter_val == active_filter)
        pill_cls = f"flex flex-col items-center px-4 py-2 rounded-lg border transition-colors {color_cls}"
        if is_active:
            pill_cls += f" {active_cls}"
        items.append(
            A(
                Span(str(count), cls="text-lg font-bold"),
                Span(label, cls="text-xs" + ("" if is_active else " opacity-80")),
                href=f"/?section=to_review&view={view_mode}&filter={filter_val}",
                cls=pill_cls,
            )
        )

    if not items:
        return None

    return Div(
        *items,
        cls="flex gap-3 mb-4 flex-wrap",
    )


def _promotion_badge(identity: dict):
    """Badge for promoted (rediscovered) identities in browse view."""
    if not identity.get("promoted_from"):
        return None
    reason = identity.get("promotion_reason", "")
    if reason == "confirmed_match":
        return Span(
            "Suggested ID",
            cls="text-xs px-2 py-0.5 rounded border bg-emerald-600/30 text-emerald-300 border-emerald-500/30",
            title="Previously skipped — now matches a confirmed identity",
        )
    else:
        return Span(
            "Rediscovered",
            cls="text-xs px-2 py-0.5 rounded border bg-amber-600/30 text-amber-300 border-amber-500/30",
            title="Previously skipped — new match evidence found",
        )


def _promotion_banner(identity: dict):
    """Banner for promoted faces shown above expanded cards in Focus mode."""
    if not identity.get("promoted_from"):
        return None
    reason = identity.get("promotion_reason", "")
    context = identity.get("promotion_context", "")

    if reason == "confirmed_match":
        title = "Identity Suggested"
        desc = context or "This previously skipped face now matches a confirmed identity with high confidence."
        icon_cls = "text-emerald-400"
        border_cls = "border-emerald-600/40 bg-emerald-900/20"
    elif reason == "new_face_match":
        title = "New Context Available"
        desc = context or "A newly uploaded photo matches this previously skipped face."
        icon_cls = "text-amber-400"
        border_cls = "border-amber-600/40 bg-amber-900/20"
    else:  # group_discovery
        title = "Rediscovered"
        desc = context or "This face now groups with another face from a different batch."
        icon_cls = "text-amber-400"
        border_cls = "border-amber-600/40 bg-amber-900/20"

    return Div(
        Div(
            Span("*", cls=f"text-lg font-bold {icon_cls}"),
            Div(
                Strong(title, cls="text-white text-sm"),
                P(desc, cls="text-slate-400 text-xs mt-0.5"),
                cls="ml-2",
            ),
            cls="flex items-start",
        ),
        cls=f"rounded-lg border p-3 mb-3 {border_cls}",
    )


def _section_for_state(state: str) -> str:
    """Map identity state to the correct sidebar section for navigation links."""
    if state == "CONFIRMED":
        return "confirmed"
    elif state == "SKIPPED":
        return "skipped"
    elif state in ("REJECTED", "CONTESTED"):
        return "rejected"
    else:  # INBOX, PROPOSED
        return "to_review"


def _safe_get_identity(registry, identity_id: str) -> dict:
    """Get identity by ID, returning empty dict instead of raising KeyError."""
    try:
        return registry.get_identity(identity_id)
    except (KeyError, TypeError):
        return {}


def _compute_sidebar_counts(registry) -> dict:
    """Compute sidebar navigation counts from a loaded registry.

    This is the SINGLE canonical source for sidebar counts.
    All pages with a sidebar MUST call this instead of computing counts inline.
    """
    _build_caches()
    inbox = registry.list_identities(state=IdentityState.INBOX)
    proposed = registry.list_identities(state=IdentityState.PROPOSED)
    confirmed_list = registry.list_identities(state=IdentityState.CONFIRMED)
    skipped_list = registry.list_identities(state=IdentityState.SKIPPED)
    rejected = registry.list_identities(state=IdentityState.REJECTED)
    contested = registry.list_identities(state=IdentityState.CONTESTED)

    to_review = inbox + proposed
    dismissed = rejected + contested
    photo_count = len(_photo_cache) if _photo_cache else 0
    proposal_count = len(registry.list_proposed_matches()) if hasattr(registry, 'list_proposed_matches') else 0

    # Count pending user annotations (for admin approvals badge)
    pending_annotations = 0
    try:
        annotations_data = _load_annotations()
        for ann in annotations_data.get("annotations", []):
            if ann.get("status") in ("pending", "pending_unverified"):
                pending_annotations += 1
    except Exception:
        pass

    return {
        "to_review": len(to_review),
        "confirmed": len(confirmed_list),
        "skipped": len(skipped_list),
        "rejected": len(dismissed),
        "photos": photo_count,
        "pending_uploads": _count_pending_uploads(),
        "proposals": proposal_count,
        "pending_annotations": pending_annotations,
    }


async def _notify_admin_upload(uploader_email: str, job_id: str, file_count: int, source: str) -> None:
    """Send email notification to admins about a new pending upload.

    Uses Resend API if RESEND_API_KEY is set. Fire-and-forget — does not
    block the upload response on email delivery.
    """
    import os
    resend_api_key = os.getenv("RESEND_API_KEY", "")
    if not resend_api_key:
        logging.info(f"[upload] No RESEND_API_KEY set, skipping email notification for job {job_id}")
        return

    if not ADMIN_EMAILS:
        logging.info(f"[upload] No ADMIN_EMAILS configured, skipping email notification for job {job_id}")
        return

    import httpx

    site_url = os.getenv("SITE_URL", "https://rhodesli.nolanandrewfox.com")
    from_email = os.getenv("NOTIFICATION_FROM_EMAIL", "noreply@nolanandrewfox.com")
    subject = f"New photo upload pending review ({file_count} file{'s' if file_count != 1 else ''})"
    html_body = f"""
    <div style="font-family: sans-serif; max-width: 480px;">
        <h2 style="color: #1e293b;">New Upload Pending Review</h2>
        <p><strong>Uploader:</strong> {uploader_email}</p>
        <p><strong>Files:</strong> {file_count}</p>
        <p><strong>Source:</strong> {source or 'Not specified'}</p>
        <p><strong>Job ID:</strong> <code>{job_id}</code></p>
        <p style="margin-top: 20px;">
            <a href="{site_url}/admin/pending"
               style="display: inline-block; background-color: #2563eb; color: #ffffff !important;
                      padding: 10px 20px; border-radius: 6px; text-decoration: none; font-weight: bold;">
                Review Uploads
            </a>
        </p>
    </div>
    """

    try:
        async with httpx.AsyncClient() as client:
            for admin_email in ADMIN_EMAILS:
                await client.post(
                    "https://api.resend.com/emails",
                    json={
                        "from": f"Rhodesli <{from_email}>",
                        "to": [admin_email],
                        "subject": subject,
                        "html": html_body,
                    },
                    headers={
                        "Authorization": f"Bearer {resend_api_key}",
                        "Content-Type": "application/json",
                    },
                    timeout=10.0,
                )
        logging.info(f"[upload] Email notification sent for job {job_id}")
    except Exception as e:
        logging.warning(f"[upload] Failed to send email notification for job {job_id}: {e}")


# =============================================================================
# FACE DATA & PHOTO REGISTRY LOADERS
# =============================================================================

_face_data_cache = None
_photo_registry_cache = None


def load_face_embeddings() -> dict[str, dict]:
    """
    Load face embeddings as face_id -> {mu, sigma_sq} dict.

    Returns:
        Dict mapping face_id to {"mu": np.ndarray, "sigma_sq": np.ndarray}
    """
    embeddings_path = data_path / "embeddings.npy"
    if not embeddings_path.exists():
        return {}

    embeddings = np.load(embeddings_path, allow_pickle=True)

    face_data = {}
    filename_face_counts = {}

    for entry in embeddings:
        filename = entry["filename"]

        # Track face index per filename (same logic as generate_face_id)
        if filename not in filename_face_counts:
            filename_face_counts[filename] = 0
        face_index = filename_face_counts[filename]
        filename_face_counts[filename] += 1

        # Use stored face_id if present (inbox format), otherwise generate legacy format
        face_id = entry.get("face_id") or generate_face_id(filename, face_index)

        # Extract mu and sigma_sq
        if "mu" in entry:
            mu = entry["mu"]
            sigma_sq = entry["sigma_sq"]
        else:
            # Legacy format: use embedding directly, compute default sigma_sq
            mu = np.asarray(entry["embedding"], dtype=np.float32)
            # Default sigma_sq based on det_score if available
            det_score = entry.get("det_score", 0.5)
            sigma_sq_val = 1.0 - (det_score * 0.9)  # 0.1 to 1.0
            sigma_sq = np.full(512, sigma_sq_val, dtype=np.float32)

        face_data[face_id] = {
            "mu": np.asarray(mu, dtype=np.float32),
            "sigma_sq": np.asarray(sigma_sq, dtype=np.float32),
        }

    return face_data


def get_face_data() -> dict[str, dict]:
    """Get face data with caching."""
    global _face_data_cache
    if _face_data_cache is None:
        _face_data_cache = load_face_embeddings()
    return _face_data_cache


def load_photo_registry():
    """Load the photo registry for merge validation.

    Returns an empty registry if the file is missing or corrupted,
    so the server never crashes on bad data.
    """
    global _photo_registry_cache
    if _photo_registry_cache is None:
        from core.photo_registry import PhotoRegistry
        photo_index_path = data_path / "photo_index.json"
        if photo_index_path.exists():
            try:
                _photo_registry_cache = PhotoRegistry.load(photo_index_path)
            except (ValueError, OSError) as e:
                logging.error(f"Failed to load photo registry from {photo_index_path}: {e}")
                _photo_registry_cache = PhotoRegistry()
        else:
            _photo_registry_cache = PhotoRegistry()
    return _photo_registry_cache


def save_photo_registry(registry):
    """Save photo registry to disk and invalidate cache."""
    global _photo_registry_cache
    photo_index_path = data_path / "photo_index.json"
    registry.save(photo_index_path)
    _photo_registry_cache = registry


# =============================================================================
# PHOTO CONTEXT HELPERS
# =============================================================================

def generate_photo_id(filename: str) -> str:
    """
    Generate a stable, deterministic photo_id from filename.

    Always uses basename for consistency — all photos live in raw_photos/.
    """
    basename = Path(filename).name
    hash_bytes = hashlib.sha256(basename.encode("utf-8")).hexdigest()
    return hash_bytes[:16]


def generate_face_id(filename: str, face_index: int) -> str:
    """
    Generate a stable face ID from filename and index.
    Format: {filename_stem}:face{index}
    """
    stem = Path(filename).stem
    return f"{stem}:face{face_index}"


def make_css_id(raw_id: str) -> str:
    """
    Create a safe CSS identifier from a face_id.
    Replaces colons, spaces, and special chars with hyphens.
    Example: "John Doe:face0" -> "face-card-John-Doe-face0"
    """
    # Replace non-alphanumeric characters with hyphens
    safe = re.sub(r'[^a-zA-Z0-9\-_]', '-', raw_id)
    # Collapse multiple hyphens to look cleaner
    safe = re.sub(r'-+', '-', safe)
    return f"face-card-{safe}"


def load_embeddings_for_photos():
    """
    Load embeddings and build photo metadata cache.

    Returns:
        dict mapping photo_id -> {
            "filename": str,
            "faces": list of {face_id, bbox, face_index}
        }
    """
    embeddings_path = data_path / "embeddings.npy"
    if not embeddings_path.exists():
        return {}

    embeddings = np.load(embeddings_path, allow_pickle=True)

    # Group faces by photo_id
    photos = {}
    filename_face_counts = {}

    for entry in embeddings:
        filename = entry["filename"]

        # Track face index per filename
        if filename not in filename_face_counts:
            filename_face_counts[filename] = 0
        face_index = filename_face_counts[filename]
        filename_face_counts[filename] += 1

        photo_id = generate_photo_id(filename)
        # Use stored face_id if present (inbox format), otherwise generate legacy format
        face_id = entry.get("face_id") or generate_face_id(filename, face_index)

        # Parse bbox - it might be a string or list
        bbox = entry["bbox"]
        if isinstance(bbox, str):
            bbox = json.loads(bbox)
        elif hasattr(bbox, "tolist"):
            bbox = bbox.tolist()

        if photo_id not in photos:
            photos[photo_id] = {
                "filename": filename,
                "faces": [],
            }

        photos[photo_id]["faces"].append({
            "face_id": face_id,
            "bbox": bbox,  # [x1, y1, x2, y2]
            "face_index": face_index,
            "det_score": float(entry.get("det_score", 0)),
            "quality": float(entry.get("quality", 0)),
        })

    return photos


_photo_dimensions_cache = None


def _load_photo_dimensions_cache() -> dict:
    """Load photo dimensions from photo_index.json into a cache."""
    global _photo_dimensions_cache
    if _photo_dimensions_cache is not None:
        return _photo_dimensions_cache

    _photo_dimensions_cache = {}
    photo_index_path = data_path / "photo_index.json"
    if photo_index_path.exists():
        try:
            import json
            with open(photo_index_path) as f:
                data = json.load(f)
            for photo_id, photo_data in data.get("photos", {}).items():
                width = photo_data.get("width", 0)
                height = photo_data.get("height", 0)
                if width > 0 and height > 0:
                    # Index by path and by filename for flexible lookup
                    path = photo_data.get("path", "")
                    if path:
                        _photo_dimensions_cache[path] = (width, height)
                        _photo_dimensions_cache[Path(path).name] = (width, height)
        except Exception as e:
            logging.warning(f"Failed to load photo dimensions cache: {e}")

    return _photo_dimensions_cache


def get_photo_dimensions(filename: str) -> tuple:
    """
    Get image dimensions for a photo.

    Args:
        filename: Photo filename (looked up in raw_photos/).

    Returns:
        (width, height) tuple or (0, 0) if file not found
    """
    basename = Path(filename).name

    # In R2 mode, photos aren't stored locally, so use cached dimensions
    # from photo_index.json instead of reading from filesystem
    if storage.is_r2_mode():
        cache = _load_photo_dimensions_cache()
        if basename in cache:
            return cache[basename]
        return (0, 0)

    # Local mode: read from filesystem
    filepath = photos_path / basename
    if not filepath.exists():
        return (0, 0)

    try:
        with Image.open(filepath) as img:
            return img.size  # (width, height)
    except Exception:
        return (0, 0)


def get_identity_for_face(registry, face_id: str) -> dict:
    """
    Find the identity containing a face.

    Returns:
        Identity dict or None if not found
    """
    for identity in registry.list_identities():
        all_face_ids = identity.get("anchor_ids", []) + identity.get("candidate_ids", [])
        for entry in all_face_ids:
            fid = entry if isinstance(entry, str) else entry.get("face_id")
            if fid == face_id:
                return identity
    return None


def find_shared_photo_filename(
    target_id: str,
    neighbor_id: str,
    registry,
    photo_registry,
) -> str:
    """
    Find the filename of a shared photo between two identities.

    Used to show users why a merge is blocked (co-occurrence).

    Returns:
        Filename of shared photo, or empty string if none found.
    """
    # Get all face IDs for both identities
    faces_a = registry.get_all_face_ids(target_id)
    faces_b = registry.get_all_face_ids(neighbor_id)

    # Get photo_ids for each identity's faces
    photos_a = photo_registry.get_photos_for_faces(faces_a)
    photos_b = photo_registry.get_photos_for_faces(faces_b)

    # Find intersection
    shared_photos = photos_a & photos_b

    if shared_photos:
        # Get filename for first shared photo
        first_photo_id = next(iter(shared_photos))
        photo_path = photo_registry.get_photo_path(first_photo_id)
        if photo_path:
            return Path(photo_path).name

    return ""


def _compute_co_occurrence(
    identity_a_id: str,
    identity_b_id: str,
    registry,
    photo_registry,
) -> int:
    """
    Count how many photos two identities appear in together.

    Strong evidence they are different people (or family members in the same photo).
    Uses anchor + candidate face IDs for both identities.

    Returns:
        Number of shared photos (0 if none).
    """
    faces_a = (
        registry.get_anchor_face_ids(identity_a_id)
        + registry.get_candidate_face_ids(identity_a_id)
    )
    faces_b = (
        registry.get_anchor_face_ids(identity_b_id)
        + registry.get_candidate_face_ids(identity_b_id)
    )

    photos_a = photo_registry.get_photos_for_faces(faces_a)
    photos_b = photo_registry.get_photos_for_faces(faces_b)

    return len(photos_a & photos_b)


def get_first_anchor_face_id(identity_id: str, registry) -> str | None:
    """
    Get the best-quality anchor face ID for an identity.

    Used for showing thumbnails in neighbor cards.
    Falls back to the first anchor if quality data is unavailable.

    Returns:
        Best anchor face ID, or None if identity has no anchors.
    """
    try:
        anchor_ids = registry.get_anchor_face_ids(identity_id)
        if not anchor_ids:
            return None
        return get_best_face_id(anchor_ids)
    except KeyError:
        return None


# Photo metadata cache (rebuilt on each request for simplicity)
_photo_cache = None
_face_to_photo_cache = None


def _build_caches():
    """Build photo and face-to-photo caches.

    Loads raw detections from embeddings.npy, then filters each photo's
    face list to only include faces registered in photo_index.json.
    This removes noise detections (e.g., a newspaper photo might have
    63 raw detections but only 21 real registered faces).
    """
    global _photo_cache, _face_to_photo_cache
    if _photo_cache is None:
        _photo_cache = load_embeddings_for_photos()

        # Merge source data and filter faces using photo_index.json
        try:
            from core.photo_registry import PhotoRegistry
            photo_registry = PhotoRegistry.load(data_path / "photo_index.json")

            # Build filename-based fallback maps for photos with mismatched IDs
            # (e.g., inbox_* IDs in photo_index.json vs SHA256 IDs in _photo_cache)
            filename_to_source = {}
            filename_to_collection = {}
            filename_to_source_url = {}
            filename_to_face_ids = {}
            for pid in photo_registry._photos:
                path = photo_registry.get_photo_path(pid)
                source = photo_registry.get_source(pid)
                collection = photo_registry.get_collection(pid)
                source_url = photo_registry.get_source_url(pid)
                face_ids = photo_registry.get_faces_in_photo(pid)
                if path:
                    fname = Path(path).name
                    if source:
                        filename_to_source[fname] = source
                    if collection:
                        filename_to_collection[fname] = collection
                    if source_url:
                        filename_to_source_url[fname] = source_url
                    filename_to_face_ids[fname] = face_ids

            for photo_id in _photo_cache:
                filename = _photo_cache[photo_id].get("filename", "")
                fname = Path(filename).name

                # Filter faces to only registered ones from photo_index
                registered_ids = filename_to_face_ids.get(fname)
                if registered_ids:
                    _photo_cache[photo_id]["faces"] = [
                        f for f in _photo_cache[photo_id]["faces"]
                        if f["face_id"] in registered_ids
                    ]

                # Set source (provenance)
                source = photo_registry.get_source(photo_id)
                if not source:
                    source = filename_to_source.get(fname, "")
                _photo_cache[photo_id]["source"] = source

                # Set collection (classification)
                collection = photo_registry.get_collection(photo_id)
                if not collection:
                    collection = filename_to_collection.get(fname, "")
                _photo_cache[photo_id]["collection"] = collection

                # Set source_url (citation)
                source_url = photo_registry.get_source_url(photo_id)
                if not source_url:
                    source_url = filename_to_source_url.get(fname, "")
                _photo_cache[photo_id]["source_url"] = source_url

                # Merge photo metadata (BE-012)
                metadata = photo_registry.get_metadata(photo_id)
                if metadata:
                    _photo_cache[photo_id].update(metadata)
        except FileNotFoundError:
            # No photo_index.json yet, set empty sources
            for photo_id in _photo_cache:
                _photo_cache[photo_id]["source"] = ""

        # Build reverse mapping AFTER filtering: face_id -> photo_id
        _face_to_photo_cache = {}
        for photo_id, photo_data in _photo_cache.items():
            for face in photo_data["faces"]:
                _face_to_photo_cache[face["face_id"]] = photo_id


def get_photo_metadata(photo_id: str) -> dict:
    """Get photo metadata including face bboxes."""
    _build_caches()
    return _photo_cache.get(photo_id)


def get_photo_id_for_face(face_id: str) -> str:
    """Get the photo_id containing a face."""
    _build_caches()
    return _face_to_photo_cache.get(face_id)


def get_face_quality(face_id: str) -> float:
    """Look up face quality score from embeddings cache.

    Returns the quality score stored in embeddings.npy for this face,
    or None if not found. This is needed because inbox-style crop
    filenames don't encode quality in the filename.
    """
    photo_id = get_photo_id_for_face(face_id)
    if not photo_id:
        return None
    photo = _photo_cache.get(photo_id)
    if not photo:
        return None
    for face in photo.get("faces", []):
        if face.get("face_id") == face_id:
            q = face.get("quality", 0)
            return q if q > 0 else None
    return None


def _get_face_cache_entry(face_id: str) -> dict | None:
    """Look up full face data (bbox, det_score, quality) from embeddings cache."""
    _build_caches()
    photo_id = get_photo_id_for_face(face_id)
    if not photo_id:
        return None
    photo = _photo_cache.get(photo_id)
    if not photo:
        return None
    for face in photo.get("faces", []):
        if face.get("face_id") == face_id:
            return face
    return None


def compute_face_quality_score(face_id: str) -> float:
    """Compute composite quality score (0-100) for a face.

    Components:
    - Detection confidence (0-30 pts): InsightFace SCRFD det_score
    - Face crop size (0-35 pts): pixel area from bounding box
    - Embedding norm (0-35 pts): proxy for image quality (MagFace principle)

    Returns 0 if face data is not found.
    """
    face = _get_face_cache_entry(face_id)
    if not face:
        return 0.0

    score = 0.0

    # 1. Detection confidence — 0-30 pts
    det_score = face.get("det_score", 0.5)
    score += det_score * 30

    # 2. Face crop size from bbox — 0-35 pts
    # Good faces are 150+ pixels on a side (~22500 area)
    bbox = face.get("bbox", [0, 0, 0, 0])
    if len(bbox) == 4:
        face_width = abs(bbox[2] - bbox[0])
        face_height = abs(bbox[3] - bbox[1])
        face_area = face_width * face_height
        # Scale: 0=tiny, 1=good (22500px²=150×150)
        area_factor = min(face_area / 22500.0, 1.0)
        score += area_factor * 35

    # 3. Embedding norm — 0-35 pts
    # Raw quality is the embedding L2 norm (~15-30 range typically)
    raw_quality = face.get("quality", 0)
    if raw_quality > 0:
        # Normalize: 15 = low, 30 = high quality
        norm_factor = max(min((raw_quality - 15) / 15.0, 1.0), 0.0)
        score += norm_factor * 35

    return round(score, 1)


def get_best_face_id(face_ids: list) -> str | None:
    """Pick the highest-quality face from a list of face IDs.

    Returns the face_id with the highest composite quality score,
    or the first one if scores can't be computed.
    """
    if not face_ids:
        return None

    # Normalize: face_ids can be strings or dicts
    ids = []
    for f in face_ids:
        if isinstance(f, str):
            ids.append(f)
        elif isinstance(f, dict):
            ids.append(f.get("face_id", ""))
        else:
            ids.append(str(f))

    if len(ids) == 1:
        return ids[0]

    best_id = ids[0]
    best_score = -1
    for fid in ids:
        s = compute_face_quality_score(fid)
        if s > best_score:
            best_score = s
            best_id = fid
    return best_id


def _highlight_match(name: str, query: str):
    """Return FastHTML elements with the matched portion highlighted.

    Case-insensitive substring match. When the exact query doesn't match,
    tries surname variant terms (e.g., query "Capelluto" highlights "Capeluto"
    in "Leon Capeluto").
    """
    if not query:
        return name
    idx = name.lower().find(query.lower())
    if idx == -1:
        # Try variant terms — if query word maps to a variant group,
        # highlight whichever variant appears in the name
        from core.registry import _load_surname_variants
        variant_lookup = _load_surname_variants()
        for word in query.lower().split():
            if word in variant_lookup:
                for variant in variant_lookup[word]:
                    vidx = name.lower().find(variant)
                    if vidx != -1:
                        before = name[:vidx]
                        match = name[vidx:vidx + len(variant)]
                        after = name[vidx + len(variant):]
                        return (
                            Span(before) if before else None,
                            Span(match, cls="text-amber-300 font-semibold"),
                            Span(after) if after else None,
                        )
        return name
    before = name[:idx]
    match = name[idx:idx + len(query)]
    after = name[idx + len(query):]
    return (
        Span(before) if before else None,
        Span(match, cls="text-amber-300 font-semibold"),
        Span(after) if after else None,
    )


def parse_quality_from_filename(filename: str) -> float:
    """Extract quality score from filename like 'brass_rail_21.98_0.jpg'."""
    match = re.search(r'_(\d+\.\d+)_\d+\.jpg$', filename)
    if match:
        return float(match.group(1))
    return 0.0


def photo_url(filename: str) -> str:
    """
    Generate a properly URL-encoded path for a photo.

    In local mode: returns /photos/{filename} (served by app route)
    In R2 mode: returns Cloudflare R2 public URL for raw_photos/
    """
    return storage.get_photo_url(filename)


_crop_files_cache = None


def get_crop_files():
    """
    Get set of available crop filenames.

    In local mode: reads from static/crops directory.
    In R2 mode: builds the expected crop filenames from embeddings data,
    since we can't list R2 bucket contents.

    Crop filename format: {sanitized_stem}_{quality:.2f}_{face_index}.jpg
    """
    global _crop_files_cache
    if _crop_files_cache is not None:
        return _crop_files_cache

    # Try local mode first
    crops_dir = static_path / "crops"
    if crops_dir.exists():
        crop_files = {f.name for f in crops_dir.glob("*.jpg")}
        if crop_files:
            _crop_files_cache = crop_files
            return _crop_files_cache

    # R2 mode or no local crops: build from embeddings
    # The embeddings have: filename, quality, and we compute face_index
    # by tracking order of faces within each unique filename
    crop_files = set()

    embeddings_path = Path(DATA_DIR) / "embeddings.npy"
    if embeddings_path.exists():
        try:
            embeddings = np.load(embeddings_path, allow_pickle=True)
            filename_face_counts = {}

            for entry in embeddings:
                if not isinstance(entry, dict):
                    continue

                filename = entry.get("filename", "")
                quality = entry.get("quality")

                if not filename or quality is None:
                    continue

                # Get face index (order within this filename)
                face_index = filename_face_counts.get(filename, 0)
                filename_face_counts[filename] = face_index + 1

                # Build crop filename
                stem = Path(filename).stem
                sanitized = stem.lower()
                sanitized = re.sub(r'[^a-z0-9]+', '_', sanitized)
                sanitized = sanitized.strip('_')

                crop_filename = f"{sanitized}_{quality:.2f}_{face_index}.jpg"
                crop_files.add(crop_filename)

        except Exception as e:
            logging.warning(f"Failed to build crop files from embeddings: {e}")

    _crop_files_cache = crop_files
    return _crop_files_cache


def sanitize_stem(stem: str) -> str:
    """
    Sanitize a filename stem to match crop file naming convention.
    Mirrors the logic in core/crop_faces.py:sanitize_filename().
    """
    sanitized = stem.lower()
    sanitized = re.sub(r'[^a-z0-9]+', '_', sanitized)
    sanitized = sanitized.strip('_')
    return sanitized


def _existing_suggestions_for_identity(identity_id: str, face_id_encoded: str) -> list:
    """Return FT elements showing existing pending suggestions for an identity.

    If there are pending name_suggestion annotations for this identity,
    returns "I Agree" buttons so community members can confirm them.
    """
    if not identity_id:
        return []
    try:
        annotations = _load_annotations()
    except Exception:
        return []

    pending = [
        a for a in annotations.get("annotations", {}).values()
        if a.get("target_id") == identity_id
        and a.get("type") == "name_suggestion"
        and a.get("status") in ("pending", "pending_unverified")
    ]
    if not pending:
        return []

    from urllib.parse import unquote
    import json as _json

    items = []
    for ann in pending:
        confirmations = len(ann.get("confirmations", []))
        people_count = 1 + confirmations  # original + confirmations
        items.append(Div(
            Div(
                Span(ann["value"], cls="text-sm font-medium text-amber-300"),
                Span(f"suggested by {people_count} {'person' if people_count == 1 else 'people'}",
                     cls="text-xs text-slate-500"),
                cls="flex flex-col"
            ),
            Button(
                "I Agree",
                hx_post="/api/annotations/submit",
                hx_vals=_json.dumps({
                    "target_type": "identity",
                    "target_id": identity_id,
                    "annotation_type": "name_suggestion",
                    "value": ann["value"],
                    "confidence": "likely",
                    "reason": f"face_tag:{unquote(face_id_encoded)}:agree",
                }),
                hx_target="closest div",
                hx_swap="outerHTML",
                cls="px-2 py-0.5 text-xs bg-emerald-700 text-white rounded hover:bg-emerald-600 flex-shrink-0",
                type="button",
            ),
            cls="flex items-center justify-between gap-2 px-2 py-1.5 bg-amber-900/20 border border-amber-700/30 rounded mb-1"
        ))
    return items


def resolve_face_image_url(face_id: str, crop_files: set) -> str:
    """
    Resolve a canonical face ID to its crop image URL.

    Supports two face_id formats:
    1. Legacy: {filename_stem}:face{index} -> {sanitized_stem}_{quality}_{index}.jpg
    2. Inbox: inbox_{hash} -> inbox_{hash}.jpg (direct mapping)

    In local mode: returns /static/crops/{filename}
    In R2 mode: returns Cloudflare R2 public URL

    Args:
        face_id: Canonical face identifier
        crop_files: Set of available crop filenames

    Returns:
        URL path to the crop image, or None if no matching crop file is found.
    """
    # Inbox format: face_ids starting with "inbox_" have crops named exactly {face_id}.jpg
    # In R2 mode, inbox crops aren't in embeddings.npy (and thus not in crop_files),
    # so we return the URL directly without checking crop_files.
    if face_id.startswith("inbox_"):
        inbox_crop = f"{face_id}.jpg"
        # In local mode, verify it exists; in R2 mode, assume it exists
        if storage.is_r2_mode() or inbox_crop in crop_files:
            return storage.get_crop_url_by_filename(inbox_crop)

    # Fall back to legacy format parsing
    # Legacy face_ids use format: {filename_stem}:face{index}
    if ":face" not in face_id:
        return None

    stem, face_suffix = face_id.rsplit(":face", 1)
    try:
        face_index = int(face_suffix)
    except ValueError:
        return None

    # Sanitize the stem to match crop file naming
    sanitized = sanitize_stem(stem)

    # Find matching crop file: {sanitized}_{quality}_{index}.jpg
    # Quality is a float like 22.17, index matches face_index
    pattern = re.compile(
        rf'^{re.escape(sanitized)}_[\d.]+_{face_index}\.jpg$'
    )

    for crop in crop_files:
        if pattern.match(crop):
            return storage.get_crop_url_by_filename(crop)

    return None


# =============================================================================
# UI COMPONENTS
# =============================================================================

def toast_container() -> Div:
    """
    Toast notification container.
    UX Intent: Non-blocking feedback for actions.
    """
    return Div(
        id="toast-container",
        cls="fixed top-4 right-4 z-[10001] flex flex-col gap-2"
    )


def toast(message: str, variant: str = "info") -> Div:
    """
    Single toast notification.
    Variants: success, error, warning, info
    """
    # UI BOUNDARY: sanitize message for safe rendering
    safe_message = ensure_utf8_display(message)

    colors = {
        "success": "bg-emerald-600 text-white",
        "error": "bg-red-600 text-white",
        "warning": "bg-amber-500 text-white",
        "info": "bg-stone-700 text-white",
    }
    icons = {
        "success": "\u2713",
        "error": "\u2717",
        "warning": "\u26a0",
        "info": "\u2139",
    }
    return Div(
        Span(icons.get(variant, ""), cls="mr-2"),
        Span(safe_message),
        cls=f"px-4 py-3 rounded shadow-lg flex items-center {colors.get(variant, colors['info'])} animate-fade-in",
        # Auto-dismiss after 4 seconds
        **{"_": "on load wait 4s then remove me"}
    )


def toast_with_undo(
    message: str,
    source_id: str,
    target_id: str,
    variant: str = "info",
) -> Div:
    """
    Toast notification with inline Undo button (D5).

    Used for "Not Same Person" rejection - allows immediate reversal.
    Auto-dismisses after 8 seconds (longer than standard toast to allow undo).
    """
    colors = {
        "success": "bg-emerald-600 text-white",
        "error": "bg-red-600 text-white",
        "warning": "bg-amber-500 text-white",
        "info": "bg-stone-700 text-white",
    }
    icons = {
        "success": "\u2713",
        "error": "\u2717",
        "warning": "\u26a0",
        "info": "\u2139",
    }
    return Div(
        Span(icons.get(variant, ""), cls="mr-2"),
        Span(message, cls="flex-1"),
        Button(
            "Undo",
            cls="ml-3 px-2 py-1 text-xs font-bold bg-white/20 hover:bg-white/30 rounded transition-colors",
            hx_post=f"/api/identity/{source_id}/unreject/{target_id}",
            hx_swap="outerHTML",
            hx_target="closest div",  # Replace the toast itself
            type="button",
        ),
        cls=f"px-4 py-3 rounded shadow-lg flex items-center {colors.get(variant, colors['info'])} animate-fade-in",
        # Longer dismiss time to allow undo
        **{"_": "on load wait 8s then remove me"}
    )


def _admin_dashboard_banner(counts: dict, current_section: str) -> Div:
    """Admin-only dashboard summary banner at the top of the workstation.

    Shows inbox count, skipped count, and quick links.
    Focus/Browse toggle lives in each section's header instead.
    Only rendered when user is admin.
    """
    to_review = counts.get("to_review", 0)
    skipped = counts.get("skipped", 0)
    confirmed = counts.get("confirmed", 0)
    proposals = counts.get("proposals", 0)
    photo_count = counts.get("photo_count", 0)

    stat_items = [
        ("To Review", to_review, "/?section=to_review&view=focus", "text-amber-400"),
        ("People", confirmed, "/?section=confirmed", "text-emerald-400"),
        ("Help Identify", skipped, "/?section=skipped", "text-yellow-400"),
    ]
    if proposals > 0:
        stat_items.append(("Proposals", proposals, "/admin/proposals", "text-blue-400"))

    stats_row = [
        A(
            Span(str(count), cls=f"font-bold text-lg {color}"),
            Span(f" {label}", cls="text-slate-400 text-xs"),
            href=link,
            cls="hover:bg-slate-700/50 px-3 py-1 rounded transition-colors",
        )
        for label, count, link, color in stat_items
    ]

    return Div(
        Div(
            *stats_row,
            cls="max-w-6xl mx-auto px-4 sm:px-8 flex items-center gap-4 flex-wrap",
        ),
        id="admin-dashboard-banner",
        cls="py-2 border-b border-slate-700/50 bg-slate-800/30",
    )


def mobile_header() -> Div:
    """
    Mobile top bar with hamburger menu button.
    Hidden on desktop (lg+), shown on smaller screens.
    """
    return Div(
        Button(
            NotStr('<svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16"/></svg>'),
            cls="text-white p-2 -ml-2",
            onclick="toggleSidebar()",
            type="button",
            aria_label="Open menu",
        ),
        Span("Rhodesli", cls="text-lg font-bold text-white"),
        cls="mobile-header fixed top-0 left-0 right-0 h-14 bg-slate-800 border-b border-slate-700 "
            "flex items-center gap-3 px-4 z-20",
        id="mobile-header",
    )


def _public_nav_links(active: str = "", user=None) -> list:
    """Build standard navigation links for public pages.

    Args:
        active: Which link is currently active (e.g., "photos", "map", "timeline")
        user: Current user (for Sign In link)
    """
    _inactive = "text-slate-300 hover:text-white text-sm font-medium transition-colors"
    _active = "text-white text-sm font-medium"
    links = [
        A("Photos", href="/photos", cls=_active if active == "photos" else _inactive),
        A("Collections", href="/collections", cls=_active if active == "collections" else _inactive),
        A("People", href="/people", cls=_active if active == "people" else _inactive),
        A("Map", href="/map", cls=_active if active == "map" else _inactive),
        A("Timeline", href="/timeline", cls=_active if active == "timeline" else _inactive),
        A("Tree", href="/tree", cls=_active if active == "tree" else _inactive),
        A("Connect", href="/connect", cls=_active if active == "connect" else _inactive),
        A("Compare", href="/compare", cls=_active if active == "compare" else _inactive),
    ]
    if is_auth_enabled() and not user:
        links.append(A("Sign In", href="/login", cls="text-indigo-400 hover:text-indigo-300 text-sm font-medium transition-colors"))
    return links


def sidebar(counts: dict, current_section: str = "to_review", user: "User | None" = None) -> Aside:
    """
    Collapsible sidebar navigation for the Command Center.

    Supports expanded (full labels + counts) and collapsed (icons only) states.
    Default: collapsed on mobile (< 768px), expanded on desktop.
    Collapse state persisted in localStorage.

    Args:
        counts: Dict with keys: to_review, confirmed, skipped, rejected
        current_section: Currently active section
        user: Current user (None if anonymous)
    """
    def nav_item(href: str, icon: str, label: str, count: int, section_key: str, color: str):
        """Single navigation item with badge. Adapts to collapsed state."""
        is_active = current_section == section_key

        # Dark theme: Active vs inactive styling
        if is_active:
            container_cls = f"bg-slate-700 text-white"
            badge_cls = f"bg-{color}-500 text-white"
        else:
            container_cls = "text-slate-300 hover:bg-slate-700/50"
            badge_cls = f"bg-{color}-500/20 text-{color}-400"

        return A(
            # Icon always visible
            Span(icon, cls="sidebar-icon text-base flex-shrink-0 w-5 text-center"),
            # Label shown when expanded
            Span(label, cls="sidebar-label ml-2 whitespace-nowrap"),
            # Badge shown when expanded
            Span(
                str(count),
                cls=f"sidebar-label ml-auto px-2 py-0.5 text-xs font-bold rounded-full {badge_cls}"
            ),
            href=href,
            title=f"{label} ({count})",
            onclick="closeSidebar()",
            cls=f"sidebar-nav-item flex items-center px-3 py-2 rounded-lg text-sm font-medium min-h-[44px] {container_cls}"
        )

    return Aside(
        # Header with collapse toggle
        Div(
            A(
                H1("Rhodesli", cls="sidebar-label text-lg font-bold text-white leading-tight"),
                P("Identity System", cls="sidebar-label text-xs text-slate-400 mt-0.5"),
                href="/",
                cls="flex-1 min-w-0 no-underline hover:opacity-80 transition-opacity"
            ),
            Button(
                Svg(
                    Path(stroke_linecap="round", stroke_linejoin="round", stroke_width="2",
                         d="M15 19l-7-7 7-7"),
                    cls="sidebar-chevron w-4 h-4 transition-transform duration-200",
                    fill="none", stroke="currentColor", viewBox="0 0 24 24"
                ),
                onclick="toggleSidebarCollapse()",
                cls="sidebar-collapse-btn hidden lg:flex items-center justify-center p-1 rounded text-slate-400 hover:text-white hover:bg-slate-700 transition-colors",
                title="Toggle sidebar"
            ),
            cls="flex items-center px-3 py-3 border-b border-slate-700/50"
        ),
        # Search input
        Div(
            Div(
                Svg(
                    Path(stroke_linecap="round", stroke_linejoin="round", stroke_width="2",
                         d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"),
                    cls="w-4 h-4 text-slate-400 flex-shrink-0",
                    fill="none", stroke="currentColor", viewBox="0 0 24 24"
                ),
                Input(type="text", name="q", placeholder="Search names...", autocomplete="off",
                      cls="sidebar-label bg-transparent border-none outline-none text-sm text-slate-200 placeholder-slate-500 w-full ml-2",
                      id="sidebar-search-input",
                      hx_get="/api/search", hx_trigger="keyup changed delay:300ms",
                      hx_target="#sidebar-search-results", hx_swap="innerHTML"),
                cls="flex items-center bg-slate-700/50 rounded-lg px-3 py-2"
            ),
            Div(id="sidebar-search-results", cls="sidebar-search-results"),
            cls="sidebar-search px-3 pt-3 pb-1 relative"
        ),
        # Upload Button (any logged-in user can upload; non-admin uploads go to moderation queue)
        Div(
            A(
                Svg(
                    Path(stroke_linecap="round", stroke_linejoin="round", stroke_width="2",
                         d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"),
                    cls="w-4 h-4 flex-shrink-0", fill="none", stroke="currentColor", viewBox="0 0 24 24"
                ),
                Span("Upload", cls="sidebar-label ml-2"),
                href="/upload", title="Upload photos",
                cls="flex items-center justify-center gap-0 w-full px-3 py-2 bg-indigo-600 text-white text-sm font-medium rounded-lg hover:bg-indigo-500 transition-colors"
            ) if user else None,
            cls="px-3 py-2"
        ),
        # Navigation
        Nav(
            # Review Section
            Div(
                P(
                    "Review",
                    cls="sidebar-label px-3 text-xs font-semibold text-slate-500 uppercase tracking-wider mb-1"
                ),
                nav_item("/?section=to_review", "📥", "New Matches", counts["to_review"], "to_review", "blue"),
                nav_item("/?section=skipped", "❓", "Help Identify", counts["skipped"], "skipped", "amber"),
                cls="mb-3"
            ),
            # Library Section
            Div(
                P(
                    "Library",
                    cls="sidebar-label px-3 text-xs font-semibold text-slate-500 uppercase tracking-wider mb-1"
                ),
                nav_item("/?section=confirmed", "✓", "People", counts["confirmed"], "confirmed", "green"),
                nav_item("/?section=rejected", "🗑️", "Dismissed", counts["rejected"], "rejected", "gray"),
                cls="mb-3"
            ),
            # Browse Section (photo-centric)
            Div(
                P(
                    "Browse",
                    cls="sidebar-label px-3 text-xs font-semibold text-slate-500 uppercase tracking-wider mb-1"
                ),
                nav_item("/?section=photos", "📷", "Photos", counts.get("photos", 0), "photos", "slate"),
                A(
                    Span("📂", cls="text-base leading-none flex-shrink-0 w-5 text-center"),
                    Span("Collections", cls="sidebar-label ml-2"),
                    href="/collections",
                    cls="flex items-center px-3 py-1.5 text-sm text-slate-300 hover:bg-slate-700/50 rounded-lg transition-colors"
                ),
                A(
                    Span("🗺️", cls="text-base leading-none flex-shrink-0 w-5 text-center"),
                    Span("Map", cls="sidebar-label ml-2"),
                    href="/map",
                    cls="flex items-center px-3 py-1.5 text-sm text-slate-300 hover:bg-slate-700/50 rounded-lg transition-colors"
                ),
                A(
                    Span("\U0001f4c5", cls="text-base leading-none flex-shrink-0 w-5 text-center"),
                    Span("Timeline", cls="sidebar-label ml-2"),
                    href="/timeline",
                    cls="flex items-center px-3 py-1.5 text-sm text-slate-300 hover:bg-slate-700/50 rounded-lg transition-colors"
                ),
                A(
                    Span("\U0001f333", cls="text-base leading-none flex-shrink-0 w-5 text-center"),
                    Span("Tree", cls="sidebar-label ml-2"),
                    href="/tree",
                    cls="flex items-center px-3 py-1.5 text-sm text-slate-300 hover:bg-slate-700/50 rounded-lg transition-colors"
                ),
                A(
                    Span("🔗", cls="text-base leading-none flex-shrink-0 w-5 text-center"),
                    Span("Connect", cls="sidebar-label ml-2"),
                    href="/connect",
                    cls="flex items-center px-3 py-1.5 text-sm text-slate-300 hover:bg-slate-700/50 rounded-lg transition-colors"
                ),
                A(
                    Span("🔍", cls="text-base leading-none flex-shrink-0 w-5 text-center"),
                    Span("Compare", cls="sidebar-label ml-2"),
                    href="/compare",
                    cls="flex items-center px-3 py-1.5 text-sm text-slate-300 hover:bg-slate-700/50 rounded-lg transition-colors"
                ),
                A(
                    Span("📖", cls="text-base leading-none flex-shrink-0 w-5 text-center"),
                    Span("About", cls="sidebar-label ml-2"),
                    href="/about",
                    cls="flex items-center px-3 py-1.5 text-sm text-slate-300 hover:bg-slate-700/50 rounded-lg transition-colors"
                ),
                cls="mb-3"
            ),
            # Admin Section (admin-only, with pending uploads badge)
            Div(
                P(
                    "Admin",
                    cls="sidebar-label px-3 text-xs font-semibold text-slate-500 uppercase tracking-wider mb-1"
                ),
                nav_item("/admin/pending", "📋", "Uploads", counts.get("pending_uploads", 0), "pending_uploads", "amber"),
                nav_item("/admin/approvals", "✅", "Approvals", counts.get("pending_annotations", 0), "approvals", "emerald"),
                nav_item("/admin/proposals", "🔗", "Proposals", counts.get("proposals", 0), "proposals", "indigo"),
                A(
                    Span("🌳", cls="text-base leading-none flex-shrink-0 w-5 text-center"),
                    Span("GEDCOM", cls="sidebar-label ml-2"),
                    href="/admin/gedcom",
                    cls="flex items-center px-3 py-1.5 text-sm text-slate-300 hover:bg-slate-700/50 rounded-lg transition-colors"
                ),
                cls="mb-3"
            ) if (user and user.is_admin) else None,
            cls="flex-1 px-2 py-2 space-y-0 overflow-y-auto"
        ),
        # Footer with user info and stats
        Div(
            Div(
                Div(
                    Span(user.email, cls="sidebar-label text-xs text-slate-400 truncate"),
                    Span(" (admin)" if user.is_admin else "", cls="sidebar-label text-xs text-indigo-400"),
                    cls="flex items-center gap-1 min-w-0"
                ),
                A("Sign out", href="/logout", cls="sidebar-label text-xs text-slate-500 hover:text-slate-300 underline flex-shrink-0"),
                cls="flex items-center justify-between mb-1 gap-2"
            ) if user else Div(
                A("Sign in", href="/login", cls="sidebar-label text-xs text-slate-400 hover:text-slate-300 underline"),
                cls="mb-1"
            ),
            Div(
                f"{counts['confirmed']} of {counts['to_review'] + counts['confirmed'] + counts['skipped']} identified",
                cls="sidebar-label text-xs text-slate-500 font-data"
            ),
            Div(APP_VERSION, cls="sidebar-label text-xs text-slate-600 mt-0.5"),
            cls="px-3 py-2 border-t border-slate-700/50"
        ),
        # Close button for mobile
        Div(
            Button(
                Span("\u00d7", cls="text-2xl"),
                onclick="closeSidebar()",
                cls="text-slate-400 hover:text-white p-2 min-h-[44px] min-w-[44px] flex items-center justify-center"
            ),
            cls="absolute top-3 right-3 lg:hidden"
        ),
        id="sidebar",
        cls="sidebar-container fixed left-0 top-0 h-screen bg-slate-800 border-r border-slate-700/50 flex flex-col z-40 -translate-x-full lg:translate-x-0 transition-all duration-200"
    )


def section_header(title: str, subtitle: str, view_mode: str = None, section: str = None) -> Div:
    """
    Section header with optional Focus/Browse toggle.
    """
    header_content = [
        Div(
            H2(title, cls="text-2xl font-bold text-white"),
            P(subtitle, cls="text-sm text-slate-400 mt-1"),
        )
    ]

    # Add view toggle for sections that support it
    if section == "to_review" and view_mode is not None:
        toggle = Div(
            A(
                "Focus",
                href="/?section=to_review&view=focus",
                cls=f"px-3 py-1.5 text-sm font-medium rounded-lg {'bg-white text-slate-900' if view_mode == 'focus' else 'bg-slate-700 text-slate-300 hover:bg-slate-600'}"
            ),
            A(
                "View All",
                href="/?section=to_review&view=browse",
                cls=f"px-3 py-1.5 text-sm font-medium rounded-lg {'bg-white text-slate-900' if view_mode == 'browse' else 'bg-slate-700 text-slate-300 hover:bg-slate-600'}"
            ),
            A(
                "Match",
                href="/?section=to_review&view=match",
                cls=f"px-3 py-1.5 text-sm font-medium rounded-lg {'bg-amber-500 text-white' if view_mode == 'match' else 'bg-slate-700 text-slate-300 hover:bg-slate-600'}"
            ),
            cls="flex items-center gap-2"
        )
        header_content.append(toggle)
    elif section == "skipped" and view_mode is not None:
        toggle = Div(
            A(
                "Focus",
                href="/?section=skipped&view=focus",
                cls=f"px-3 py-1.5 text-sm font-medium rounded-lg {'bg-white text-slate-900' if view_mode == 'focus' else 'bg-slate-700 text-slate-300 hover:bg-slate-600'}"
            ),
            A(
                "View All",
                href="/?section=skipped&view=browse",
                cls=f"px-3 py-1.5 text-sm font-medium rounded-lg {'bg-white text-slate-900' if view_mode == 'browse' else 'bg-slate-700 text-slate-300 hover:bg-slate-600'}"
            ),
            cls="flex items-center gap-2"
        )
        header_content.append(toggle)

    return Div(
        *header_content,
        cls="section-header flex items-center justify-between mb-6"
    )


def _proposal_banner(identity_id: str):
    """Show a proposal banner if ML found a match for this identity."""
    best = _get_best_proposal_for_identity(identity_id)
    if not best:
        return None
    confidence = best.get("confidence", "")
    target_name = best.get("target_identity_name", "Unknown")
    distance = best.get("distance", 0)
    confidence_pct = max(0, min(100, int((1 - distance / 2.0) * 100)))

    color_cls = {
        "VERY HIGH": "bg-emerald-900/30 border-emerald-500/50 text-emerald-300",
        "HIGH": "bg-blue-900/30 border-blue-500/50 text-blue-300",
        "MODERATE": "bg-amber-900/30 border-amber-500/50 text-amber-300",
    }.get(confidence, "bg-slate-700/30 border-slate-500/50 text-slate-300")

    all_proposals = _get_proposals_for_identity(identity_id)
    count_text = f" (+{len(all_proposals) - 1} more)" if len(all_proposals) > 1 else ""

    return Div(
        Span(f"ML Match: {confidence}", cls="text-xs font-bold uppercase"),
        Span(" — ", cls="text-xs opacity-50"),
        Span(f"Likely {target_name}", cls="text-sm font-medium"),
        Span(f" ({confidence_pct}%)", cls="text-xs opacity-70"),
        Span(count_text, cls="text-xs opacity-50") if count_text else None,
        cls=f"mt-2 px-3 py-2 rounded-lg border text-sm {color_cls}",
    )


def _proposal_badge_inline(identity_id: str):
    """Compact inline badge showing ML match count for browse view cards."""
    proposals = _get_proposals_for_identity(identity_id)
    if not proposals:
        return None
    best = min(proposals, key=lambda p: p.get("distance", 999))
    confidence = best.get("confidence", "")
    count = len(proposals)
    label = f"{count} match{'es' if count > 1 else ''}"

    color_cls = {
        "VERY HIGH": "bg-emerald-600/30 text-emerald-300 border-emerald-500/30",
        "HIGH": "bg-blue-600/30 text-blue-300 border-blue-500/30",
        "MODERATE": "bg-amber-600/30 text-amber-300 border-amber-500/30",
    }.get(confidence, "bg-slate-600/30 text-slate-300 border-slate-500/30")

    return Span(
        f"{label}",
        cls=f"text-xs px-2 py-0.5 rounded border {color_cls}",
        title=f"ML: Likely {best.get('target_identity_name', '?')} ({confidence})",
    )


def identity_card_expanded(identity: dict, crop_files: set, is_admin: bool = True, triage_filter: str = "") -> Div:
    """
    Expanded identity card for Focus Mode review.
    Shows larger thumbnail and prominent actions (admin only).

    Args:
        triage_filter: Active triage filter to preserve in action URLs
    """
    identity_id = identity["identity_id"]
    raw_name = ensure_utf8_display(identity.get("name"))
    name = raw_name or f"Unidentified Person"
    state = identity["state"]

    # Get all faces
    all_face_ids = identity.get("anchor_ids", []) + identity.get("candidate_ids", [])
    face_count = len(all_face_ids)

    # Get best-quality face for main thumbnail
    main_crop_url = None
    main_photo_id = None
    best_face_id = get_best_face_id(all_face_ids)
    if best_face_id:
        main_crop_url = resolve_face_image_url(best_face_id, crop_files)
        main_photo_id = get_photo_id_for_face(best_face_id)

    # Build face grid for additional faces (skip best since it's shown as main thumbnail)
    face_previews = []
    for face_entry in all_face_ids[:6]:  # Show up to 6, skip the best one
        if isinstance(face_entry, str):
            face_id = face_entry
        else:
            face_id = face_entry.get("face_id", "")
        if face_id == best_face_id:
            continue  # Already shown as main thumbnail
        crop_url = resolve_face_image_url(face_id, crop_files)
        if crop_url:
            # Get photo_id for this face to make it clickable
            face_photo_id = get_photo_id_for_face(face_id)
            if face_photo_id:
                face_previews.append(
                    Button(
                        Img(
                            src=crop_url,
                            cls="w-16 h-16 rounded object-cover border border-slate-600 hover:border-indigo-400 hover:scale-110 transition-all",
                            alt=f"Face {face_id[:8]}"
                        ),
                        cls="p-0 bg-transparent cursor-pointer hover:ring-2 hover:ring-indigo-400 rounded transition-all",
                        hx_get=f"/photo/{face_photo_id}/partial?face={face_id}&identity_id={identity_id}",
                        hx_target="#photo-modal-content",
                        **{"_": "on click remove .hidden from #photo-modal"},
                        type="button",
                        title="Click to view photo"
                    )
                )
            else:
                face_previews.append(
                    Img(
                        src=crop_url,
                        cls="w-16 h-16 rounded object-cover border border-slate-600",
                        alt=f"Face {face_id[:8]}"
                    )
                )

    # Action buttons - only for admins
    if is_admin:
        base_confirm_url = f"/inbox/{identity_id}/confirm" if state == "INBOX" else f"/confirm/{identity_id}"
        base_reject_url = f"/inbox/{identity_id}/reject" if state == "INBOX" else f"/reject/{identity_id}"
        _filter_suffix = f"&filter={triage_filter}" if triage_filter else ""
        confirm_url = f"{base_confirm_url}?from_focus=true{_filter_suffix}"
        reject_url = f"{base_reject_url}?from_focus=true{_filter_suffix}"
        skip_url = f"/identity/{identity_id}/skip?from_focus=true{_filter_suffix}"

        actions = Div(
            Button(
                "✓ Confirm",
                cls="px-4 py-2 bg-green-500 text-white font-medium rounded-lg hover:bg-green-600 transition-colors min-h-[44px]",
                hx_post=confirm_url,
                hx_target="#focus-container",
                hx_swap="outerHTML",
                type="button",
                id="focus-btn-confirm",
            ),
            Button(
                "⏸ Skip",
                cls="px-4 py-2 bg-yellow-500 text-white font-medium rounded-lg hover:bg-yellow-600 transition-colors min-h-[44px]",
                hx_post=skip_url,
                hx_target="#focus-container",
                hx_swap="outerHTML",
                type="button",
                id="focus-btn-skip",
            ),
            Button(
                "✗ Reject",
                cls="px-4 py-2 bg-red-500 text-white font-medium rounded-lg hover:bg-red-600 transition-colors min-h-[44px]",
                hx_post=reject_url,
                hx_target="#focus-container",
                hx_swap="outerHTML",
                type="button",
                id="focus-btn-reject",
            ),
            Button(
                "Find Similar",
                cls="px-4 py-2 bg-slate-700 text-slate-300 font-medium rounded-lg hover:bg-slate-600 transition-colors ml-auto min-h-[44px]",
                hx_get=f"/api/identity/{identity_id}/neighbors?from_focus=true",
                hx_target=f"#neighbors-{identity_id}",
                hx_swap="innerHTML",
                type="button",
                id="focus-btn-similar",
                **{"hx-on::after-swap": f"document.getElementById('neighbors-{identity_id}').scrollIntoView({{behavior: 'smooth', block: 'start'}})"},
            ),
            Span(
                "Keyboard: C S R F",
                cls="text-xs text-slate-600 hidden sm:inline ml-2",
                title="C=Confirm, S=Skip, R=Reject, F=Find Similar"
            ),
            cls="flex flex-wrap items-center gap-3 mt-6"
        )
    else:
        actions = Div(
            Button(
                "Find Similar",
                cls="px-4 py-2 bg-slate-700 text-slate-300 font-medium rounded-lg hover:bg-slate-600 transition-colors",
                hx_get=f"/api/identity/{identity_id}/neighbors?from_focus=true",
                hx_target=f"#neighbors-{identity_id}",
                hx_swap="innerHTML",
                type="button",
                **{"hx-on::after-swap": f"document.getElementById('neighbors-{identity_id}').scrollIntoView({{behavior: 'smooth', block: 'start'}})"},
            ),
            Button(
                "I Know This Person",
                cls="px-4 py-2 bg-indigo-600 text-white font-medium rounded-lg hover:bg-indigo-500 transition-colors",
                **{"_": f"on click toggle .hidden on #suggest-name-{identity_id}"},
                type="button",
            ),
            cls="flex items-center gap-3 mt-6"
        )

    return Div(
        Div(
            # Left: Main Face (clickable to open photo)
            Div(
                Button(
                    Div(
                        Img(
                            src=main_crop_url or "",
                            alt=name,
                            cls="w-full h-full object-cover"
                        ) if main_crop_url else Span("?", cls="text-6xl text-slate-500"),
                        cls="w-48 h-48 sm:w-72 sm:h-72 rounded-lg overflow-hidden bg-slate-700 flex items-center justify-center"
                    ),
                    cls="p-0 bg-transparent cursor-pointer hover:ring-2 hover:ring-indigo-400 rounded-lg transition-all",
                    hx_get=f"/photo/{main_photo_id}/partial?face={face_id}&identity_id={identity_id}" if main_photo_id else None,
                    hx_target="#photo-modal-content",
                    **{"_": "on click remove .hidden from #photo-modal"} if main_photo_id else {},
                    type="button",
                    title="Click to view photo",
                ) if main_photo_id else Div(
                    Img(
                        src=main_crop_url,
                        alt=name,
                        cls="w-full h-full object-cover"
                    ) if main_crop_url else Span("?", cls="text-6xl text-slate-500"),
                    cls="w-48 h-48 sm:w-72 sm:h-72 rounded-lg overflow-hidden bg-slate-700 flex items-center justify-center"
                ),
                cls="flex-shrink-0"
            ),
            # Right: Details + Actions
            Div(
                H3(name, cls="text-xl font-semibold text-white"),
                P(
                    f"{face_count} face{'s' if face_count != 1 else ''}",
                    cls="text-sm text-slate-400 mt-1"
                ),
                # Proposal banner — shows ML match suggestion if one exists
                _proposal_banner(identity_id),
                # Face grid preview
                Div(
                    *face_previews,
                    cls="flex gap-2 mt-4 flex-wrap"
                ) if len(face_previews) > 1 else None,
                # Neighbors container — auto-load if proposals exist
                Div(
                    id=f"neighbors-{identity_id}", cls="mt-4",
                    **({"hx_get": f"/api/identity/{identity_id}/neighbors?from_focus=true",
                        "hx_trigger": "load",
                        "hx_swap": "innerHTML"}
                       if identity_id in _get_identities_with_proposals() else {}),
                ),
                actions,
                # Suggest Name form (hidden by default, shown via Hyperscript toggle)
                _suggest_name_form(identity_id),
                # Identity metadata (AN-012)
                _identity_metadata_display(identity, is_admin=is_admin),
                # Identity annotations (AN-013/AN-014)
                _identity_annotations_section(identity_id, is_admin=is_admin),
                # Notes section (loads via HTMX)
                Div(
                    Button(
                        "Notes",
                        cls="text-xs text-slate-400 hover:text-slate-300 underline",
                        hx_get=f"/api/identity/{identity_id}/notes",
                        hx_target=f"#notes-{identity_id}",
                        hx_swap="innerHTML",
                        type="button",
                    ),
                    Div(id=f"notes-{identity_id}", cls="mt-2"),
                    cls="mt-4 pt-3 border-t border-slate-700"
                ),
                cls="flex-1 min-w-0"
            ),
            cls="flex flex-col sm:flex-row gap-4 sm:gap-6"
        ),
        cls="bg-slate-800 rounded-xl shadow-lg border border-slate-700 p-4 sm:p-6",
        id="focus-card"
    )


def _suggest_name_form(identity_id: str) -> Div:
    """Hidden form for suggesting a name for an unidentified person."""
    return Div(
        H4("I Know This Person", cls="text-sm font-medium text-white mb-2"),
        Form(
            Input(type="hidden", name="target_type", value="identity"),
            Input(type="hidden", name="target_id", value=identity_id),
            Input(type="hidden", name="annotation_type", value="name_suggestion"),
            Input(
                name="value", placeholder="Enter name...",
                cls="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm text-white placeholder-slate-400",
                required=True,
            ),
            Select(
                Option("I'm certain", value="certain"),
                Option("Likely", value="likely", selected=True),
                Option("Just a guess", value="guess"),
                name="confidence",
                cls="w-full mt-2 bg-slate-700 border border-slate-600 rounded px-3 py-1.5 text-sm text-white",
            ),
            Input(
                name="reason", placeholder="How do you know? (optional)",
                cls="w-full mt-2 bg-slate-700 border border-slate-600 rounded px-3 py-2 text-sm text-white placeholder-slate-400",
            ),
            Button(
                "Submit Suggestion",
                type="submit",
                cls="mt-2 px-4 py-2 bg-indigo-600 text-white text-sm font-medium rounded hover:bg-indigo-500",
            ),
            hx_post="/api/annotations/submit",
            hx_swap="beforeend",
            hx_target="#toast-container",
            cls="space-y-0"
        ),
        cls="hidden mt-4 p-4 bg-slate-900/50 border border-indigo-500/30 rounded-lg",
        id=f"suggest-name-{identity_id}",
    )


def identity_card_mini(identity: dict, crop_files: set, clickable: bool = False, triage_filter: str = "") -> Div:
    """
    Mini identity card for queue preview in Focus Mode.

    Args:
        identity: Identity dict
        crop_files: Set of available crop files
        clickable: If True, clicking loads this identity in focus mode
        triage_filter: Active filter to preserve in navigation links
    """
    identity_id = identity["identity_id"]

    # Get best-quality face for thumbnail
    all_face_ids = identity.get("anchor_ids", []) + identity.get("candidate_ids", [])
    crop_url = None
    best_fid = get_best_face_id(all_face_ids)
    if best_fid:
        crop_url = resolve_face_image_url(best_fid, crop_files)

    img_element = Img(
        src=crop_url or "",
        cls="w-full h-full object-cover"
    ) if crop_url else Span("?", cls="text-2xl text-slate-500")

    if clickable:
        # Wrap in a link that loads this identity in focus mode (correct section)
        section = _section_for_state(identity.get("state", "INBOX"))
        filter_suffix = f"&filter={triage_filter}" if triage_filter else ""
        return A(
            Div(
                img_element,
                cls="w-full aspect-square rounded-lg overflow-hidden bg-slate-700 flex items-center justify-center hover:ring-2 hover:ring-indigo-400 transition-all"
            ),
            href=f"/?section={section}&view=focus&current={identity_id}{filter_suffix}",
            cls="w-24 flex-shrink-0 cursor-pointer",
            title="Click to review this identity"
        )
    else:
        return Div(
            Div(
                img_element,
                cls="w-full aspect-square rounded-lg overflow-hidden bg-slate-700 flex items-center justify-center"
            ),
            cls="w-24 flex-shrink-0"
        )


def render_to_review_section(
    to_review: list,
    crop_files: set,
    view_mode: str,
    counts: dict,
    current_id: str = None,
    is_admin: bool = True,
    sort_by: str = "newest",
    triage_filter: str = "",
) -> Div:
    """Render the To Review section with Focus or Browse mode."""

    # Build triage bar (shown above all views)
    triage_bar = _build_triage_bar(to_review, view_mode, active_filter=triage_filter)

    # Apply triage filter if set
    if triage_filter in ("ready", "rediscovered", "unmatched"):
        to_review = [i for i in to_review if _triage_category(i) == triage_filter]

    # For focus mode, prioritize by actionability:
    # 1. Confirmed match promotions (one-click merge available)
    # 2. Faces with Very High proposals to confirmed identities
    # 3. Faces with new_face_match or group_discovery promotion
    # 4. Faces with High proposals
    # 5. Remaining inbox faces
    ids_with_proposals = _get_identities_with_proposals()

    def _focus_sort_key(x):
        iid = x.get("identity_id", "")
        has_proposal = iid in ids_with_proposals
        best = _get_best_proposal_for_identity(iid) if has_proposal else None
        has_promotion = x.get("promoted_from") is not None
        promotion_reason = x.get("promotion_reason", "")

        # Priority tiers (lower = higher priority):
        # 0: confirmed_match promotion (highest value)
        # 1: Very High confidence proposal
        # 2: new_face_match / group_discovery promotion
        # 3: High confidence proposal
        # 4: Other proposals (Moderate/Low)
        # 5: No proposals, no promotion (unmatched)
        if has_promotion and promotion_reason == "confirmed_match":
            tier = 0
        elif has_proposal and best and best.get("confidence") == "VERY HIGH":
            tier = 1
        elif has_promotion:
            tier = 2
        elif has_proposal and best and best.get("confidence") == "HIGH":
            tier = 3
        elif has_proposal:
            tier = 4
        else:
            tier = 5

        # Quality tiebreaker — clear faces first within same tier
        quality = _identity_quality_score(x)

        return (
            tier,
            best["distance"] if best else 999,
            -quality,
            -len(x.get("anchor_ids", []) + x.get("candidate_ids", [])),
        )

    high_confidence = sorted(to_review, key=_focus_sort_key)[:10]

    # If a specific identity was requested, move it to the front
    if current_id and view_mode == "focus":
        # Find the requested identity
        current_identity = None
        remaining = []
        for item in high_confidence:
            if item["identity_id"] == current_id:
                current_identity = item
            else:
                remaining.append(item)
        # If not found in high_confidence, search full list
        if not current_identity:
            for item in to_review:
                if item["identity_id"] == current_id:
                    current_identity = item
                    break
        # Reorder with current at front
        if current_identity:
            high_confidence = [current_identity] + remaining[:9]

    if view_mode == "focus":
        if high_confidence:
            # Build Up Next carousel
            up_next = None
            if len(high_confidence) > 1:
                up_next = Div(
                    H3("Up Next", cls="text-sm font-medium text-slate-400 mb-3"),
                    Div(
                        *[identity_card_mini(i, crop_files, clickable=True, triage_filter=triage_filter) for i in high_confidence[1:6]],
                        A(
                            f"+{len(high_confidence) - 6} more",
                            href="/?section=to_review&view=browse",
                            cls="w-24 flex-shrink-0 flex items-center justify-center bg-slate-700 rounded-lg text-sm text-slate-400 aspect-square hover:bg-slate-600 transition-colors cursor-pointer"
                        ) if len(high_confidence) > 6 else None,
                        cls="flex gap-3 overflow-x-auto pb-2"
                    ),
                    cls="mt-6"
                )
            # Show promotion banner above the expanded card if applicable
            banner = _promotion_banner(high_confidence[0])
            # Show one item expanded + queue preview, wrapped in focus-container for HTMX swap.
            # Keyboard shortcuts (C/S/R/F) are handled by the global keydown handler
            # in the page layout — no per-swap re-registration needed.
            content = Div(
                banner,
                identity_card_expanded(high_confidence[0], crop_files, is_admin=is_admin, triage_filter=triage_filter),
                up_next,
                id="focus-container"
            )
        else:
            # Empty state
            content = Div(
                Div("🎉", cls="text-4xl mb-4"),
                H3("All caught up!", cls="text-lg font-medium text-white"),
                P("No items to review.", cls="text-slate-400 mt-1"),
                A(
                    "Upload more photos →",
                    href="/upload",
                    cls="inline-block mt-4 text-indigo-400 hover:text-indigo-300 font-medium"
                ),
                cls="bg-slate-800 rounded-xl shadow-lg border border-slate-700 p-12 text-center"
            )
    elif view_mode == "match":
        # Match mode - gamified side-by-side pairing
        match_url = f"/api/match/next-pair?filter={triage_filter}" if triage_filter else "/api/match/next-pair"
        content = Div(
            Div(
                Div(
                    Span("Matched: ", cls="text-slate-400"),
                    Span("0", id="match-counter", cls="text-white font-bold"),
                    Span(" pairs today", cls="text-slate-400"),
                    cls="text-sm"
                ),
                cls="flex items-center justify-between mb-4"
            ),
            Div(
                P("Loading next pair...", cls="text-slate-400 text-center py-8"),
                id="match-pair-container",
                hx_get=match_url,
                hx_trigger="load",
                hx_swap="innerHTML",
            ),
            Script("""
                // Match counter persistence via cookie
                function getMatchCount() {
                    var today = new Date().toISOString().slice(0, 10);
                    var stored = document.cookie.split(';').find(c => c.trim().startsWith('match_count_' + today + '='));
                    return stored ? parseInt(stored.split('=')[1]) : 0;
                }
                function incrementMatchCount() {
                    var today = new Date().toISOString().slice(0, 10);
                    var count = getMatchCount() + 1;
                    document.cookie = 'match_count_' + today + '=' + count + '; path=/; max-age=86400';
                    var el = document.getElementById('match-counter');
                    if (el) el.textContent = count;
                }
                // Initialize counter on load
                document.addEventListener('DOMContentLoaded', function() {
                    var el = document.getElementById('match-counter');
                    if (el) el.textContent = getMatchCount();
                });
            """),
            cls="bg-slate-800 rounded-xl shadow-lg border border-slate-700 p-6",
        )
    else:
        # Browse mode - apply sorting
        if sort_by == "faces":
            to_review = sorted(to_review, key=lambda x: len(x.get("anchor_ids", []) + x.get("candidate_ids", [])), reverse=True)
        elif sort_by == "name":
            to_review = sorted(to_review, key=lambda x: (x.get("name") or "").lower())
        # default: newest (already sorted by created_at desc above)

        cards = [
            identity_card(identity, crop_files, lane_color="blue", show_actions=True, is_admin=is_admin)
            for identity in to_review
        ]
        cards = [c for c in cards if c]  # Filter None

        if cards:
            content = Div(*cards)
        else:
            content = Div(
                "All caught up! No new faces to review right now.",
                cls="text-center py-12 text-slate-400"
            )

    # Build header with optional sort controls (browse mode only)
    header = section_header(
        "New Matches",
        f"{counts['to_review']} faces the AI matched \u2014 confirm or correct",
        view_mode=view_mode,
        section="to_review"
    )
    if view_mode == "browse":
        return Div(
            Div(header, _sort_control("to_review", sort_by), cls="flex items-center justify-between flex-wrap gap-2 mb-6"),
            triage_bar,
            content,
            cls="space-y-4"
        )
    return Div(header, triage_bar, content, cls="space-y-6")


def _sort_control(section: str, current_sort: str) -> Div:
    """Render sort control buttons for a section."""
    options = [
        ("name", "A-Z"),
        ("faces", "Faces"),
        ("newest", "Newest"),
    ]
    buttons = []
    for value, label in options:
        is_active = current_sort == value
        cls = "px-2 py-1 text-xs font-medium rounded transition-colors "
        if is_active:
            cls += "bg-slate-600 text-white"
        else:
            cls += "text-slate-400 hover:text-slate-200 hover:bg-slate-700/50"
        buttons.append(
            A(label, href=f"/?section={section}&sort_by={value}", cls=cls)
        )
    return Div(
        Span("Sort:", cls="text-xs text-slate-500 mr-1"),
        *buttons,
        cls="flex items-center gap-1"
    )


def render_confirmed_section(confirmed: list, crop_files: set, counts: dict, is_admin: bool = True, sort_by: str = "name") -> Div:
    """Render the Confirmed section with optional sorting."""
    # Apply sorting
    if sort_by == "faces":
        confirmed = sorted(confirmed, key=lambda x: len(x.get("anchor_ids", []) + x.get("candidate_ids", [])), reverse=True)
    elif sort_by == "newest":
        confirmed = sorted(confirmed, key=lambda x: x.get("updated_at", x.get("created_at", "")), reverse=True)
    else:  # default: name (A-Z)
        confirmed = sorted(confirmed, key=lambda x: (x.get("name") or "").lower())

    cards = [
        identity_card(identity, crop_files, lane_color="emerald", show_actions=False, is_admin=is_admin)
        for identity in confirmed
    ]
    cards = [c for c in cards if c]

    if cards:
        content = Div(*cards)
    else:
        content = Div(
            "No confirmed identities yet. Browse the inbox to help identify faces.",
            cls="text-center py-12 text-slate-400"
        )

    return Div(
        Div(
            section_header("People", f"{counts['confirmed']} identified \u2014 click anyone to see all their photos"),
            _sort_control("confirmed", sort_by),
            cls="flex items-center justify-between flex-wrap gap-2 mb-6"
        ),
        content,
        cls="space-y-4"
    )


def render_skipped_section(skipped: list, crop_files: set, counts: dict,
                           is_admin: bool = True, view_mode: str = "focus",
                           current_id: str = None) -> Div:
    """Render the Skipped section with Focus or Browse mode.

    Focus mode: guided one-at-a-time review with photo context and ML suggestions.
    Browse mode: grid of identity cards with lazy-loaded ML hints.
    """
    header = section_header(
        "Help Identify",
        f"{counts['skipped']} face{'s' if counts['skipped'] != 1 else ''} we need your help with \u2014 your family knowledge could be the key",
        view_mode=view_mode,
        section="skipped",
    )

    if view_mode == "focus":
        # Sort by actionability for focus mode
        sorted_skipped = _sort_skipped_by_actionability(skipped)

        # If a specific identity was requested, move it to the front
        if current_id:
            current_identity = None
            remaining = []
            for item in sorted_skipped:
                if item["identity_id"] == current_id:
                    current_identity = item
                else:
                    remaining.append(item)
            if not current_identity:
                for item in skipped:
                    if item["identity_id"] == current_id:
                        current_identity = item
                        break
            if current_identity:
                sorted_skipped = [current_identity] + remaining[:9]

        if sorted_skipped:
            # Build Up Next carousel
            up_next = None
            if len(sorted_skipped) > 1:
                up_next = Div(
                    H3("Up Next", cls="text-sm font-medium text-slate-400 mb-3"),
                    Div(
                        *[identity_card_mini(i, crop_files, clickable=True) for i in sorted_skipped[1:6]],
                        A(
                            f"+{len(sorted_skipped) - 6} more",
                            href="/?section=to_review&view=browse",
                            cls="w-24 flex-shrink-0 flex items-center justify-center bg-slate-700 rounded-lg text-sm text-slate-400 aspect-square hover:bg-slate-600 transition-colors cursor-pointer"
                        ) if len(sorted_skipped) > 6 else None,
                        cls="flex gap-3 overflow-x-auto pb-2"
                    ),
                    cls="mt-6"
                )

            # Progress counter
            total = counts["skipped"]
            progress = _skipped_focus_progress()

            content = Div(
                progress,
                skipped_card_expanded(sorted_skipped[0], crop_files, is_admin=is_admin),
                up_next,
                id="skipped-focus-container",
                data_focus_mode="skipped",
            )
        else:
            content = Div(
                Div("🎉", cls="text-4xl mb-4"),
                H3("All caught up!", cls="text-lg font-medium text-white"),
                P("No faces need help right now.", cls="text-slate-400 mt-1"),
                A(
                    "← Back to Inbox",
                    href="/?section=to_review",
                    cls="inline-block mt-4 text-indigo-400 hover:text-indigo-300 font-medium"
                ),
                cls="bg-slate-800 rounded-xl shadow-lg border border-slate-700 p-12 text-center",
                id="skipped-focus-container",
            )

        return Div(header, content, cls="space-y-6")

    # Browse mode (default fallback) — sort by actionability (best leads first)
    sorted_browse = _sort_skipped_by_actionability(skipped)
    ids_with_proposals = _get_identities_with_proposals()
    cards = []
    for identity in sorted_browse:
        card = identity_card(identity, crop_files, lane_color="stone", show_actions=False, is_admin=is_admin)
        if card:
            # Add lazy-loaded ML hint below each skipped card
            identity_id = identity["identity_id"]
            # Add actionability badge
            badge = _actionability_badge(identity_id, ids_with_proposals)
            hint = Div(
                id=f"skip-hint-{identity_id}",
                hx_get=f"/api/identity/{identity_id}/skip-hints",
                hx_trigger="revealed",
                hx_swap="innerHTML",
                cls="ml-4 mt-1 mb-3",
            )
            # Wrapper carries data-name so sidebar filter hides card+hint together
            raw_name = (identity.get("name") or "").lower()
            cards.append(Div(badge, card, hint, cls="identity-card-wrapper", data_name=raw_name))

    if cards:
        content = Div(*cards)
    else:
        content = Div(
            "No unresolved faces right now. Check the inbox for new arrivals.",
            cls="text-center py-12 text-slate-400"
        )

    return Div(header, content, cls="space-y-6")


_skipped_neighbor_cache = None
_skipped_neighbor_cache_key = None


def _get_skipped_neighbor_distances(skipped: list) -> dict:
    """Get best-neighbor distances for all skipped identities.

    Uses proposals first, falls back to batch neighbor computation.
    Results are cached for the lifetime of the process (invalidated on data reload).
    """
    global _skipped_neighbor_cache, _skipped_neighbor_cache_key
    cache_key = len(skipped)  # Simple cache invalidation
    if _skipped_neighbor_cache is not None and _skipped_neighbor_cache_key == cache_key:
        return _skipped_neighbor_cache

    ids_with_proposals = _get_identities_with_proposals()
    result = {}

    # First, use proposals for any identities that have them
    for identity in skipped:
        iid = identity.get("identity_id", "")
        if iid in ids_with_proposals:
            best = _get_best_proposal_for_identity(iid)
            if best:
                target_name = best.get("target_name", best.get("name", ""))
                result[iid] = (best.get("distance", 999), best.get("confidence", "LOW"), target_name)

    # For identities without proposals, compute batch neighbors
    needs_computation = [i["identity_id"] for i in skipped if i["identity_id"] not in result]
    if needs_computation:
        try:
            from core.neighbors import batch_best_neighbor_distances
            registry = load_registry()
            face_data = get_face_data()
            batch_results = batch_best_neighbor_distances(needs_computation, registry, face_data)
            for iid, (dist, neighbor_id, neighbor_name) in batch_results.items():
                if dist < 999:
                    if dist < 0.80:
                        confidence = "VERY HIGH"
                    elif dist < 1.00:
                        confidence = "HIGH"
                    elif dist < 1.20:
                        confidence = "MODERATE"
                    else:
                        confidence = "LOW"
                    result[iid] = (dist, confidence, neighbor_name or "")
        except (ImportError, Exception) as e:
            print(f"[sort] Batch neighbor computation failed: {e}")

    _skipped_neighbor_cache = result
    _skipped_neighbor_cache_key = cache_key
    return result


def _identity_quality_score(identity: dict) -> float:
    """Get the best face quality score for an identity (0-100).

    Used for ordering — clear, high-quality faces should appear before
    blurry or small ones within the same confidence tier.
    """
    face_ids = identity.get("anchor_ids", []) + identity.get("candidate_ids", [])
    if not face_ids:
        return 0.0
    best_id = get_best_face_id(face_ids)
    if best_id:
        return compute_face_quality_score(best_id)
    return 0.0


def _sort_skipped_by_actionability(skipped: list) -> list:
    """Sort skipped identities by actionability — best leads first.

    Priority tiers (lower = higher priority):
      0: Has VERY HIGH confidence match (near-certain)
      1: Has HIGH confidence match
      2: Has MODERATE or lower match
      3: No matches found

    Within each tier, sort by:
      1. Named match target bonus (named targets like "Rica Moussafer" before "Unidentified Person 310")
      2. Distance ascending (closest match first)
      3. Face quality descending (clear faces before blurry ones)

    Uses proposals when available, falls back to real-time neighbor computation.
    """
    neighbor_data = _get_skipped_neighbor_distances(skipped)

    def _actionability_key(x):
        iid = x.get("identity_id", "")
        match = neighbor_data.get(iid)

        if match:
            dist, confidence, target_name = match
            if confidence == "VERY HIGH":
                tier = 0
            elif confidence == "HIGH":
                tier = 1
            elif confidence == "MODERATE":
                tier = 2
            else:
                tier = 3

            # Named match bonus: 0 if target is named, 1 if unidentified
            is_unidentified = 1 if (not target_name or target_name.startswith("Unidentified")) else 0

            # Quality penalty (negative so higher quality sorts first)
            quality = _identity_quality_score(x)

            return (tier, is_unidentified, dist, -quality)
        else:
            quality = _identity_quality_score(x)
            return (4, 1, 999, -quality)

    return sorted(skipped, key=_actionability_key)


def _actionability_badge(identity_id: str, ids_with_proposals: set = None):
    """Return a visual badge for an identity's actionability level.

    Uses cached neighbor data from _get_skipped_neighbor_distances() when available,
    falls back to proposals. Returns None if the identity has no leads.
    """
    # Try cached neighbor distances first
    if _skipped_neighbor_cache and identity_id in _skipped_neighbor_cache:
        cached = _skipped_neighbor_cache[identity_id]
        confidence = cached[1]  # (distance, confidence, target_name)
    else:
        # Fallback to proposals
        if ids_with_proposals and identity_id not in ids_with_proposals:
            return None
        best = _get_best_proposal_for_identity(identity_id)
        if not best:
            return None
        confidence = best.get("confidence", "")

    if confidence in ("VERY HIGH", "HIGH"):
        return Div(
            Span("Strong lead", cls="text-xs font-bold text-emerald-300"),
            Span(" — ML found a likely match", cls="text-xs text-slate-400"),
            cls="px-3 py-1 bg-emerald-900/30 border border-emerald-500/30 rounded-lg mb-1",
        )
    elif confidence == "MODERATE":
        return Div(
            Span("Good lead", cls="text-xs font-bold text-amber-300"),
            Span(" — possible match found", cls="text-xs text-slate-400"),
            cls="px-3 py-1 bg-amber-900/30 border border-amber-500/30 rounded-lg mb-1",
        )
    return None


def _skipped_focus_progress() -> Div:
    """Build progress counter for skipped focus mode.

    Uses client-side cookie to persist count across HTMX swaps.
    """
    return Div(
        Div(
            Span("Reviewed: ", cls="text-slate-400"),
            Span("0", id="skipped-reviewed-count", cls="text-white font-bold"),
            Span(" this session", cls="text-slate-400"),
            cls="text-sm"
        ),
        A(
            "← Exit Focus Mode",
            href="/?section=skipped&view=browse",
            cls="text-sm text-slate-400 hover:text-white transition-colors"
        ),
        Script("""
            (function() {
                var key = 'skipped_focus_count';
                function getCount() {
                    var stored = document.cookie.split(';').find(function(c) { return c.trim().startsWith(key + '='); });
                    return stored ? parseInt(stored.split('=')[1]) : 0;
                }
                function setCount(n) {
                    document.cookie = key + '=' + n + '; path=/; max-age=86400';
                    var el = document.getElementById('skipped-reviewed-count');
                    if (el) el.textContent = n;
                }
                // Initialize on load
                var el = document.getElementById('skipped-reviewed-count');
                if (el) el.textContent = getCount();
                // Increment when the focus container is swapped (action was taken)
                document.body.addEventListener('htmx:afterSwap', function(evt) {
                    if (evt.detail.target && evt.detail.target.id === 'skipped-focus-container') {
                        setCount(getCount() + 1);
                    }
                });
            })();
        """),
        cls="flex items-center justify-between mb-4",
        id="skipped-focus-progress",
    )


def skipped_card_expanded(identity: dict, crop_files: set, is_admin: bool = True) -> Div:
    """
    Expanded identity card for Needs Help Focus Mode.

    Shows the face prominently, the best ML suggestion side-by-side,
    photo context (full photo with collection info), and action buttons:
    - Same Person (Y): merge with top suggestion
    - Not Same (N): reject top suggestion
    - I Know Them (Enter): name input + confirm
    - Skip (S): advance without action
    """
    identity_id = identity["identity_id"]
    raw_name = ensure_utf8_display(identity.get("name"))
    name = raw_name or "Unidentified Person"
    state = identity["state"]

    # Get all faces
    all_face_ids = identity.get("anchor_ids", []) + identity.get("candidate_ids", [])
    face_count = len(all_face_ids)

    # Get best-quality face for main display
    main_crop_url = None
    main_photo_id = None
    main_face_id = get_best_face_id(all_face_ids)
    if main_face_id:
        main_crop_url = resolve_face_image_url(main_face_id, crop_files)
        main_photo_id = get_photo_id_for_face(main_face_id)

    # Get top ML suggestions for side-by-side display + strip (compute first so we know best match)
    suggestion_el, other_matches_strip, best_match_id = _build_skipped_suggestion_with_strip(identity_id, crop_files)

    # Get photo context (collection, other identified people) — includes best match photo
    photo_context_el = _build_skipped_photo_context(main_face_id, main_photo_id, identity_id, best_match_id=best_match_id)

    # Action buttons
    if is_admin:
        actions = _build_skipped_focus_actions(identity_id, state)
    else:
        actions = Div(
            Button(
                "I Know This Person",
                cls="px-4 py-2 bg-indigo-600 text-white font-medium rounded-lg hover:bg-indigo-500 transition-colors min-h-[44px]",
                **{"_": f"on click toggle .hidden on #skipped-name-form-{identity_id}"},
                type="button",
            ),
            cls="flex items-center gap-3 mt-6"
        )

    # Inline name form (hidden by default)
    name_form = Div(
        Form(
            Input(
                type="text",
                name="name",
                placeholder="Type their name...",
                cls="flex-1 bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 text-white placeholder-slate-400 focus:ring-2 focus:ring-indigo-500 focus:border-transparent min-h-[44px]",
                autofocus=True,
            ),
            Button(
                "Confirm Identity",
                cls="px-4 py-2 bg-green-500 text-white font-medium rounded-lg hover:bg-green-600 transition-colors min-h-[44px]",
                type="submit",
            ),
            Button(
                "Cancel",
                cls="px-4 py-2 bg-slate-700 text-slate-300 rounded-lg hover:bg-slate-600 transition-colors min-h-[44px]",
                type="button",
                **{"_": f"on click add .hidden to #skipped-name-form-{identity_id}"},
            ),
            hx_post=f"/api/skipped/{identity_id}/name-and-confirm",
            hx_target="#skipped-focus-container",
            hx_swap="outerHTML",
            cls="flex gap-3 items-center",
        ),
        cls="mt-4 hidden",
        id=f"skipped-name-form-{identity_id}",
    )

    # Additional faces preview
    face_previews = []
    for face_entry in all_face_ids[1:4]:
        fid = face_entry if isinstance(face_entry, str) else face_entry.get("face_id", "")
        crop_url = resolve_face_image_url(fid, crop_files)
        if crop_url:
            face_photo_id = get_photo_id_for_face(fid)
            if face_photo_id:
                face_previews.append(
                    Button(
                        Img(src=crop_url, cls="w-20 h-20 rounded-lg object-cover border border-slate-600 hover:border-indigo-400 transition-colors", alt=f"Face"),
                        cls="p-0 bg-transparent cursor-pointer hover:ring-2 hover:ring-indigo-400 rounded-lg transition-all",
                        hx_get=f"/photo/{face_photo_id}/partial?face={fid}&identity_id={identity_id}",
                        hx_target="#photo-modal-content",
                        **{"_": "on click remove .hidden from #photo-modal"},
                        type="button",
                        title="Click to view photo",
                    )
                )

    return Div(
        # Top row: This Person + Best Match side by side (large faces ~300px)
        Div(
            # Left: This Person
            Div(
                Div("Who is this?", cls="text-xs font-medium text-slate-400 mb-2 uppercase tracking-wide"),
                Button(
                    Div(
                        Img(
                            src=main_crop_url or "",
                            alt=name,
                            cls="w-full h-full object-cover"
                        ) if main_crop_url else Span("?", cls="text-6xl text-slate-500"),
                        cls="w-48 h-48 sm:w-72 sm:h-72 rounded-lg overflow-hidden bg-slate-700 flex items-center justify-center"
                    ),
                    cls="p-0 bg-transparent cursor-pointer hover:ring-2 hover:ring-indigo-400 rounded-lg transition-all",
                    hx_get=f"/photo/{main_photo_id}/partial?face={main_face_id}&identity_id={identity_id}" if main_photo_id else None,
                    hx_target="#photo-modal-content",
                    **{"_": "on click remove .hidden from #photo-modal"} if main_photo_id else {},
                    type="button",
                    title="Click to view full photo",
                ) if main_photo_id else Div(
                    Img(src=main_crop_url, alt=name, cls="w-full h-full object-cover") if main_crop_url else Span("?", cls="text-6xl text-slate-500"),
                    cls="w-48 h-48 sm:w-72 sm:h-72 rounded-lg overflow-hidden bg-slate-700 flex items-center justify-center"
                ),
                Div(
                    P(name, cls="text-lg font-semibold text-white mt-2"),
                    P(f"{face_count} face{'s' if face_count != 1 else ''}", cls="text-xs text-slate-400"),
                ),
                Div(
                    A("View Photo", href="#", cls="text-xs text-indigo-400 hover:text-indigo-300 inline-block",
                      hx_get=f"/photo/{main_photo_id}/partial?face={main_face_id}&identity_id={identity_id}",
                      hx_target="#photo-modal-content",
                      **{"_": "on click remove .hidden from #photo-modal"},
                    ),
                    share_button(main_photo_id, style="link", label="Share Photo"),
                    share_button(url=f"/identify/{identity_id}/match/{best_match_id}", style="link", label="Share This Match",
                                 title="Are these the same person?", text=f"Help identify: {name}") if best_match_id else None,
                    cls="flex items-center gap-3 mt-1",
                ) if main_photo_id else None,
                # Additional faces
                Div(*face_previews, cls="flex gap-2 mt-3") if face_previews else None,
                cls="flex-1 flex flex-col items-center sm:items-start"
            ),
            # Right: Best Match suggestion
            suggestion_el,
            cls="flex flex-col sm:flex-row gap-8 items-start justify-center"
        ),
        # Other matches strip (horizontal scroll)
        other_matches_strip,
        # Photo context
        photo_context_el,
        # Neighbors container — always auto-loads ML suggestions
        Div(
            id=f"neighbors-{identity_id}", cls="mt-4",
            hx_get=f"/api/identity/{identity_id}/neighbors?from_focus=true&focus_section=skipped",
            hx_trigger="load",
            hx_swap="innerHTML",
        ),
        # Name form (inline, hidden by default)
        name_form,
        # Sticky action bar at bottom
        actions,
        cls="bg-slate-800 rounded-xl shadow-lg border border-slate-700 p-4 sm:p-6 pb-24 sm:pb-6",
        id="skipped-focus-card",
        **{"data-focus-mode": "skipped"},
    )


def _build_skipped_photo_context(face_id: str, photo_id: str, identity_id: str, best_match_id: str = None):
    """Build photo context panel showing collection info and co-identified faces.

    Shows both the "Who is this?" source photo and the Best Match source photo
    side by side when a best match exists.
    """
    if not photo_id:
        return None

    _build_caches()
    photo = _photo_cache.get(photo_id)
    if not photo:
        return None

    collection = photo.get("collection") or photo.get("source") or ""
    photo_url = storage.get_photo_url(photo.get("path") or photo.get("filename") or "")

    # Find other identified faces in this photo
    registry = load_registry()
    other_people = []
    for fid in photo.get("face_ids", []):
        if fid == face_id:
            continue
        # Look up which identity this face belongs to
        for state_name in ["CONFIRMED", "PROPOSED", "INBOX", "SKIPPED"]:
            try:
                state_enum = IdentityState[state_name]
                identities = registry.list_identities(state=state_enum)
                for ident in identities:
                    if ident["identity_id"] == identity_id:
                        continue
                    all_faces = ident.get("anchor_ids", []) + ident.get("candidate_ids", [])
                    face_strs = [f if isinstance(f, str) else f.get("face_id", "") for f in all_faces]
                    if fid in face_strs:
                        ident_name = ensure_utf8_display(ident.get("name") or "")
                        if ident_name and not ident_name.startswith("Unidentified"):
                            other_people.append(ident_name)
                        break
            except (KeyError, AttributeError):
                continue

    other_people = list(set(other_people))[:5]  # Deduplicate, limit

    # Build "Who is this?" photo card
    who_context_items = []
    if collection:
        who_context_items.append(Span(collection, cls="text-xs text-slate-400 truncate"))
    if other_people:
        who_context_items.append(Span(f"Also: {', '.join(other_people)}", cls="text-xs text-slate-300 truncate"))

    who_card = Div(
        Div("Who is this?", cls="text-[10px] font-medium text-slate-500 uppercase tracking-wide mb-1"),
        Button(
            Img(
                src=photo_url,
                cls="w-full h-20 object-cover rounded border border-slate-600 hover:border-indigo-400 transition-colors",
                alt="Source photo",
            ),
            cls="p-0 bg-transparent cursor-pointer w-full",
            hx_get=f"/photo/{photo_id}/partial?face={face_id}&identity_id={identity_id}",
            hx_target="#photo-modal-content",
            **{"_": "on click remove .hidden from #photo-modal"},
            type="button",
            title="View full photo",
        ),
        Div(*who_context_items, cls="flex flex-col gap-0.5 mt-1") if who_context_items else None,
        A("View Photo Page", href=f"/photo/{photo_id}", cls="text-[10px] text-indigo-400 hover:text-indigo-300 mt-1 inline-block"),
        cls="flex-1 min-w-0",
    )

    # Build Best Match photo card (if we have a best match)
    match_card = None
    if best_match_id:
        try:
            match_identity = registry.get_identity(best_match_id)
            match_faces = match_identity.get("anchor_ids", []) + match_identity.get("candidate_ids", [])
            match_face_id = get_best_face_id(match_faces)
            if match_face_id:
                match_photo_id = get_photo_id_for_face(match_face_id)
                if match_photo_id:
                    match_photo = _photo_cache.get(match_photo_id)
                    if match_photo:
                        match_collection = match_photo.get("collection") or match_photo.get("source") or ""
                        match_photo_url = storage.get_photo_url(match_photo.get("path") or match_photo.get("filename") or "")
                        match_name = ensure_utf8_display(match_identity.get("name") or "Unknown")

                        match_context_items = []
                        if match_collection:
                            match_context_items.append(Span(match_collection, cls="text-xs text-slate-400 truncate"))
                        match_context_items.append(Span(match_name, cls="text-xs text-slate-300 truncate"))

                        match_card = Div(
                            Div("Best Match", cls="text-[10px] font-medium text-slate-500 uppercase tracking-wide mb-1"),
                            Button(
                                Img(
                                    src=match_photo_url,
                                    cls="w-full h-20 object-cover rounded border border-slate-600 hover:border-indigo-400 transition-colors",
                                    alt=f"Source photo for {match_name}",
                                ),
                                cls="p-0 bg-transparent cursor-pointer w-full",
                                hx_get=f"/photo/{match_photo_id}/partial?face={match_face_id}&identity_id={best_match_id}",
                                hx_target="#photo-modal-content",
                                **{"_": "on click remove .hidden from #photo-modal"},
                                type="button",
                                title=f"View photo of {match_name}",
                            ),
                            Div(*match_context_items, cls="flex flex-col gap-0.5 mt-1") if match_context_items else None,
                            A("View Photo Page", href=f"/photo/{match_photo_id}", cls="text-[10px] text-indigo-400 hover:text-indigo-300 mt-1 inline-block"),
                            cls="flex-1 min-w-0",
                        )
        except (KeyError, Exception):
            pass

    # Share button shares the source photo page, not the match comparison
    share_el = share_button(url=f"/photo/{photo_id}", style="link", label="Share",
                            title="Check out this photo", text="From the Rhodesli archive")

    return Div(
        Div(
            Span("Photo Context", cls="text-xs font-medium text-slate-400 uppercase tracking-wide"),
            share_el,
            cls="flex items-center justify-between mb-2",
        ),
        Div(
            who_card,
            match_card,
            cls="flex gap-3"
        ) if match_card else Div(
            who_card,
            cls="flex gap-3"
        ),
        cls="mt-4 bg-slate-700/30 rounded-lg p-3 border border-slate-700/50"
    )


def _compute_best_neighbor(identity_id: str):
    """Compute best neighbor for an identity using real-time embedding distance.

    Returns a dict with keys matching proposal format:
      target_identity_id, target_identity_name, distance, confidence
    or None if no neighbor found.
    """
    try:
        from core.neighbors import find_nearest_neighbors
        registry = load_registry()
        photo_registry = load_photo_registry()
        face_data = get_face_data()
        neighbors = find_nearest_neighbors(
            identity_id, registry, photo_registry, face_data, limit=1
        )
        if not neighbors:
            return None
        n = neighbors[0]
        dist = n.get("distance", 999)
        # Map distance to confidence tier (same thresholds as clustering)
        if dist < 0.80:
            confidence = "VERY HIGH"
        elif dist < 1.00:
            confidence = "HIGH"
        elif dist < 1.20:
            confidence = "MODERATE"
        else:
            confidence = "LOW"
        return {
            "target_identity_id": n["identity_id"],
            "target_identity_name": n.get("name", "Unknown"),
            "distance": dist,
            "confidence": confidence,
        }
    except (ImportError, Exception):
        return None


def _compute_top_neighbors(identity_id: str, limit: int = 5):
    """Compute top N neighbors for an identity using real-time embedding distance.

    Returns a list of dicts with keys: target_identity_id, target_identity_name, distance, confidence.
    """
    try:
        from core.neighbors import find_nearest_neighbors
        registry = load_registry()
        photo_registry = load_photo_registry()
        face_data = get_face_data()
        neighbors = find_nearest_neighbors(
            identity_id, registry, photo_registry, face_data, limit=limit
        )
        results = []
        for n in neighbors:
            dist = n.get("distance", 999)
            if dist < 0.80:
                confidence = "VERY HIGH"
            elif dist < 1.00:
                confidence = "HIGH"
            elif dist < 1.20:
                confidence = "MODERATE"
            else:
                confidence = "LOW"
            results.append({
                "target_identity_id": n["identity_id"],
                "target_identity_name": n.get("name", "Unknown"),
                "distance": dist,
                "confidence": confidence,
            })
        return results
    except (ImportError, Exception):
        return []


def _get_best_match_for_identity(identity_id: str):
    """Get best match: first from proposals, then from real-time neighbors."""
    best = _get_best_proposal_for_identity(identity_id)
    if best:
        return best
    return _compute_best_neighbor(identity_id)


def _build_skipped_suggestion(identity_id: str, crop_files: set):
    """Build the 'Best Match' side-by-side panel for a skipped identity.

    Returns a single element (for backward compat with any callers).
    """
    el, _ = _build_skipped_suggestion_with_strip(identity_id, crop_files)
    return el


def _resolve_match_crop(target_id: str, crop_files: set):
    """Resolve the first available face crop URL for an identity."""
    try:
        registry = load_registry()
        target_identity = registry.get_identity(target_id)
        target_faces = target_identity.get("anchor_ids", []) + target_identity.get("candidate_ids", [])
        for f in target_faces:
            fid = f if isinstance(f, str) else f.get("face_id", "")
            url = resolve_face_image_url(fid, crop_files)
            if url:
                return url
    except (KeyError, Exception):
        pass
    return None


def _confidence_tier(distance: float) -> str:
    """Map embedding distance to confidence tier."""
    if distance < 0.80:
        return "VERY HIGH"
    elif distance < 1.00:
        return "HIGH"
    elif distance < 1.20:
        return "MODERATE"
    return "LOW"


_CONFIDENCE_RING = {"VERY HIGH": "ring-emerald-400", "HIGH": "ring-blue-400", "MODERATE": "ring-amber-400"}
_CONFIDENCE_COLOR = {"VERY HIGH": "text-emerald-300", "HIGH": "text-blue-300", "MODERATE": "text-amber-300"}
_CONFIDENCE_LABEL = {"VERY HIGH": "Strong match", "HIGH": "Good match", "MODERATE": "Possible match", "LOW": "Weak match"}


def _build_skipped_suggestion_with_strip(identity_id: str, crop_files: set):
    """Build 'Best Match' panel + horizontal strip of other matches.

    Returns (suggestion_el, other_matches_strip_el, best_match_id).
    """
    # Fetch up to 5 neighbors
    top_matches = _compute_top_neighbors(identity_id, limit=5)

    # Also check proposals
    best_proposal = _get_best_proposal_for_identity(identity_id)
    if best_proposal:
        # Merge proposal into top of list if not already present
        proposal_id = best_proposal.get("target_identity_id", "")
        if not any(m.get("target_identity_id") == proposal_id for m in top_matches):
            top_matches.insert(0, best_proposal)

    if not top_matches:
        no_match_el = Div(
            Div("Best Match", cls="text-xs font-medium text-slate-400 mb-2 uppercase tracking-wide"),
            P("No ML suggestions yet", cls="text-sm text-slate-500 italic"),
            P("Try 'I Know Them' to name this person", cls="text-xs text-slate-500 mt-1"),
            cls="flex-1 flex flex-col items-center sm:items-start"
        )
        return no_match_el, None, None

    # Best match (primary comparison)
    best = top_matches[0]
    target_id = best.get("target_identity_id", "")
    target_name = ensure_utf8_display(best.get("target_identity_name", "Unknown"))
    confidence = best.get("confidence", "")
    ring_cls = _CONFIDENCE_RING.get(confidence, "ring-slate-500")
    color_cls = _CONFIDENCE_COLOR.get(confidence, "text-slate-300")
    confidence_label = _CONFIDENCE_LABEL.get(confidence, "Match")
    suggestion_crop_url = _resolve_match_crop(target_id, crop_files)

    # Resolve best match's photo ID for View Photo / share links
    match_photo_id = None
    match_face_id = None
    target_identity = None
    try:
        registry = load_registry()
        target_identity = registry.get_identity(target_id)
        target_faces = target_identity.get("anchor_ids", []) + target_identity.get("candidate_ids", [])
        match_face_id = get_best_face_id(target_faces)
        if match_face_id:
            match_photo_id = get_photo_id_for_face(match_face_id)
    except (KeyError, Exception):
        pass

    # Build links for best match (mirror "Who is this?" links)
    match_links = []
    if match_photo_id:
        match_links.append(
            A("View Photo", href="#", cls="text-xs text-indigo-400 hover:text-indigo-300 inline-block",
              hx_get=f"/photo/{match_photo_id}/partial?face={match_face_id}&identity_id={target_id}",
              hx_target="#photo-modal-content",
              **{"_": "on click remove .hidden from #photo-modal"},
            )
        )
    # Profile link
    target_state = target_identity.get("state", "") if target_identity else ""
    if target_state == "CONFIRMED":
        match_links.append(A("View Profile", href=f"/person/{target_id}", cls="text-xs text-indigo-400 hover:text-indigo-300 inline-block"))
    else:
        match_links.append(A("Help Identify", href=f"/identify/{target_id}", cls="text-xs text-indigo-400 hover:text-indigo-300 inline-block"))

    suggestion_el = Div(
        Div("Best Match", cls="text-xs font-medium text-slate-400 mb-2 uppercase tracking-wide"),
        Div(
            Img(
                src=suggestion_crop_url or "",
                alt=target_name,
                cls="w-full h-full object-cover"
            ) if suggestion_crop_url else Span("?", cls="text-4xl text-slate-500"),
            cls=f"w-48 h-48 sm:w-72 sm:h-72 rounded-lg overflow-hidden bg-slate-700 flex items-center justify-center ring-3 {ring_cls}"
        ),
        Div(
            P(target_name, cls="text-lg font-semibold text-white mt-2"),
            P(
                Span(confidence_label, cls=f"font-bold {color_cls}"),
                cls="text-sm mt-1"
            ),
        ),
        Div(*match_links, cls="flex items-center gap-3 mt-1") if match_links else None,
        cls="flex-1 flex flex-col items-center sm:items-start"
    )

    # Other matches strip (2nd through 5th)
    other_matches_strip = None
    other_matches = top_matches[1:]
    if other_matches:
        strip_items = []
        for match in other_matches:
            m_id = match.get("target_identity_id", "")
            m_name = ensure_utf8_display(match.get("target_identity_name", "Unknown"))
            m_conf = match.get("confidence", "LOW")
            m_ring = _CONFIDENCE_RING.get(m_conf, "ring-slate-500")
            m_crop = _resolve_match_crop(m_id, crop_files)
            m_label = _CONFIDENCE_LABEL.get(m_conf, "Match")
            strip_items.append(
                Div(
                    Div(
                        Img(src=m_crop or "", alt=m_name, cls="w-full h-full object-cover") if m_crop else Span("?", cls="text-lg text-slate-500"),
                        cls=f"w-20 h-20 sm:w-24 sm:h-24 rounded-lg overflow-hidden bg-slate-700 flex items-center justify-center ring-2 {m_ring} hover:scale-105 transition-transform"
                    ),
                    P(m_name[:20] + ("..." if len(m_name) > 20 else ""), cls="text-xs text-slate-300 mt-1 text-center truncate max-w-[80px]"),
                    P(m_label, cls=f"text-[10px] {_CONFIDENCE_COLOR.get(m_conf, 'text-slate-400')} text-center"),
                    cls="flex flex-col items-center flex-shrink-0 cursor-pointer hover:bg-slate-700/50 rounded-lg p-1 transition-colors",
                    title=f"{m_name} — {m_label}",
                )
            )
        other_matches_strip = Div(
            Div("More matches", cls="text-xs font-medium text-slate-500 mb-2 uppercase tracking-wide"),
            Div(*strip_items, cls="flex gap-3 overflow-x-auto pb-2"),
            cls="mt-5 pt-4 border-t border-slate-700/50"
        )

    return suggestion_el, other_matches_strip, target_id


def _build_skipped_focus_actions(identity_id: str, state: str) -> Div:
    """Build action buttons for skipped focus mode."""
    best = _get_best_match_for_identity(identity_id)
    has_suggestion = best is not None

    buttons = []

    if has_suggestion:
        target_id = best.get("target_identity_id", "")
        target_name = ensure_utf8_display(best.get("target_identity_name", ""))
        buttons.append(
            Button(
                "✓ Same Person",
                cls="px-4 py-2 bg-green-500 text-white font-medium rounded-lg hover:bg-green-600 transition-colors min-h-[44px]",
                hx_post=f"/api/identity/{target_id}/merge/{identity_id}?from_focus=true&focus_section=skipped",
                hx_target="#skipped-focus-container",
                hx_swap="outerHTML",
                type="button",
                id="focus-btn-confirm",
                title=f"Merge with {target_name}" if target_name else "Merge with suggestion",
                **{"data-undo-url": f"/api/identity/{target_id}/undo-merge", "data-undo-type": "merge",
                   "data-undo-identity": identity_id},
            )
        )
        buttons.append(
            Button(
                "✗ Not Same",
                cls="px-4 py-2 bg-red-500 text-white font-medium rounded-lg hover:bg-red-600 transition-colors min-h-[44px]",
                hx_post=f"/api/skipped/{identity_id}/reject-suggestion?suggestion_id={target_id}",
                hx_target="#skipped-focus-container",
                hx_swap="outerHTML",
                type="button",
                id="focus-btn-reject",
                title="Not the same person — reject this suggestion",
                **{"data-undo-url": f"/api/identity/{identity_id}/unreject/{target_id}", "data-undo-type": "reject",
                   "data-undo-identity": identity_id},
            )
        )

    buttons.append(
        Button(
            "I Know Them",
            cls="px-4 py-2 bg-indigo-600 text-white font-medium rounded-lg hover:bg-indigo-500 transition-colors min-h-[44px]",
            type="button",
            id="focus-btn-name",
            **{"_": f"on click remove .hidden from #skipped-name-form-{identity_id} then set focus to the first <input/> in #skipped-name-form-{identity_id}"},
            title="I recognize this person — enter their name",
        )
    )
    buttons.append(
        Button(
            "→ Skip",
            cls="px-4 py-2 bg-slate-700 text-slate-300 font-medium rounded-lg hover:bg-slate-600 transition-colors min-h-[44px]",
            hx_post=f"/api/skipped/{identity_id}/focus-skip",
            hx_target="#skipped-focus-container",
            hx_swap="outerHTML",
            type="button",
            id="focus-btn-skip",
            title="Skip — come back later",
            **{"data-undo-type": "skip", "data-undo-identity": identity_id},
        )
    )

    shortcut_text = "Y Same · N Different · Enter Name · S Skip · Z Undo" if has_suggestion else "Enter Name · S Skip"

    return Div(
        Div(*buttons, cls="flex flex-wrap items-center gap-3"),
        Div(shortcut_text, cls="text-xs text-slate-500 mt-2 hidden sm:block"),
        # Undo toast (hidden by default, shown after undo-able action)
        Div(
            id="undo-toast",
            cls="hidden fixed bottom-20 left-1/2 -translate-x-1/2 bg-slate-700 text-white px-4 py-2 rounded-lg shadow-lg z-50 text-sm flex items-center gap-3",
        ),
        cls="sticky bottom-0 bg-slate-800/95 backdrop-blur-sm border-t border-slate-700 p-4 -mx-4 sm:-mx-6 -mb-24 sm:-mb-6 mt-6 rounded-b-xl z-10",
    )


def get_next_skipped_focus_card(exclude_id: str = None) -> Div:
    """
    Get the next skipped identity card for focus mode review.

    Returns an expanded identity card + Up Next carousel for skipped identities,
    sorted by actionability. Returns empty state if no items remain.
    """
    registry = load_registry()
    crop_files = get_crop_files()

    skipped = registry.list_identities(state=IdentityState.SKIPPED)

    # Filter out the just-actioned item
    if exclude_id:
        skipped = [i for i in skipped if i["identity_id"] != exclude_id]

    # Sort by actionability
    sorted_skipped = _sort_skipped_by_actionability(skipped)

    if sorted_skipped:
        # Build Up Next carousel
        up_next = None
        if len(sorted_skipped) > 1:
            up_next = Div(
                H3("Up Next", cls="text-sm font-medium text-slate-400 mb-3"),
                Div(
                    *[identity_card_mini(i, crop_files, clickable=True) for i in sorted_skipped[1:6]],
                    Div(
                        f"+{len(sorted_skipped) - 6} more",
                        cls="w-24 flex-shrink-0 flex items-center justify-center bg-slate-700 rounded-lg text-sm text-slate-400 aspect-square"
                    ) if len(sorted_skipped) > 6 else None,
                    cls="flex gap-3 overflow-x-auto pb-2"
                ),
                cls="mt-6"
            )

        progress = _skipped_focus_progress()

        return Div(
            progress,
            skipped_card_expanded(sorted_skipped[0], crop_files, is_admin=True),
            up_next,
            id="skipped-focus-container",
            data_focus_mode="skipped",
        )
    else:
        return Div(
            Div("🎉", cls="text-4xl mb-4"),
            H3("All caught up!", cls="text-lg font-medium text-white"),
            P("You've reviewed all the faces that need help.", cls="text-slate-400 mt-1"),
            A(
                "← Back to Inbox",
                href="/?section=to_review",
                cls="inline-block mt-4 text-indigo-400 hover:text-indigo-300 font-medium"
            ),
            cls="bg-slate-800 rounded-xl shadow-lg border border-slate-700 p-12 text-center",
            id="skipped-focus-container",
        )


def render_rejected_section(dismissed: list, crop_files: set, counts: dict, is_admin: bool = True) -> Div:
    """Render the Rejected/Dismissed section."""
    cards = [
        identity_card(identity, crop_files, lane_color="rose", show_actions=False, is_admin=is_admin)
        for identity in dismissed
    ]
    cards = [c for c in cards if c]

    if cards:
        content = Div(*cards)
    else:
        content = Div(
            "No dismissed items. Rejected matches will appear here.",
            cls="text-center py-12 text-slate-400"
        )

    return Div(
        section_header("Dismissed", f"{counts['rejected']} items dismissed"),
        content,
        cls="space-y-6"
    )


def _photo_nav_url(photo_id: str, index: int, photos: list, total: int) -> str:
    """Build /photo/{id}/partial URL with prev/next navigation context."""
    from urllib.parse import urlencode
    params = {"nav_idx": str(index), "nav_total": str(total)}
    if index > 0:
        params["prev_id"] = photos[index - 1]["photo_id"]
    if index < total - 1:
        params["next_id"] = photos[index + 1]["photo_id"]
    return f"/photo/{photo_id}/partial?{urlencode(params)}"


def render_photos_section(counts: dict, registry, crop_files: set,
                          filter_source: str = "", sort_by: str = "newest",
                          filter_collection: str = "") -> Div:
    """
    Render the Photos section - a grid view of all photos.

    This is the photo-centric workflow, complementing the face-centric inbox.

    Args:
        counts: Sidebar counts dict
        registry: Identity registry
        crop_files: Set of available crop filenames
        filter_source: Filter by source/provenance (empty = all)
        sort_by: Sort order (newest, oldest, most_faces, collection)
        filter_collection: Filter by collection/classification (empty = all)
    """
    _build_caches()
    if not _photo_cache:
        return Div(
            section_header("Photos", "0 photos"),
            Div(
                "No photos uploaded yet.",
                cls="text-center py-12 text-slate-400"
            ),
            cls="space-y-6"
        )

    # Get all photos with metadata
    photos = []
    sources_set = set()
    collections_set = set()
    for photo_id, photo_data in _photo_cache.items():
        source = photo_data.get("source", "")
        collection = photo_data.get("collection", "")
        if source:
            sources_set.add(source)
        if collection:
            collections_set.add(collection)

        # Get identified faces in this photo
        identified_faces = []
        confirmed_count = 0
        for face in photo_data.get("faces", []):
            face_id = face["face_id"]
            identity = get_identity_for_face(registry, face_id)
            if identity and identity.get("name"):
                identified_faces.append({
                    "name": identity.get("name"),
                    "face_id": face_id,
                    "identity_id": identity.get("identity_id"),
                })
                if identity.get("state") == "CONFIRMED":
                    confirmed_count += 1

        face_count = len(photo_data.get("faces", []))
        photos.append({
            "photo_id": photo_id,
            "filename": photo_data.get("filename", "unknown"),
            "source": source,
            "collection": collection,
            "face_count": face_count,
            "identified_count": len(identified_faces),
            "confirmed_count": confirmed_count,
            "identified_faces": identified_faces[:4],  # Max 4 for display
        })

    sources = sorted(sources_set)
    collections = sorted(collections_set)

    # Apply filters
    if filter_source:
        photos = [p for p in photos if p["source"] == filter_source]
    if filter_collection:
        photos = [p for p in photos if p["collection"] == filter_collection]

    # Apply sorting
    if sort_by == "oldest":
        photos = sorted(photos, key=lambda p: p["filename"])
    elif sort_by == "newest":
        photos = sorted(photos, key=lambda p: p["filename"], reverse=True)
    elif sort_by == "most_faces":
        photos = sorted(photos, key=lambda p: p["face_count"], reverse=True)
    elif sort_by == "collection":
        photos = sorted(photos, key=lambda p: (p["collection"] or p["source"] or "zzz", p["filename"]))

    # Build per-collection stats
    collection_stats = {}
    for p in photos:
        coll = p["collection"] or p["source"] or "Uncategorized"
        if coll not in collection_stats:
            collection_stats[coll] = {"photo_count": 0, "face_count": 0, "identified_count": 0}
        collection_stats[coll]["photo_count"] += 1
        collection_stats[coll]["face_count"] += p["face_count"]
        collection_stats[coll]["identified_count"] += p["identified_count"]

    # Build subtitle — scoped to current view
    active_filters = []
    if filter_collection:
        active_filters.append(filter_collection)
    if filter_source:
        active_filters.append(f"from {filter_source}")
    if active_filters:
        subtitle = f"{' '.join(active_filters)} \u2014 {len(photos)} photo{'s' if len(photos) != 1 else ''}"
    else:
        subtitle_parts = [f"{len(photos)} photo{'s' if len(photos) != 1 else ''}"]
        if len(collections) > 1:
            subtitle_parts.append(f"{len(collections)} collections")
        subtitle = " \u2022 ".join(subtitle_parts)

    # Build filter/sort options
    from urllib.parse import quote
    _fc = quote(filter_collection)
    _fs = quote(filter_source)

    collection_options = [Option("All Collections", value="", selected=not filter_collection)]
    for c in collections:
        collection_options.append(Option(c, value=c, selected=(filter_collection == c)))

    source_options = [Option("All Sources", value="", selected=not filter_source)]
    for s in sources:
        source_options.append(Option(s, value=s, selected=(filter_source == s)))

    sort_options = [
        Option("Newest First", value="newest", selected=(sort_by == "newest")),
        Option("Oldest First", value="oldest", selected=(sort_by == "oldest")),
        Option("Most Faces", value="most_faces", selected=(sort_by == "most_faces")),
        Option("By Collection", value="collection", selected=(sort_by == "collection")),
    ]

    # Filter/sort controls
    filter_bar = Div(
        # Collection filter
        Div(
            Label("Collection:", cls="text-sm text-slate-400 mr-2 flex-shrink-0"),
            Select(
                *collection_options,
                cls="bg-slate-700 border border-slate-600 text-slate-200 text-sm rounded-lg px-3 py-1.5 "
                    "focus:ring-2 focus:ring-indigo-500 min-w-0 max-w-[10rem] sm:max-w-none truncate",
                onchange=f"window.location.href='/?section=photos&filter_collection=' + encodeURIComponent(this.value) + '&filter_source={_fs}&sort_by={sort_by}'"
            ),
            cls="flex items-center min-w-0"
        ),
        # Source filter
        Div(
            Label("Source:", cls="text-sm text-slate-400 mr-2 flex-shrink-0"),
            Select(
                *source_options,
                cls="bg-slate-700 border border-slate-600 text-slate-200 text-sm rounded-lg px-3 py-1.5 "
                    "focus:ring-2 focus:ring-indigo-500 min-w-0 max-w-[10rem] sm:max-w-none truncate",
                onchange=f"window.location.href='/?section=photos&filter_collection={_fc}&filter_source=' + encodeURIComponent(this.value) + '&sort_by={sort_by}'"
            ),
            cls="flex items-center min-w-0"
        ),
        # Sort
        Div(
            Label("Sort:", cls="text-sm text-slate-400 mr-2 flex-shrink-0"),
            Select(
                *sort_options,
                cls="bg-slate-700 border border-slate-600 text-slate-200 text-sm rounded-lg px-3 py-1.5 "
                    "focus:ring-2 focus:ring-indigo-500 min-w-0",
                onchange=f"window.location.href='/?section=photos&filter_collection={_fc}&filter_source={_fs}&sort_by=' + this.value"
            ),
            cls="flex items-center min-w-0"
        ),
        # Select toggle button
        Button(
            "Select",
            id="photo-select-toggle",
            cls="px-3 py-1.5 text-sm border border-slate-600 text-slate-300 rounded-lg hover:bg-slate-700 transition-colors",
            type="button",
            data_action="toggle-photo-select",
        ),
        # Result count
        Span(f"{len(photos)} photo{'s' if len(photos) != 1 else ''}", cls="text-sm text-slate-500 ml-auto"),
        cls="filter-bar flex flex-wrap items-center gap-4 bg-slate-800 rounded-lg p-3 border border-slate-700 mb-4"
    )

    # Photo grid — build with navigation context
    total_photos = len(photos)
    photo_cards = []
    for pi, photo in enumerate(photos):
        # Face avatars for identified people
        face_avatars = []
        for i, face in enumerate(photo["identified_faces"][:3]):
            crop_file = f"{face['face_id']}.jpg"
            if crop_file in crop_files:
                face_avatars.append(
                    Div(
                        Img(
                            src=storage.get_crop_url_by_filename(crop_file),
                            cls="w-full h-full object-cover",
                            title=face["name"]
                        ),
                        cls="w-6 h-6 rounded-full border-2 border-slate-800 overflow-hidden",
                        style=f"margin-left: {-4 if i > 0 else 0}px; z-index: {10-i};"
                    )
                )

        if photo["identified_count"] > 3:
            face_avatars.append(
                Div(
                    f"+{photo['identified_count'] - 3}",
                    cls="w-6 h-6 rounded-full border-2 border-slate-800 bg-slate-700 "
                        "flex items-center justify-center text-xs text-slate-300",
                    style="margin-left: -4px;"
                )
            )

        card = Div(
            # Photo thumbnail
            Div(
                Img(
                    src=photo_url(photo["filename"]),
                    cls="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300",
                    loading="lazy"
                ),
                # Select mode checkbox (hidden by default)
                Div(
                    Input(
                        type="checkbox",
                        name="photo_ids",
                        value=photo["photo_id"],
                        cls="w-5 h-5 rounded border-slate-500 bg-slate-700/80 text-indigo-500 focus:ring-indigo-500 cursor-pointer",
                        data_action="photo-select-check",
                    ),
                    cls="photo-select-checkbox absolute top-2 left-2 z-10 hidden",
                ),
                # Face count badge with completion indicator
                Div(
                    Span("\u2713 ", cls="text-emerald-400") if photo["face_count"] > 0 and photo["confirmed_count"] == photo["face_count"] else None,
                    f"{photo['confirmed_count']}/{photo['face_count']}" if photo["confirmed_count"] > 0 else f"{photo['face_count']} face{'s' if photo['face_count'] != 1 else ''}",
                    cls="absolute top-2 right-2 text-white text-xs font-data "
                        "px-2 py-1 rounded-full backdrop-blur-sm "
                        + ("bg-emerald-600/80" if photo["face_count"] > 0 and photo["confirmed_count"] == photo["face_count"]
                           else "bg-black/70" if photo["confirmed_count"] == 0
                           else "bg-indigo-600/70")
                ),
                # Identified faces indicator
                Div(
                    *face_avatars,
                    cls="absolute bottom-2 left-2 flex"
                ) if face_avatars else None,
                # Date badge
                _render_date_badge_overlay(photo["photo_id"]),
                cls="aspect-[4/3] overflow-hidden relative"
            ),
            # Photo info
            Div(
                P(photo["filename"], cls="text-sm text-white truncate font-data"),
                Div(
                    P(
                        f"\U0001F4C1 {photo['source']}",
                        cls="text-xs text-slate-500 truncate"
                    ) if photo["source"] else None,
                    Span(
                        share_button(photo['photo_id'], style="icon"),
                        A(
                            "Open",
                            href=f"/photo/{photo['photo_id']}",
                            cls="text-[10px] text-indigo-400 hover:text-indigo-300 underline ml-1",
                            target="_blank",
                        ),
                        cls="flex items-center gap-0.5 flex-shrink-0",
                        **{"_": "on click halt the event's bubbling"},
                    ),
                    cls="flex items-center justify-between mt-0.5"
                ),
                cls="p-3"
            ),
            cls="bg-slate-800 rounded-lg border border-slate-700 overflow-hidden "
                "hover:border-slate-500 transition-colors cursor-pointer group",
            hx_get=_photo_nav_url(photo['photo_id'], pi, photos, total_photos),
            hx_target="#photo-modal-content",
            hx_swap="innerHTML",
            # Show modal and set navigation index
            **{"_": f"on htmx:afterOnLoad remove .hidden from #photo-modal then js window._photoNavIdx={pi} end"}
        )
        photo_cards.append(card)

    # Build ordered photo ID list for client-side navigation
    import json as _json
    photo_id_list = [p["photo_id"] for p in photos]
    photo_nav_script = Script(f"""
        window._photoNavIds = {_json.dumps(photo_id_list)};
        window._photoNavIdx = -1;
        function photoNavTo(idx) {{
            var ids = window._photoNavIds;
            if (idx < 0 || idx >= ids.length) return;
            window._photoNavIdx = idx;
            var prevId = idx > 0 ? ids[idx-1] : '';
            var nextId = idx < ids.length-1 ? ids[idx+1] : '';
            var url = '/photo/' + ids[idx] + '/partial?nav_idx=' + idx + '&nav_total=' + ids.length;
            if (prevId) url += '&prev_id=' + prevId;
            if (nextId) url += '&next_id=' + nextId;
            htmx.ajax('GET', url, {{target:'#photo-modal-content', swap:'innerHTML'}});
        }}
        // NOTE: Keyboard navigation is handled by the global event delegation
        // handler (data-action dispatch on document). Do NOT add a per-script
        // keydown listener here — it would double-fire with the global one,
        // causing 2 navigations per key press. (BUG-006 fix)
        // Touch swipe for photo modal navigation
        (function() {{
            var mc = document.getElementById('photo-modal-content');
            if (!mc) return;
            var sx = 0, sy = 0;
            mc.addEventListener('touchstart', function(e) {{ sx = e.touches[0].clientX; sy = e.touches[0].clientY; }}, {{passive: true}});
            mc.addEventListener('touchend', function(e) {{
                var dx = e.changedTouches[0].clientX - sx;
                var dy = e.changedTouches[0].clientY - sy;
                if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 50) {{
                    if (dx > 0) photoNavTo(window._photoNavIdx - 1);
                    else photoNavTo(window._photoNavIdx + 1);
                }}
            }});
        }})();
    """)

    # Photo grid layout
    grid = Div(
        *photo_cards,
        photo_nav_script,
        cls="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4"
    )

    # Collection stats cards (shown when viewing all collections, not filtered)
    collection_cards = None
    if not filter_collection and not filter_source and len(collection_stats) > 1:
        stat_cards = []
        for coll_name in sorted(collection_stats.keys()):
            stats = collection_stats[coll_name]
            stat_cards.append(
                Div(
                    Div(
                        P(coll_name, cls="text-sm font-medium text-white truncate"),
                        cls="mb-2"
                    ),
                    Div(
                        Span(f"{stats['photo_count']} photo{'s' if stats['photo_count'] != 1 else ''}", cls="text-xs text-slate-400"),
                        Span(" \u2022 ", cls="text-xs text-slate-600"),
                        Span(f"{stats['face_count']} face{'s' if stats['face_count'] != 1 else ''}", cls="text-xs text-slate-400"),
                        Span(" \u2022 ", cls="text-xs text-slate-600"),
                        Span(f"{stats['identified_count']} identified", cls="text-xs text-emerald-400"),
                    ),
                    cls="bg-slate-800/50 border border-slate-700 rounded-lg p-3 cursor-pointer "
                        "hover:border-indigo-500/50 transition-colors",
                    onclick=f"window.location.href='/?section=photos&filter_collection={quote(coll_name)}&sort_by={sort_by}'"
                )
            )
        # Use horizontal scroll for 5+ collections, grid for fewer
        if len(stat_cards) >= 5:
            # Make cards fixed-width for horizontal scrolling
            for card in stat_cards:
                card.attrs["class"] = card.attrs.get("class", "") + " min-w-[180px] flex-shrink-0"
            collection_cards = Div(
                *stat_cards,
                cls="flex gap-3 mb-4 overflow-x-auto pb-2 scrollbar-thin"
            )
        else:
            collection_cards = Div(
                *stat_cards,
                cls="grid grid-cols-2 md:grid-cols-4 gap-3 mb-4"
            )

    # Bulk action bar (hidden until selections exist)
    collection_options_bulk = [Option("Set collection...", value="", disabled=True, selected=True)]
    for c in collections:
        collection_options_bulk.append(Option(c, value=c))

    source_options_bulk = [Option("Set source...", value="", disabled=True, selected=True)]
    for s in sources:
        source_options_bulk.append(Option(s, value=s))

    bulk_action_bar = Div(
        Div(
            Span("0 selected", id="photo-select-count", cls="text-sm font-medium text-white"),
            Button("Select All", type="button", data_action="photo-select-all",
                   cls="px-3 py-1 text-xs border border-slate-600 text-slate-300 rounded hover:bg-slate-700"),
            Button("Clear", type="button", data_action="photo-select-clear",
                   cls="px-3 py-1 text-xs border border-slate-600 text-slate-300 rounded hover:bg-slate-700"),
            Div(
                Select(
                    *collection_options_bulk,
                    id="bulk-move-collection",
                    cls="bg-slate-700 border border-slate-600 text-slate-200 text-sm rounded-lg px-2 py-1.5",
                ),
                Select(
                    *source_options_bulk,
                    id="bulk-move-source",
                    cls="bg-slate-700 border border-slate-600 text-slate-200 text-sm rounded-lg px-2 py-1.5",
                ),
                Input(
                    type="url",
                    id="bulk-source-url",
                    placeholder="Source URL...",
                    cls="bg-slate-700 border border-slate-600 text-slate-200 text-sm rounded-lg px-2 py-1.5 w-40",
                ),
                Button("Apply", type="button", data_action="photo-bulk-move",
                       cls="px-4 py-1.5 text-sm font-bold bg-indigo-600 text-white rounded hover:bg-indigo-500"),
                cls="flex items-center gap-2 flex-wrap",
            ),
            Button("Cancel", type="button", data_action="toggle-photo-select",
                   cls="px-3 py-1 text-xs text-slate-400 hover:text-white"),
            cls="flex items-center gap-4 max-w-5xl mx-auto px-4 flex-wrap"
        ),
        id="photo-bulk-bar",
        cls="hidden fixed bottom-0 left-0 right-0 bg-slate-800 border-t border-slate-700 py-3 z-40",
    )

    # Select mode script using event delegation (CLAUDE.md rule #12)
    select_script = Script("""
        (function() {
            var selectMode = false;

            document.addEventListener('click', function(e) {
                var action = e.target.closest('[data-action]');
                if (!action) return;
                var act = action.getAttribute('data-action');

                if (act === 'toggle-photo-select') {
                    selectMode = !selectMode;
                    var cbs = document.querySelectorAll('.photo-select-checkbox');
                    var bar = document.getElementById('photo-bulk-bar');
                    var toggle = document.getElementById('photo-select-toggle');
                    cbs.forEach(function(cb) { cb.classList.toggle('hidden', !selectMode); });
                    if (bar) bar.classList.toggle('hidden', !selectMode);
                    if (toggle) {
                        toggle.textContent = selectMode ? 'Cancel' : 'Select';
                        toggle.classList.toggle('bg-indigo-600', selectMode);
                        toggle.classList.toggle('text-white', selectMode);
                        toggle.classList.toggle('border-indigo-600', selectMode);
                    }
                    if (!selectMode) {
                        cbs.forEach(function(cb) { var inp = cb.querySelector('input'); if (inp) inp.checked = false; });
                        updateSelectCount();
                    }
                }
                else if (act === 'photo-select-check') {
                    updateSelectCount();
                }
                else if (act === 'photo-select-all') {
                    document.querySelectorAll('.photo-select-checkbox input').forEach(function(cb) { cb.checked = true; });
                    updateSelectCount();
                }
                else if (act === 'photo-select-clear') {
                    document.querySelectorAll('.photo-select-checkbox input').forEach(function(cb) { cb.checked = false; });
                    updateSelectCount();
                }
                else if (act === 'photo-bulk-move') {
                    var collSel = document.getElementById('bulk-move-collection');
                    var srcSel = document.getElementById('bulk-move-source');
                    var urlInp = document.getElementById('bulk-source-url');
                    var collection = collSel ? collSel.value : '';
                    var source = srcSel ? srcSel.value : '';
                    var sourceUrl = urlInp ? urlInp.value : '';
                    if (!collection && !source && !sourceUrl) { alert('Please set at least one field.'); return; }
                    var ids = [];
                    document.querySelectorAll('.photo-select-checkbox input:checked').forEach(function(cb) { ids.push(cb.value); });
                    if (ids.length === 0) { alert('No photos selected.'); return; }
                    htmx.ajax('POST', '/api/photos/bulk-update-source', {
                        values: { photo_ids: JSON.stringify(ids), collection: collection, source: source, source_url: sourceUrl },
                        target: '#toast-container',
                        swap: 'beforeend'
                    });
                }
            });

            // Also handle change events for checkboxes
            document.addEventListener('change', function(e) {
                if (e.target.closest('[data-action="photo-select-check"]')) {
                    updateSelectCount();
                }
            });

            function updateSelectCount() {
                var count = document.querySelectorAll('.photo-select-checkbox input:checked').length;
                var el = document.getElementById('photo-select-count');
                if (el) el.textContent = count + ' selected';
            }
        })();
    """)

    return Div(
        section_header("Photos", subtitle),
        filter_bar,
        collection_cards,
        grid if photo_cards else Div(
            "No photos found." + (" Clear filter to see all." if (filter_source or filter_collection) else ""),
            cls="text-center py-12 text-slate-400"
        ),
        bulk_action_bar,
        select_script,
        cls="space-y-6"
    )


def get_next_focus_card(exclude_id: str = None, triage_filter: str = ""):
    """
    Get the next identity card for focus mode review.

    Returns an expanded identity card + Up Next carousel for the top priority items,
    or an empty state if no items remain.

    Args:
        exclude_id: Identity ID to exclude (just-actioned item)
        triage_filter: Active triage filter to preserve through navigation

    IMPORTANT: This must use the same sorting as render_to_review_section to ensure
    the "Up Next" queue matches what appears after an action.
    """
    registry = load_registry()
    crop_files = get_crop_files()

    # Get all to_review items
    inbox = registry.list_identities(state=IdentityState.INBOX)
    proposed = registry.list_identities(state=IdentityState.PROPOSED)
    to_review = inbox + proposed

    # Filter out the just-actioned item
    if exclude_id:
        to_review = [i for i in to_review if i["identity_id"] != exclude_id]

    # Apply triage filter if set (must match render_to_review_section logic)
    if triage_filter in ("ready", "rediscovered", "unmatched"):
        to_review = [i for i in to_review if _triage_category(i) == triage_filter]

    # Sort by actionability priority (matches render_to_review_section's _focus_sort_key)
    ids_with_proposals = _get_identities_with_proposals()

    def _focus_sort_key(x):
        iid = x.get("identity_id", "")
        has_proposal = iid in ids_with_proposals
        best = _get_best_proposal_for_identity(iid) if has_proposal else None
        has_promotion = x.get("promoted_from") is not None
        promotion_reason = x.get("promotion_reason", "")

        if has_promotion and promotion_reason == "confirmed_match":
            tier = 0
        elif has_proposal and best and best.get("confidence") == "VERY HIGH":
            tier = 1
        elif has_promotion:
            tier = 2
        elif has_proposal and best and best.get("confidence") == "HIGH":
            tier = 3
        elif has_proposal:
            tier = 4
        else:
            tier = 5

        # Quality tiebreaker — clear faces first within same tier
        quality = _identity_quality_score(x)

        return (
            tier,
            best["distance"] if best else 999,
            -quality,
            -len(x.get("anchor_ids", []) + x.get("candidate_ids", [])),
        )

    high_confidence = sorted(to_review, key=_focus_sort_key)[:10]

    if high_confidence:
        user_is_admin = True  # get_next_focus_card is only called from admin action routes
        # Build Up Next carousel
        up_next = None
        if len(high_confidence) > 1:
            up_next = Div(
                H3("Up Next", cls="text-sm font-medium text-slate-400 mb-3"),
                Div(
                    *[identity_card_mini(i, crop_files, clickable=True, triage_filter=triage_filter) for i in high_confidence[1:6]],
                    Div(
                        f"+{len(high_confidence) - 6} more",
                        cls="w-24 flex-shrink-0 flex items-center justify-center bg-slate-700 rounded-lg text-sm text-slate-400 aspect-square"
                    ) if len(high_confidence) > 6 else None,
                    cls="flex gap-3 overflow-x-auto pb-2"
                ),
                cls="mt-6"
            )

        # Show promotion banner above the expanded card if applicable
        banner = _promotion_banner(high_confidence[0])
        return Div(
            banner,
            identity_card_expanded(high_confidence[0], crop_files, is_admin=user_is_admin, triage_filter=triage_filter),
            up_next,
            id="focus-container"
        )
    else:
        # Empty state
        return Div(
            Div("🎉", cls="text-4xl mb-4"),
            H3("All caught up!", cls="text-lg font-medium text-white"),
            P("No more items to review.", cls="text-slate-400 mt-1"),
            A(
                "Upload more photos →",
                href="/upload",
                cls="inline-block mt-4 text-indigo-400 hover:text-indigo-300 font-medium"
            ),
            cls="bg-slate-800 rounded-xl shadow-lg border border-slate-700 p-12 text-center",
            id="focus-container"
        )


def upload_area(existing_sources: list[str] = None, existing_collections: list[str] = None) -> Div:
    """
    Drag-and-drop file upload area with separate collection, source, and source URL fields.
    UX Intent: Easy bulk ingestion into inbox with provenance tracking.

    Args:
        existing_sources: List of existing source labels for autocomplete
        existing_collections: List of existing collection labels for autocomplete
    """
    if existing_sources is None:
        existing_sources = []
    if existing_collections is None:
        existing_collections = []

    return Div(
        # Metadata fields — optional, can be filled before or after upload
        Div(
            P("Categorize your photos (optional — you can do this later)",
              cls="text-sm text-slate-400 mb-3"),
            # Collection field
            Div(
                Label("Collection", cls="block text-xs font-medium text-slate-400 mb-1"),
                Input(
                    type="text",
                    name="collection",
                    id="upload-collection",
                    placeholder="e.g., Immigration Records, Wedding Photos",
                    list="collection-suggestions",
                    cls="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded-lg "
                        "text-white placeholder-slate-400 text-sm focus:ring-2 focus:ring-indigo-500 "
                        "focus:border-transparent"
                ),
                Datalist(
                    *[Option(value=c) for c in existing_collections],
                    id="collection-suggestions"
                ) if existing_collections else None,
                P("How you want to organize these in the archive",
                  cls="text-xs text-slate-500 mt-0.5"),
                cls="mb-3"
            ),
            # Source field
            Div(
                Label("Source", cls="block text-xs font-medium text-slate-400 mb-1"),
                Input(
                    type="text",
                    name="source",
                    id="upload-source",
                    placeholder="e.g., Newspapers.com, Betty's Album, Rhodes Facebook Group",
                    list="source-suggestions",
                    cls="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded-lg "
                        "text-white placeholder-slate-400 text-sm focus:ring-2 focus:ring-indigo-500 "
                        "focus:border-transparent"
                ),
                Datalist(
                    *[Option(value=s) for s in existing_sources],
                    id="source-suggestions"
                ) if existing_sources else None,
                P("Where did these photos come from?",
                  cls="text-xs text-slate-500 mt-0.5"),
                cls="mb-3"
            ),
            # Source URL field
            Div(
                Label("Source URL", cls="block text-xs font-medium text-slate-400 mb-1"),
                Input(
                    type="url",
                    name="source_url",
                    id="upload-source-url",
                    placeholder="https://...",
                    cls="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded-lg "
                        "text-white placeholder-slate-400 text-sm focus:ring-2 focus:ring-indigo-500 "
                        "focus:border-transparent"
                ),
                P("Link to the original (for citation)",
                  cls="text-xs text-slate-500 mt-0.5"),
                cls="mb-3"
            ),
            cls="mb-4 p-4 bg-slate-800/50 rounded-lg border border-slate-700"
        ),
        # File upload area
        Form(
            Div(
                Span("\u2191", cls="text-4xl text-slate-500"),
                P("Drop photos here or click to upload", cls="text-slate-300 mt-2 font-medium"),
                P("Multiple files allowed \u2022 JPG, PNG, or ZIP", cls="text-xs text-slate-500 mt-1"),
                cls="text-center py-8"
            ),
            Input(
                type="file",
                name="files",
                accept="image/*,.zip",
                multiple=True,
                cls="absolute inset-0 opacity-0 cursor-pointer",
                hx_post="/upload",
                hx_encoding="multipart/form-data",
                hx_target="#upload-status",
                hx_swap="innerHTML",
                hx_include="#upload-source,#upload-collection,#upload-source-url",
            ),
            cls="relative",
            enctype="multipart/form-data",
        ),
        Div(id="upload-status", cls="mt-2"),
        cls="border-2 border-dashed border-slate-600 rounded-lg p-4 hover:border-slate-500 hover:bg-slate-800/50 transition-colors mb-4",
    )


def inbox_badge(count: int) -> A:
    """
    New Matches badge showing count of items awaiting review.
    """
    if count == 0:
        return A(
            Span("\U0001F4E5", cls="mr-2"),
            "New Matches",
            Span("(0)", cls="text-slate-500 ml-1"),
            href="#inbox-lane",
            cls="text-slate-400 hover:text-slate-300 text-sm"
        )
    return A(
        Span("\U0001F4E5", cls="mr-2"),
        "New Matches",
        Span(
            f"({count})",
            cls="bg-blue-600 text-white text-xs px-1.5 py-0.5 rounded-full ml-1"
        ),
        href="#inbox-lane",
        cls="text-slate-300 hover:text-blue-400 text-sm font-medium"
    )


def review_action_buttons(identity_id: str, state: str, is_admin: bool = True) -> Div:
    """
    Unified action buttons based on identity state.
    Only rendered for admin users.
    """
    if not is_admin:
        return Div()  # No buttons for non-admins

    buttons = []

    # Confirm button - available for reviewable and skipped states
    if state in ("INBOX", "PROPOSED", "SKIPPED"):
        # Use different endpoint for INBOX vs PROPOSED/SKIPPED
        confirm_url = f"/inbox/{identity_id}/confirm" if state == "INBOX" else f"/confirm/{identity_id}"
        buttons.append(Button(
            "\u2713 Confirm",
            cls="px-3 py-1.5 text-sm font-bold bg-emerald-600 text-white rounded hover:bg-emerald-700 transition-colors min-h-[44px]",
            hx_post=confirm_url,
            hx_target=f"#identity-{identity_id}",
            hx_swap="outerHTML",
            hx_indicator=f"#loading-{identity_id}",
            aria_label="Confirm this identity",
            type="button",
        ))

    # Skip button - available for reviewable states only
    if state in ("INBOX", "PROPOSED"):
        buttons.append(Button(
            "\u23f8 Skip",
            cls="px-3 py-1.5 text-sm font-bold bg-amber-500 text-white rounded hover:bg-amber-600 transition-colors min-h-[44px]",
            hx_post=f"/identity/{identity_id}/skip",
            hx_target=f"#identity-{identity_id}",
            hx_swap="outerHTML",
            hx_indicator=f"#loading-{identity_id}",
            aria_label="Skip for later",
            type="button",
        ))

    # Reject button - available for reviewable and skipped states
    if state in ("INBOX", "PROPOSED", "SKIPPED"):
        # Use different endpoint for INBOX vs PROPOSED/SKIPPED
        reject_url = f"/inbox/{identity_id}/reject" if state == "INBOX" else f"/reject/{identity_id}"
        buttons.append(Button(
            "\u2717 Reject",
            cls="px-3 py-1.5 text-sm font-bold border-2 border-red-500 text-red-500 rounded hover:bg-red-500/20 transition-colors min-h-[44px]",
            hx_post=reject_url,
            hx_target=f"#identity-{identity_id}",
            hx_swap="outerHTML",
            hx_indicator=f"#loading-{identity_id}",
            aria_label="Reject this identity",
            type="button",
        ))

    # Reset button - available for terminal states
    if state in ("CONFIRMED", "SKIPPED", "REJECTED", "CONTESTED"):
        buttons.append(Button(
            "\u21a9 Return to Inbox",
            cls="px-3 py-1.5 text-sm font-bold border border-slate-500 text-slate-400 rounded hover:bg-slate-700 transition-colors min-h-[44px]",
            hx_post=f"/identity/{identity_id}/reset",
            hx_target=f"#identity-{identity_id}",
            hx_swap="outerHTML",
            hx_indicator=f"#loading-{identity_id}",
            aria_label="Return to Inbox",
            type="button",
        ))

    # Loading indicator
    buttons.append(Span(
        "...",
        id=f"loading-{identity_id}",
        cls="htmx-indicator ml-2 text-slate-400 animate-pulse",
        aria_hidden="true",
    ))

    return Div(
        *buttons,
        cls="flex gap-2 items-center flex-wrap mt-3",
    )


def state_badge(state: str) -> Span:
    """
    Render state as a colored badge.
    UX Intent: Instant state recognition via color coding.
    """
    colors = {
        "INBOX": "bg-blue-600 text-white",
        "CONFIRMED": "bg-emerald-600 text-white",
        "PROPOSED": "bg-amber-500 text-white",
        "CONTESTED": "bg-red-600 text-white",
        "REJECTED": "bg-rose-700 text-white",
        "SKIPPED": "bg-stone-500 text-white",
    }
    return Span(
        state,
        cls=f"text-xs font-bold px-2 py-1 rounded {colors.get(state, 'bg-gray-500 text-white')}"
    )


def era_badge(era: str) -> Span:
    """
    Render era classification as a subtle badge.
    UX Intent: Temporal context without visual dominance.
    """
    if not era:
        return None
    return Span(
        era,
        cls="absolute top-2 right-2 bg-stone-700/80 text-white text-xs px-2 py-1 font-mono"
    )


# Share icon SVG (three connected dots) — used everywhere for consistency
_SHARE_ICON_SVG = '<svg xmlns="http://www.w3.org/2000/svg" class="w-3.5 h-3.5 inline" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"/></svg>'


def og_tags(title: str, description: str = "", image_url: str = "", canonical_url: str = "", og_type: str = "website") -> tuple:
    """
    Unified OG meta tags for social sharing previews.
    All URLs are converted to absolute (prepends SITE_URL if relative).
    Returns a tuple of Meta elements to spread into Title() or page head.
    """
    # Ensure absolute URLs
    if image_url and not image_url.startswith("http"):
        image_url = f"{SITE_URL}{image_url}"
    if canonical_url and not canonical_url.startswith("http"):
        canonical_url = f"{SITE_URL}{canonical_url}"
    tags = [
        Meta(property="og:title", content=title),
        Meta(property="og:description", content=description),
        Meta(property="og:url", content=canonical_url),
        Meta(property="og:type", content=og_type),
        Meta(property="og:site_name", content="Rhodesli \u2014 Heritage Photo Archive"),
        Meta(name="twitter:card", content="summary_large_image" if image_url else "summary"),
        Meta(name="twitter:title", content=title),
        Meta(name="twitter:description", content=description),
        Meta(name="description", content=description),
    ]
    if image_url:
        tags.insert(2, Meta(property="og:image", content=image_url))
        tags.append(Meta(name="twitter:image", content=image_url))
    return tuple(tags)


def share_button(photo_id: str = None, *, url: str = None, style: str = "icon", label: str = "Share", title: str = "", text: str = ""):
    """
    Reusable share button. Works with photo_id (legacy) or any url.
    Uses data-action="share-photo" for global event delegation.

    photo_id: Legacy param — generates /photo/{photo_id} URL
    url: Direct URL to share (takes precedence over photo_id)
    style: "icon" (compact), "button" (icon + text), "link" (text link), "prominent" (large CTA)
    title: Share title for native share sheet (optional)
    text: Share description for native share sheet (optional)
    """
    share_url = url or (f"/photo/{photo_id}" if photo_id else "")
    extra_attrs = {}
    if title:
        extra_attrs["data_share_title"] = title
    if text:
        extra_attrs["data_share_text"] = text
    if style == "button":
        return Button(
            NotStr(f'<svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4 mr-1.5 inline" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"/></svg>'),
            label,
            cls="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-500 text-white text-sm rounded-lg transition-colors inline-flex items-center",
            type="button",
            data_action="share-photo",
            data_share_url=share_url,
            **extra_attrs,
        )
    elif style == "link":
        return Button(
            NotStr(_SHARE_ICON_SVG),
            f" {label}",
            cls="text-xs text-indigo-400 hover:text-indigo-300 underline inline-flex items-center gap-1",
            type="button",
            data_action="share-photo",
            data_share_url=share_url,
            **extra_attrs,
        )
    elif style == "prominent":
        return Button(
            NotStr(f'<svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 mr-2 inline" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"/></svg>'),
            label,
            cls="px-5 py-2.5 bg-indigo-600 hover:bg-indigo-500 text-white text-base font-medium rounded-xl transition-colors inline-flex items-center shadow-lg hover:shadow-xl",
            type="button",
            data_action="share-photo",
            data_share_url=share_url,
            **extra_attrs,
        )
    else:  # "icon" — compact, for grid overlays and card corners
        return Button(
            NotStr(_SHARE_ICON_SVG),
            cls="p-1.5 bg-black/60 hover:bg-indigo-600 text-white rounded transition-colors",
            type="button",
            data_action="share-photo",
            data_share_url=share_url,
            title=label,
            **extra_attrs,
        )


def parse_transform_to_css(transform_str: str) -> str:
    """Convert a transform string like 'rotate:90,flipH' to CSS transform value.

    Supported transforms:
    - rotate:90, rotate:180, rotate:270 — clockwise rotation
    - flipH — horizontal mirror (scaleX(-1))
    - flipV — vertical mirror (scaleY(-1))
    - invert — handled separately via CSS filter, not transform

    Returns CSS transform property value (e.g., 'rotate(90deg) scaleX(-1)').
    """
    if not transform_str or not transform_str.strip():
        return ""

    parts = [p.strip() for p in transform_str.split(",") if p.strip()]
    css_parts = []
    for part in parts:
        if part.startswith("rotate:"):
            degrees = part.split(":")[1]
            css_parts.append(f"rotate({degrees}deg)")
        elif part == "flipH":
            css_parts.append("scaleX(-1)")
        elif part == "flipV":
            css_parts.append("scaleY(-1)")
        # 'invert' is handled via CSS filter, not transform
    return " ".join(css_parts)


def parse_transform_to_filter(transform_str: str) -> str:
    """Extract CSS filter from transform string (for 'invert')."""
    if not transform_str or "invert" not in transform_str:
        return ""
    return "invert(1)"


def image_transform_toolbar(photo_id: str, target: str = "front") -> Div:
    """Admin toolbar for non-destructive image orientation.

    target: 'front' or 'back' — which image side to transform.
    """
    field_name = "transform" if target == "front" else "back_transform"
    label = "Front orientation" if target == "front" else "Back orientation"

    def _btn(icon_label, transform_val, danger=False):
        cls_base = "px-2 py-1 text-xs rounded transition-colors"
        cls_color = "bg-red-900/50 hover:bg-red-800/50 text-red-300" if danger else "bg-slate-700 hover:bg-slate-600 text-slate-300"
        return Button(
            icon_label,
            cls=f"{cls_base} {cls_color}",
            type="button",
            hx_post=f"/api/photo/{photo_id}/transform?transform={transform_val}&field={field_name}",
            hx_target="#transform-result",
            hx_swap="innerHTML",
        )

    return Div(
        P(label, cls="text-xs text-slate-400 font-medium mb-1"),
        Div(
            _btn("\u21bb 90\u00b0", "rotate:90"),
            _btn("\u21ba -90\u00b0", "rotate:270"),
            _btn("\u2194 Flip H", "flipH"),
            _btn("\u2195 Flip V", "flipV"),
            _btn("\u25d0 Invert", "invert"),
            _btn("\u21a9 Reset", "reset", danger=True),
            cls="flex flex-wrap gap-1",
        ),
        cls="mt-2",
    )


def face_card(
    face_id: str,
    crop_url: str,
    quality: float = None,
    era: str = None,
    identity_id: str = None,
    photo_id: str = None,
    show_actions: bool = False,
    show_detach: bool = False,
    is_admin: bool = True,
) -> Div:
    """
    Single face card with optional action buttons.
    UX Intent: Face-first display with metadata secondary.

    Args:
        face_id: Canonical face identifier (for alt text)
        crop_url: Resolved URL path to the crop image (from backend)
        quality: Quality score (extracted from URL if not provided)
        era: Era classification for badge display
        identity_id: Parent identity ID
        photo_id: Photo ID for "View Photo" button
        show_actions: Whether to show action buttons
        show_detach: Whether to show "Detach" button (only when identity has > 1 face)
        is_admin: Whether to show admin-only info (quality score)
    """
    if quality is None:
        # Extract quality from URL: /crops/{name}_{quality}_{idx}.jpg
        quality = parse_quality_from_filename(crop_url)
    if quality == 0.0:
        # Inbox crops don't encode quality in filename — look up from embeddings
        emb_quality = get_face_quality(face_id)
        if emb_quality is not None:
            quality = emb_quality

    # View Photo button (only if photo_id is available)
    # Pass identity_id for navigation context between identity's photos
    view_photo_btn = None
    if photo_id:
        _vp_url = f"/photo/{photo_id}/partial?face={face_id}"
        if identity_id:
            _vp_url += f"&identity_id={identity_id}"
        view_photo_btn = Button(
            "View Photo",
            cls="text-xs text-slate-400 hover:text-slate-300 underline mt-1",
            hx_get=_vp_url,
            hx_target="#photo-modal-content",
            hx_swap="innerHTML",
            # Show the modal when clicked
            **{"_": "on click remove .hidden from #photo-modal"},
            type="button",
        )

    # Share button for public photo viewer
    full_page_link = None
    if photo_id:
        full_page_link = Span(
            share_button(photo_id, style="link", label="Share"),
            cls="mt-1 ml-2",
        )

    # Detach button (only if show_detach is True)
    detach_btn = None
    if show_detach:
        # Generate safe DOM ID for targeting
        safe_dom_id = make_css_id(face_id)

        detach_btn = Button(
            "Detach",
            cls="text-xs text-slate-400 hover:text-slate-300 underline mt-1 ml-2",
            hx_post=f"/api/face/{quote(face_id)}/detach",
            hx_target=f"#{safe_dom_id}",
            hx_swap="outerHTML",
            hx_confirm="Move this face to its own identity? (You can merge it back later.)",
            type="button",
        )

    return Div(
        # Image container with era badge
        Div(
            Img(
                src=crop_url,
                alt=face_id,
                cls="w-full aspect-square object-cover sepia-[.3] hover:sepia-0 transition-all duration-300"
            ),
            era_badge(era) if era else None,
            cls="relative border border-slate-600 bg-slate-700"
        ),
        # Metadata and actions
        Div(
            P(
                f"Quality: {quality:.2f}",
                cls="text-xs font-data text-slate-500"
            ) if is_admin and quality > 0 else None,
            Div(
                view_photo_btn,
                full_page_link,
                detach_btn,
                cls="flex items-center"
            ) if view_photo_btn or detach_btn or full_page_link else None,
            cls="mt-2"
        ),
        cls="bg-slate-700 border border-slate-600 p-2 rounded shadow-md hover:shadow-lg transition-shadow",
        # Fix: Apply the safe ID to the container
        id=make_css_id(face_id)
    )


def neighbor_card(neighbor: dict, target_identity_id: str, crop_files: set, show_checkbox: bool = True, user_role: str = "admin", from_focus: bool = False, triage_filter: str = "", focus_section: str = "") -> Div:
    neighbor_id = neighbor["identity_id"]
    # UI BOUNDARY: sanitize name for safe rendering
    name = ensure_utf8_display(neighbor["name"])
    # Get values directly (no more negative scaling)
    distance = neighbor["distance"]
    percentile = neighbor.get("percentile", 1.0)
    confidence_gap = neighbor.get("confidence_gap", 0.0)

    can_merge = neighbor["can_merge"]
    face_count = neighbor.get("face_count", 0)
    co_occurrence = neighbor.get("co_occurrence", 0)

    # --- CALIBRATION: AD-013 Evidence-Based Thresholds (2026-02-09) ---
    if distance < MATCH_THRESHOLD_VERY_HIGH:
        similarity_class = "bg-emerald-500/30 text-emerald-300"
        similarity_label = "Very High"
    elif distance < MATCH_THRESHOLD_HIGH:
        similarity_class = "bg-emerald-500/20 text-emerald-400"
        similarity_label = "High"
    elif distance < MATCH_THRESHOLD_MODERATE:
        similarity_class = "bg-amber-500/20 text-amber-400"
        similarity_label = "Moderate"
    elif distance < MATCH_THRESHOLD_MEDIUM:
        similarity_class = "bg-amber-500/15 text-amber-500"
        similarity_label = "Medium"
    else:
        similarity_class = "bg-slate-600 text-slate-400"
        similarity_label = "Low"
    # -----------------------------------------------

    # Merge button -- role-aware: admin merges directly, contributor suggests
    # In focus mode, target #focus-container and append from_focus=true so the merge
    # endpoint advances to the next identity instead of returning a browse-mode card.
    _focus_filter = f"&filter={triage_filter}" if triage_filter else ""
    _focus_section = f"&focus_section={focus_section}" if focus_section else ""
    focus_suffix = f"&from_focus=true{_focus_filter}{_focus_section}" if from_focus else ""
    if from_focus and focus_section == "skipped":
        merge_target = "#skipped-focus-container"
    elif from_focus:
        merge_target = "#focus-container"
    else:
        merge_target = f"#identity-{target_identity_id}"
    merge_swap = "outerHTML"
    if not can_merge:
        merge_btn = Button("Blocked", cls="px-3 py-1 text-sm font-bold bg-slate-600 text-slate-400 rounded cursor-not-allowed", disabled=True, title=neighbor.get("merge_blocked_reason_display"))
    elif user_role == "contributor":
        merge_btn = Button("Suggest Merge", cls="px-3 py-1 text-sm font-bold bg-purple-600 text-white rounded hover:bg-purple-500",
                           hx_post=f"/api/identity/{target_identity_id}/suggest-merge/{neighbor_id}", hx_target=f"#neighbor-{neighbor_id}",
                           hx_swap="outerHTML", data_auth_action="suggest a merge")
    else:
        merge_btn = Button("Merge", cls="px-3 py-1 text-sm font-bold bg-blue-600 text-white rounded hover:bg-blue-500",
                           hx_post=f"/api/identity/{target_identity_id}/merge/{neighbor_id}{focus_suffix}", hx_target=merge_target,
                           hx_swap=merge_swap, data_auth_action="merge these identities")

    # Compare button -- opens side-by-side comparison modal
    _compare_filter = f"?filter={triage_filter}" if triage_filter else ""
    compare_btn = Button(
        "Compare",
        cls="px-2 py-1 text-xs font-bold border border-amber-400/50 text-amber-400 rounded hover:bg-amber-500/20",
        hx_get=f"/api/identity/{target_identity_id}/compare/{neighbor_id}{_compare_filter}",
        hx_target="#compare-modal-content",
        hx_swap="innerHTML",
        **{"_": "on click remove .hidden from #compare-modal"},
        type="button",
    )

    # Thumbnail logic — prefer best quality, fall back to any available crop
    thumbnail_img = Div(cls="w-16 h-16 bg-slate-600 rounded")
    anchor_face_ids = neighbor.get("anchor_face_ids", []) + neighbor.get("candidate_face_ids", [])
    crop_url = None
    best_fid = get_best_face_id(anchor_face_ids) if anchor_face_ids else None
    if best_fid:
        crop_url = resolve_face_image_url(best_fid, crop_files)
    if not crop_url:
        for fid in anchor_face_ids:
            crop_url = resolve_face_image_url(fid, crop_files)
            if crop_url:
                break
    if crop_url:
        thumbnail_img = Img(src=crop_url, alt=name, cls="w-16 h-16 object-cover rounded border border-slate-600 hover:scale-105 transition-transform")

    # Checkbox for bulk selection (linked to bulk form via hyperscript)
    # Uses property assignment (not attribute toggle) so FormData picks it up
    checkbox = Input(
        type="checkbox",
        cls="w-4 h-4 rounded border-slate-500 bg-slate-700 text-blue-500 focus:ring-blue-500 focus:ring-offset-0 cursor-pointer flex-shrink-0",
        **{"_": f"on change set #bulk-{neighbor_id}.checked to my.checked"},
    ) if (show_checkbox and can_merge) else None

    # Determine the correct section for this neighbor based on its state
    neighbor_section = _section_for_state(neighbor.get("state", "INBOX"))

    # Navigation script: try to scroll if element exists, otherwise navigate to browse mode
    nav_script = f"on click set target to #identity-{neighbor_id} then if target exists call target.scrollIntoView({{behavior: 'smooth', block: 'center'}}) then add .ring-2 .ring-blue-400 to target then wait 1.5s then remove .ring-2 .ring-blue-400 from target else go to url '/?section={neighbor_section}&view=browse#identity-{neighbor_id}'"

    return Div(
        Div(checkbox,
            A(thumbnail_img, href=f"/?section={neighbor_section}&view=browse#identity-{neighbor_id}", cls="flex-shrink-0 cursor-pointer hover:opacity-80", **{"_": nav_script}),
            Div(Div(A(name, href=f"/?section={neighbor_section}&view=browse#identity-{neighbor_id}", cls="font-medium text-slate-200 truncate hover:text-blue-400 hover:underline cursor-pointer", **{"_": nav_script}),
                    Span(similarity_label, cls=f"text-xs px-2 py-0.5 rounded ml-2 {similarity_class}"), cls="flex items-center"),
                # EXPLAINABILITY: Distance + confidence gap (how much closer than next-best)
                Div(Span(f"Dist: {distance:.2f}", cls="text-xs font-data text-slate-400 ml-2 bg-slate-700 px-1 rounded"),
                    Span(f"+{confidence_gap}% gap", cls="text-xs font-data text-emerald-400/70 ml-1 bg-emerald-900/30 px-1 rounded") if confidence_gap > 0 else None,
                    Span(f"Seen together in {co_occurrence} photo{'s' if co_occurrence != 1 else ''}", cls="text-[10px] text-amber-400 italic ml-1") if co_occurrence > 0 else None,
                    cls="flex items-center flex-wrap"),
                cls="flex-1 min-w-0 ml-3"),
            Div(compare_btn, merge_btn, Button("Not Same", cls="px-2 py-1 text-xs font-bold border border-red-400/50 text-red-400 rounded hover:bg-red-500/20",
                                  hx_post=f"/api/identity/{target_identity_id}/reject/{neighbor_id}", hx_target=f"#neighbor-{neighbor_id}", hx_swap="outerHTML"),
                share_button(url=f"/identify/{target_identity_id}/match/{neighbor_id}", style="icon",
                             title="Are these the same person?", text=f"Help identify: {name}"),
                cls="flex items-center gap-1 sm:gap-2 flex-shrink-0 sm:ml-2 mt-2 sm:mt-0"),
            cls="flex flex-wrap sm:flex-nowrap items-center gap-2"),
        id=f"neighbor-{neighbor_id}", cls="p-3 bg-slate-700 border border-slate-600 rounded shadow-md mb-2 hover:shadow-lg overflow-hidden"
    )

def search_result_card(result: dict, target_identity_id: str, crop_files: set, user_role: str = "admin") -> Div:
    """
    Card for a manual search result.
    Similar styling to neighbor_card but simpler (no distance/percentile).
    """
    result_id = result["identity_id"]
    # UI BOUNDARY: sanitize name for safe rendering
    raw_name = ensure_utf8_display(result["name"])
    name = raw_name or f"Identity {result_id[:8]}..."
    face_count = result.get("face_count", 0)
    preview_face_id = result.get("preview_face_id")

    # Thumbnail from preview_face_id
    thumbnail_img = Div(cls="w-10 h-10 bg-slate-600 rounded")
    if preview_face_id:
        crop_url = resolve_face_image_url(preview_face_id, crop_files)
        if crop_url:
            thumbnail_img = Img(
                src=crop_url,
                alt=name,
                cls="w-12 h-12 object-cover rounded border border-slate-600"
            )

    # Compare button -- opens side-by-side comparison modal (same pattern as neighbor_card)
    compare_btn = Button(
        "Compare",
        cls="px-2 py-1 text-xs font-bold border border-amber-400/50 text-amber-400 rounded hover:bg-amber-500/20",
        hx_get=f"/api/identity/{target_identity_id}/compare/{result_id}",
        hx_target="#compare-modal-content",
        hx_swap="innerHTML",
        **{"_": "on click remove .hidden from #compare-modal"},
        type="button",
    )

    # Merge button -- role-aware: admin merges directly, contributor suggests
    if user_role == "contributor":
        merge_btn = Button(
            "Suggest Merge",
            cls="px-2 py-1 text-xs font-bold bg-purple-600 text-white rounded hover:bg-purple-500",
            hx_post=f"/api/identity/{target_identity_id}/suggest-merge/{result_id}",
            hx_target=f"#search-result-{result_id}",
            hx_swap="outerHTML",
            data_auth_action="suggest a merge",
        )
    else:
        merge_btn = Button(
            "Merge",
            cls="px-2 py-1 text-xs font-bold border border-blue-500/50 text-blue-400 rounded hover:bg-blue-500/20",
            hx_post=f"/api/identity/{target_identity_id}/merge/{result_id}?source=manual_search",
            hx_target=f"#identity-{target_identity_id}",
            hx_swap="outerHTML",
            data_auth_action="merge these identities",
        )

    # Navigation hyperscript (same as neighbor_card)
    nav_script = f"on click set target to #identity-{result_id} then if target exists call target.scrollIntoView({{behavior: 'smooth', block: 'center'}}) then add .ring-2 .ring-blue-400 to target then wait 1.5s then remove .ring-2 .ring-blue-400 from target"

    return Div(
        Div(
            A(thumbnail_img, href=f"#identity-{result_id}", cls="flex-shrink-0 cursor-pointer hover:opacity-80", **{"_": nav_script}),
            Div(
                A(name, href=f"#identity-{result_id}", cls="font-medium text-slate-200 truncate text-sm hover:text-blue-400 hover:underline cursor-pointer", **{"_": nav_script}),
                Span(f"{face_count} face{'s' if face_count != 1 else ''}", cls="text-xs text-slate-400 ml-2"),
                cls="flex items-center ml-2 flex-1 min-w-0"
            ),
            Div(compare_btn, merge_btn, cls="flex items-center gap-1 flex-shrink-0 ml-2"),
            cls="flex items-center"
        ),
        id=f"search-result-{result_id}",
        cls="p-2 bg-slate-700 border border-slate-600 rounded shadow-md mb-2 hover:shadow-lg"
    )


def search_results_panel(results: list, target_identity_id: str, crop_files: set, user_role: str = "admin") -> Div:
    """Panel showing manual search results."""
    if not results:
        return Div(
            P("No matching identities found.", cls="text-slate-400 italic text-sm"),
            id=f"search-results-{target_identity_id}"
        )

    cards = [search_result_card(r, target_identity_id, crop_files, user_role=user_role) for r in results]
    return Div(
        *cards,
        id=f"search-results-{target_identity_id}"
    )


def manual_search_section(identity_id: str) -> Div:
    """
    Manual search input and results container.
    Positioned in neighbors sidebar after Load More, before Rejected section.
    """
    return Div(
        H5("Manual Search", cls="text-sm font-semibold text-slate-300 mb-2"),
        Input(
            type="text",
            name="q",
            placeholder="Search by name...",
            cls="w-full px-3 py-2 text-sm bg-slate-800 border border-slate-600 text-slate-200 rounded focus:outline-none focus:ring-2 focus:ring-blue-400 focus:border-transparent placeholder-slate-500",
            hx_get=f"/api/identity/{identity_id}/search",
            hx_trigger="keyup changed delay:300ms",
            hx_target=f"#search-results-{identity_id}",
            hx_include="this",
        ),
        Div(id=f"search-results-{identity_id}", cls="mt-2"),
        cls="mt-4 pt-3 border-t border-slate-600"
    )


def neighbors_sidebar(identity_id: str, neighbors: list, crop_files: set, offset: int = 0, has_more: bool = False, rejected_count: int = 0, user_role: str = "admin", from_focus: bool = False, focus_section: str = "") -> Div:
    toggle_btn = Button(
        "▾ Collapse",
        cls="text-sm text-slate-400 hover:text-slate-300",
        id=f"neighbors-toggle-{identity_id}",
        type="button",
        **{"_": f"on click toggle .hidden on #neighbors-body-{identity_id} then if my.textContent == '▸ Expand' set my.textContent to '▾ Collapse' else set my.textContent to '▸ Expand'"},
    )
    if not neighbors: return Div(Div(P("No similar identities.", cls="text-slate-400 italic"), toggle_btn, cls="flex items-center justify-between"), manual_search_section(identity_id), cls="neighbors-sidebar p-4 bg-slate-700 rounded border border-slate-600 overflow-hidden")

    # Mergeable neighbors get checkboxes for bulk operations
    mergeable = [n for n in neighbors if n.get("can_merge")]
    cards = [neighbor_card(n, identity_id, crop_files, user_role=user_role, from_focus=from_focus, focus_section=focus_section) for n in neighbors]
    _focus_section_param = f"&focus_section={focus_section}" if focus_section else ""
    focus_param = f"&from_focus=true{_focus_section_param}" if from_focus else ""
    load_more = Button("Load More", cls="w-full text-sm text-indigo-400 hover:text-indigo-300 py-2 border border-indigo-500/50 rounded hover:bg-indigo-500/20",
                       hx_get=f"/api/identity/{identity_id}/neighbors?offset={offset+len(neighbors)}{focus_param}", hx_target=f"#neighbors-{identity_id}", hx_swap="innerHTML") if has_more else None

    # Bulk actions (only if there are mergeable neighbors)
    bulk_actions = None
    if len(mergeable) > 1:
        select_all_script = (
            "on click "
            "set cbs to <input[name='bulk_ids']/> in closest <form/> "
            "repeat for cb in cbs set cb.checked to my.checked end"
        )
        bulk_actions = Form(
            # Hidden inputs for each mergeable neighbor (checkboxes)
            Div(
                Label(
                    Input(type="checkbox", cls="mr-2 accent-blue-500",
                          **{"_": select_all_script}),
                    Span("Select All", cls="text-xs text-slate-400"),
                    cls="flex items-center cursor-pointer mb-2",
                ),
                *[Div(
                    Input(type="checkbox", name="bulk_ids", value=n["identity_id"],
                          cls="hidden bulk-checkbox",
                          id=f"bulk-{n['identity_id']}"),
                    cls="hidden",
                ) for n in mergeable],
                cls="",
            ),
            Div(
                Button("Merge Selected", type="button",
                       hx_post=f"/api/identity/{identity_id}/bulk-merge",
                       hx_include="closest form",
                       hx_target=f"#neighbors-{identity_id}",
                       hx_swap="innerHTML",
                       cls="px-3 py-1.5 text-xs font-bold bg-blue-600 text-white rounded hover:bg-blue-500"),
                Button("Not Same Selected", type="button",
                       hx_post=f"/api/identity/{identity_id}/bulk-reject",
                       hx_include="closest form",
                       hx_target=f"#neighbors-{identity_id}",
                       hx_swap="innerHTML",
                       cls="px-3 py-1.5 text-xs font-bold border border-red-400/50 text-red-400 rounded hover:bg-red-500/20"),
                cls="flex gap-2",
            ),
            cls="mb-3 p-2 bg-slate-600/50 rounded border border-slate-600",
        )

    # Manual search section - between Load More and Rejected
    manual_search = manual_search_section(identity_id)

    rejected = Div(Div(Span(f"{rejected_count} hidden matches", cls="text-xs text-slate-400 italic"),
                       Button("Review", cls="text-xs text-indigo-400 hover:text-indigo-300 ml-2", hx_get=f"/api/identity/{identity_id}/rejected", hx_target=f"#rejected-list-{identity_id}", hx_swap="innerHTML"),
                       cls="flex items-center justify-between"), Div(id=f"rejected-list-{identity_id}"), cls="mt-4 pt-3 border-t border-slate-600") if rejected_count > 0 else None

    return Div(
        Div(H4("Similar Identities", cls="text-lg font-serif font-bold text-white"), toggle_btn, cls="flex items-center justify-between mb-3"),
        Div(
            bulk_actions,
            Div(*cards), Div(load_more, cls="mt-3") if load_more else None, manual_search, rejected,
            id=f"neighbors-body-{identity_id}",
        ),
        cls="neighbors-sidebar p-4 bg-slate-700 rounded border border-slate-600 overflow-hidden",
    )


def name_display(identity_id: str, name: str, is_admin: bool = True,
                  generation_qualifier: str = "") -> Div:
    """
    Identity name display with edit button (admin only).
    Returns the name header component that can be swapped for inline editing.
    """
    # UI BOUNDARY: sanitize name for safe rendering
    safe_name = ensure_utf8_display(name)
    display_name = safe_name or f"Identity {identity_id[:8]}..."
    if generation_qualifier:
        display_name = f"{display_name} {generation_qualifier}"
    edit_btn = Button(
        "Edit",
        hx_get=f"/api/identity/{identity_id}/rename-form",
        hx_target=f"#name-{identity_id}",
        hx_swap="outerHTML",
        cls="ml-2 text-xs text-slate-400 hover:text-slate-300 underline",
        type="button",
    ) if is_admin else None
    return Div(
        H3(display_name, cls="text-lg font-serif font-bold text-white"),
        edit_btn,
        id=f"name-{identity_id}",
        cls="flex items-center"
    )


FACES_PER_PAGE = 8


def _build_face_cards_for_entries(face_entries, crop_files, identity_id, can_detach, is_admin=True):
    """Build face card elements from a list of face entries."""
    cards = []
    for face_entry in face_entries:
        if isinstance(face_entry, str):
            face_id = face_entry
            era = None
        else:
            face_id = face_entry.get("face_id", "")
            era = face_entry.get("era_bin")

        crop_url = resolve_face_image_url(face_id, crop_files)
        if crop_url:
            photo_id = get_photo_id_for_face(face_id)
            cards.append(face_card(
                face_id=face_id,
                crop_url=crop_url,
                era=era,
                identity_id=identity_id,
                photo_id=photo_id,
                show_detach=can_detach,
                is_admin=is_admin,
            ))
        else:
            cards.append(Div(
                Div(
                    Span("?", cls="text-4xl text-slate-500"),
                    cls="w-full aspect-square bg-slate-700 border border-slate-600 flex items-center justify-center"
                ),
                P("Image unavailable", cls="text-xs text-slate-400 mt-1"),
                P(f"ID: {face_id[:12]}...", cls="text-xs font-data text-slate-500"),
                cls="face-card",
                id=make_css_id(face_id),
            ))
    return cards


def _face_pagination_controls(identity_id: str, page: int, total_faces: int, sort: str = "date"):
    """Build pagination controls for face grid carousel."""
    total_pages = (total_faces + FACES_PER_PAGE - 1) // FACES_PER_PAGE
    if total_pages <= 1:
        return None

    start = page * FACES_PER_PAGE + 1
    end = min((page + 1) * FACES_PER_PAGE, total_faces)

    prev_btn = Button(
        Span("<", cls="text-lg"),
        cls="px-2 py-1 text-slate-400 hover:text-white hover:bg-slate-600 rounded transition-colors",
        hx_get=f"/api/identity/{identity_id}/faces?page={page - 1}&sort={sort}",
        hx_target=f"#faces-{identity_id}",
        hx_swap="outerHTML",
        type="button",
    ) if page > 0 else Button(
        Span("<", cls="text-lg"),
        cls="px-2 py-1 text-slate-400 opacity-30 cursor-not-allowed rounded",
        type="button",
        disabled=True,
    )

    next_btn = Button(
        Span(">", cls="text-lg"),
        cls="px-2 py-1 text-slate-400 hover:text-white hover:bg-slate-600 rounded transition-colors",
        hx_get=f"/api/identity/{identity_id}/faces?page={page + 1}&sort={sort}",
        hx_target=f"#faces-{identity_id}",
        hx_swap="outerHTML",
        type="button",
    ) if page < total_pages - 1 else Button(
        Span(">", cls="text-lg"),
        cls="px-2 py-1 text-slate-400 opacity-30 cursor-not-allowed rounded",
        type="button",
        disabled=True,
    )

    return Div(
        prev_btn,
        Span(f"{start}-{end} of {total_faces}", cls="text-xs text-slate-400 mx-2"),
        next_btn,
        cls="flex items-center justify-center gap-1 mt-3"
    )


def identity_card(
    identity: dict,
    crop_files: set,
    lane_color: str = "stone",
    show_actions: bool = False,
    is_admin: bool = True,
) -> Div:
    """
    Identity group card showing all faces (anchors + candidates).
    UX Intent: Group context with individual face visibility.
    Action buttons only shown for admin users.
    Shows first page of faces (max FACES_PER_PAGE) with pagination if more exist.
    """
    identity_id = identity["identity_id"]
    # UI BOUNDARY: sanitize name for safe rendering
    raw_name = ensure_utf8_display(identity.get("name"))
    name = raw_name or f"Identity {identity_id[:8]}..."
    state = identity["state"]

    # Combine anchors (confirmed) and candidates (proposed) for display
    all_face_ids = identity.get("anchor_ids", []) + identity.get("candidate_ids", [])
    total_faces = len(all_face_ids)

    # Show detach button only if identity has more than one face AND user is admin
    can_detach = total_faces > 1 and is_admin

    # Show only first page of faces
    page_entries = all_face_ids[:FACES_PER_PAGE]
    face_cards = _build_face_cards_for_entries(page_entries, crop_files, identity_id, can_detach, is_admin=is_admin)

    if not face_cards:
        return None

    border_colors = {
        "blue": "border-l-blue-500",
        "emerald": "border-l-emerald-500",
        "amber": "border-l-amber-500",
        "red": "border-l-red-500",
        "stone": "border-l-stone-400",
        "rose": "border-l-rose-500",
    }

    # Sort dropdown for face ordering
    sort_dropdown = Select(
        Option("Sort by Date", value="date", selected=True),
        Option("Sort by Outlier", value="outlier"),
        cls="text-xs border border-slate-600 bg-slate-700 text-slate-300 rounded px-2 py-1",
        hx_get=f"/api/identity/{identity_id}/faces",
        hx_target=f"#faces-{identity_id}",
        hx_swap="outerHTML",
        name="sort",
        hx_trigger="change",
    )

    # View All Photos button (opens photo modal)
    view_all_photos_btn = Button(
        "\U0001f4f7 View All Photos",
        cls="px-3 py-1.5 text-sm font-medium bg-amber-600/20 text-amber-300 border border-amber-500/30 rounded-lg hover:bg-amber-600/30 hover:border-amber-400/50 transition-colors",
        hx_get=f"/api/identity/{identity_id}/photos?index=0",
        hx_target="#photo-modal-content",
        hx_swap="innerHTML",
        **{"_": "on click remove .hidden from #photo-modal"},
        type="button",
    ) if total_faces > 0 else None

    # View Public Page link (for confirmed identities with real names)
    view_public_link = None
    if state == "CONFIRMED" and not name.startswith("Unidentified") and not name.startswith("Identity "):
        view_public_link = A(
            "\U0001f517 Public Page",
            href=f"/person/{identity_id}",
            cls="px-3 py-1.5 text-sm font-medium text-slate-400 border border-slate-600 rounded-lg hover:text-indigo-300 hover:border-indigo-500/30 transition-colors",
            target="_blank",
        )

    # Find Similar button (loads neighbors via HTMX) -- scrolls into view after swap
    find_similar_btn = Button(
        "\U0001f50d Find Similar",
        cls="px-3 py-1.5 text-sm font-medium bg-indigo-600/20 text-indigo-300 border border-indigo-500/30 rounded-lg hover:bg-indigo-600/30 hover:border-indigo-400/50 transition-colors",
        hx_get=f"/api/identity/{identity_id}/neighbors",
        hx_target=f"#neighbors-{identity_id}",
        hx_swap="innerHTML",
        hx_indicator=f"#neighbors-loading-{identity_id}",
        type="button",
        **{"hx-on::after-swap": f"document.getElementById('neighbors-{identity_id}').scrollIntoView({{behavior: 'smooth', block: 'start'}})"},
    )

    # Neighbors container (populated by HTMX)
    neighbors_container = Div(
        Span(
            "Loading...",
            id=f"neighbors-loading-{identity_id}",
            cls="htmx-indicator text-slate-400 text-sm",
        ),
        id=f"neighbors-{identity_id}",
        cls="mt-4"
    )

    # Pagination controls
    pagination = _face_pagination_controls(identity_id, 0, total_faces, "date")

    # Badge for merged-unnamed identities (multiple faces but no human name)
    grouped_badge = None
    if total_faces > 1 and (name.startswith("Unidentified") or name.startswith("Identity ")):
        grouped_badge = Span(
            f"Grouped ({total_faces} faces)",
            cls="text-xs px-2 py-0.5 rounded bg-purple-600/20 text-purple-300 border border-purple-500/30 ml-2",
        )

    return Div(
        # Header with name, state, and controls
        Div(
            Div(
                name_display(identity_id, identity.get("name"), is_admin=is_admin,
                             generation_qualifier=identity.get("generation_qualifier", "")),
                state_badge(state),
                _proposal_badge_inline(identity_id),
                _promotion_badge(identity),
                grouped_badge,
                Span(
                    f"{total_faces} face{'s' if total_faces != 1 else ''}",
                    cls="text-xs text-slate-400 ml-2"
                ),
                cls="flex items-center gap-3 flex-wrap"
            ),
            Div(
                sort_dropdown,
                view_all_photos_btn,
                find_similar_btn,
                view_public_link,
                cls="flex items-center gap-3"
            ),
            cls="identity-card-header flex items-center justify-between mb-3"
        ),
        # Face grid (paginated)
        Div(
            Div(
                *face_cards,
                cls="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3",
            ),
            pagination,
            id=f"faces-{identity_id}",
        ),
        # Identity metadata (AN-012)
        _identity_metadata_display(identity, is_admin=is_admin),
        # Action buttons based on state (admin only)
        review_action_buttons(identity_id, state, is_admin=is_admin),
        # Neighbors container (shown when "Find Similar" is clicked)
        neighbors_container,
        cls=f"identity-card bg-slate-800 border border-slate-700 border-l-4 {border_colors.get(lane_color, '')} p-4 rounded-r shadow-lg mb-4",
        id=f"identity-{identity_id}",
        data_name=(raw_name or "").lower()
    )


def photo_modal() -> Div:
    """
    Modal container for photo context viewer.
    Hidden by default, shown via HTMX when "View Photo" is clicked.

    Z-index hierarchy:
    - Toast container: z-[10001] (above all modals — always visible)
    - Modal container: z-[9999] (above page content)
    - Backdrop: absolute, no z-index (first child, renders behind content)
    - Content: relative, no z-index (second child, renders above backdrop)
    """
    return Div(
        # Backdrop - absolute within the fixed parent, click to close
        Div(
            cls="absolute inset-0 bg-black/80",
            **{"_": "on click add .hidden to #photo-modal"},
        ),
        # Modal content - relative positioning to sit above backdrop
        Div(
            # Header with close button
            Div(
                H2("Photo Context", cls="text-xl font-serif font-bold text-white"),
                Button(
                    "X",
                    cls="text-slate-400 hover:text-white text-xl font-bold",
                    **{"_": "on click add .hidden to #photo-modal"},
                    type="button",
                    aria_label="Close modal",
                ),
                cls="flex justify-between items-center mb-4 pb-2 border-b border-slate-700"
            ),
            # Content area (populated by HTMX)
            Div(
                P("Loading...", cls="text-slate-400 text-center py-8"),
                id="photo-modal-content",
            ),
            cls="bg-slate-800 rounded-lg shadow-2xl w-full max-w-full sm:max-w-5xl max-h-[90vh] overflow-auto p-3 sm:p-6 relative border border-slate-700"
        ),
        id="photo-modal",
        cls="hidden fixed inset-0 flex items-center justify-center p-2 sm:p-4 z-[9999]",
        **{"_": "on keydown[key=='Escape'] add .hidden to me"},
        tabindex="-1",
    )



def compare_modal() -> Div:
    """
    Side-by-side comparison modal for evaluating merge candidates.
    Shows the source identity's best face alongside the neighbor's best face.
    """
    return Div(
        # Backdrop
        Div(
            cls="absolute inset-0 bg-black/85",
            **{"_": "on click add .hidden to #compare-modal"},
        ),
        # Content
        Div(
            # Header
            Div(
                H2("Compare Faces", cls="text-xl font-serif font-bold text-white"),
                Button(
                    "X",
                    cls="text-slate-400 hover:text-white text-xl font-bold",
                    **{"_": "on click add .hidden to #compare-modal"},
                    type="button",
                    aria_label="Close comparison",
                ),
                cls="flex justify-between items-center mb-4 pb-2 border-b border-slate-700"
            ),
            # Comparison content (populated by HTMX)
            Div(
                P("Loading...", cls="text-slate-400 text-center py-8"),
                id="compare-modal-content",
            ),
            cls="bg-slate-800 rounded-lg shadow-2xl w-full max-w-full sm:max-w-[90vw] lg:max-w-7xl max-h-[90vh] overflow-auto p-3 sm:p-6 relative border border-slate-700"
        ),
        id="compare-modal",
        cls="hidden fixed inset-0 flex items-center justify-center p-2 sm:p-4 z-[10000]",
        **{"_": "on keydown[key=='Escape'] add .hidden to me"},
    )


def login_modal() -> Div:
    """Login modal for unauthenticated HTMX action attempts.
    Shown by htmx:beforeSwap handler when server returns 401."""
    google_url = get_oauth_url("google")
    return Div(
        Div(cls="absolute inset-0 bg-black/80",
            **{"_": "on click add .hidden to #login-modal"}),
        Div(
            Div(
                H2("Sign in to continue", cls="text-xl font-bold text-white"),
                Button("X", cls="text-slate-400 hover:text-white text-xl font-bold",
                       **{"_": "on click add .hidden to #login-modal"},
                       type="button", aria_label="Close"),
                cls="flex justify-between items-center mb-4 pb-2 border-b border-slate-700"
            ),
            P("Sign in to contribute to the archive.", id="login-modal-message", cls="text-slate-400 mb-6 text-sm"),
            Form(
                Div(
                    Label("Email", fr="modal-email", cls="block text-sm mb-1 text-slate-300"),
                    Input(type="email", name="email", id="modal-email", required=True,
                          cls="w-full p-2 rounded bg-slate-700 text-white border border-slate-600"),
                    cls="mb-4"
                ),
                Div(
                    Label("Password", fr="modal-password", cls="block text-sm mb-1 text-slate-300"),
                    Input(type="password", name="password", id="modal-password", required=True,
                          cls="w-full p-2 rounded bg-slate-700 text-white border border-slate-600"),
                    cls="mb-4"
                ),
                Button("Sign In", type="submit",
                       cls="w-full p-2 bg-blue-600 hover:bg-blue-700 rounded text-white font-medium"),
                Div(id="login-modal-error", cls="text-red-400 text-sm mt-2"),
                hx_post="/login/modal", hx_target="#login-modal-error", hx_swap="innerHTML",
            ),
            # Google OAuth divider + button
            Div(
                Div(cls="flex-grow border-t border-slate-600"),
                Span("or", cls="px-4 text-slate-500 text-sm"),
                Div(cls="flex-grow border-t border-slate-600"),
                cls="flex items-center my-4"
            ) if google_url else None,
            A(
                NotStr('<svg viewBox="0 0 24 24" width="18" height="18" xmlns="http://www.w3.org/2000/svg"><path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92a5.06 5.06 0 0 1-2.2 3.32v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.1z" fill="#4285F4"/><path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/><path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/><path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/></svg>'),
                Span("Sign in with Google"),
                href=google_url or "#",
                style="display: flex; align-items: center; gap: 12px; padding: 0 16px; height: 40px; "
                      "background: white; border: 1px solid #dadce0; border-radius: 4px; cursor: pointer; "
                      "font-family: 'Roboto', Arial, sans-serif; font-size: 14px; color: #3c4043; "
                      "font-weight: 500; text-decoration: none; justify-content: center; width: 100%;",
            ) if google_url else None,
            Div(
                P(
                    A("Forgot password?", href="/forgot-password", cls="text-blue-400 hover:underline"),
                    cls="text-sm"
                ),
                P(
                    "No account? ",
                    A("Sign up with invite code", href="/signup", cls="text-blue-400 hover:underline"),
                    cls="text-sm text-slate-400"
                ),
                cls="mt-4 text-center space-y-1"
            ),
            cls="bg-slate-800 rounded-lg shadow-2xl max-w-md w-full p-4 sm:p-8 relative border border-slate-700"
        ),
        id="login-modal",
        cls="hidden fixed inset-0 flex items-center justify-center p-4 z-[9998]",
        **{"_": "on keydown[key=='Escape'] add .hidden to me"},
    )


def _guest_or_login_modal(form_data: dict) -> Div:
    """Modal offering anonymous guest submission or sign-in to save.

    form_data: dict of original annotation form fields to preserve.
    Returns a modal Div that replaces #guest-or-login-modal.
    """
    # Build hidden inputs from original form data
    hidden_fields = []
    for key, val in form_data.items():
        if val is not None:
            hidden_fields.append(Input(type="hidden", name=key, value=str(val)))

    google_url = get_oauth_url("google")

    return Div(
        Div(cls="absolute inset-0 bg-black/80",
            **{"_": "on click remove #guest-or-login-modal's children"}),
        Div(
            Div(
                H2("Save your suggestion", cls="text-xl font-bold text-white"),
                Button("X", cls="text-slate-400 hover:text-white text-xl font-bold",
                       **{"_": "on click remove #guest-or-login-modal's children"},
                       type="button", aria_label="Close"),
                cls="flex justify-between items-center mb-4 pb-2 border-b border-slate-700"
            ),
            P("Your suggestion will be reviewed by a family member.",
              cls="text-slate-400 mb-6 text-sm"),
            # Option 1: Continue as guest
            Form(
                *hidden_fields,
                Button("Continue as guest",
                       type="submit",
                       cls="w-full p-2 bg-emerald-600 hover:bg-emerald-700 rounded text-white font-medium"),
                P("Your suggestion will be saved anonymously.",
                  cls="text-xs text-slate-500 mt-1 text-center"),
                hx_post="/api/annotations/guest-submit",
                hx_target="#guest-or-login-modal",
                hx_swap="innerHTML",
            ),
            # Divider
            Div(
                Div(cls="flex-grow border-t border-slate-600"),
                Span("or", cls="px-4 text-slate-500 text-sm"),
                Div(cls="flex-grow border-t border-slate-600"),
                cls="flex items-center my-4"
            ),
            # Option 2: Sign in to save
            Form(
                *[Input(type="hidden", name=k, value=str(v))
                  for k, v in form_data.items() if v is not None],
                Button("Sign in to save",
                       type="submit",
                       cls="w-full p-2 bg-blue-600 hover:bg-blue-700 rounded text-white font-medium"),
                P("Track your contributions with your account.",
                  cls="text-xs text-slate-500 mt-1 text-center"),
                hx_post="/api/annotations/stash-and-login",
                hx_target="#guest-or-login-modal",
                hx_swap="innerHTML",
            ),
            cls="bg-slate-800 rounded-lg shadow-2xl max-w-md w-full p-4 sm:p-8 relative border border-slate-700"
        ),
        id="guest-or-login-modal",
        cls="fixed inset-0 flex items-center justify-center p-4 z-[10000]",
        **{"_": "on keydown[key=='Escape'] remove my children"},
    )


def _get_onboarding_surnames() -> list[str]:
    """Get canonical surname list from surname_variants.json for the onboarding grid."""
    variants_path = Path(__file__).resolve().parent.parent / "data" / "surname_variants.json"
    if not variants_path.exists():
        return []
    try:
        with open(variants_path) as f:
            data = json.load(f)
        return [g["canonical"] for g in data.get("variant_groups", []) if g.get("canonical")]
    except Exception:
        return []


def _welcome_banner() -> Div:
    """
    Dismissible welcome banner for first-time visitors (replaces modal wall).

    Shows a non-blocking top bar with context about the archive.
    Dismissed via X button; uses rhodesli_welcomed cookie (1 year).
    Content is immediately visible underneath — no overlay, no blocking.
    """
    return Div(
        Div(
            Div(
                Span("Welcome to Rhodesli", cls="font-semibold text-amber-100"),
                Span(" — ", cls="text-amber-300/60 hidden sm:inline"),
                Span("a heritage photo archive for the Jewish community of Rhodes. ",
                     cls="text-amber-200/80 hidden sm:inline"),
                Span("Know someone in these photos? Tap their face to help identify them.",
                     cls="text-amber-200/80 hidden sm:inline"),
                # Mobile: shorter copy
                Span(" — Tap a face to help identify someone.",
                     cls="text-amber-200/80 sm:hidden"),
                cls="flex-1 text-sm",
            ),
            Button(
                Svg(
                    Path(d="M6 18L18 6M6 6l12 12"),
                    cls="w-4 h-4", fill="none", stroke="currentColor", viewBox="0 0 24 24",
                    stroke_width="2", stroke_linecap="round", stroke_linejoin="round",
                ),
                type="button",
                cls="text-amber-300/60 hover:text-white ml-3 p-1 min-w-[28px] min-h-[28px] flex items-center justify-center",
                data_action="welcome-banner-dismiss",
                aria_label="Dismiss welcome banner",
            ),
            cls="max-w-6xl mx-auto px-4 sm:px-8 flex items-center",
        ),
        Script("""
            (function() {
                var welcomed = document.cookie.split(';').some(function(c) {
                    return c.trim().startsWith('rhodesli_welcomed=');
                });
                if (welcomed) {
                    var el = document.getElementById('welcome-banner');
                    if (el) el.remove();
                }
                document.addEventListener('click', function(e) {
                    var action = e.target.closest('[data-action="welcome-banner-dismiss"]');
                    if (action) {
                        document.cookie = 'rhodesli_welcomed=1; path=/; max-age=31536000; SameSite=Lax';
                        var banner = document.getElementById('welcome-banner');
                        if (banner) banner.remove();
                    }
                });
            })();
        """),
        id="welcome-banner",
        cls="bg-amber-900/40 border-b border-amber-700/30 py-2",
    )


def confirm_modal() -> Div:
    """Styled confirmation modal replacing native browser confirm().
    Shown by htmx:confirm event handler."""
    return Div(
        Div(cls="absolute inset-0 bg-black/80",
            **{"_": "on click add .hidden to #confirm-modal"}),
        Div(
            P("", id="confirm-modal-message", cls="text-white text-lg mb-6"),
            Div(
                Button("Cancel", id="confirm-modal-no", type="button",
                       cls="px-4 py-2 bg-slate-600 text-white rounded hover:bg-slate-500"),
                Button("Confirm", id="confirm-modal-yes", type="button",
                       cls="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-500 font-bold"),
                cls="flex justify-end gap-3"
            ),
            cls="bg-slate-800 rounded-lg shadow-2xl max-w-md w-full p-4 sm:p-6 relative border border-slate-700"
        ),
        id="confirm-modal",
        cls="hidden fixed inset-0 flex items-center justify-center p-4 z-[9997]",
        **{"_": "on keydown[key=='Escape'] add .hidden to me"},
    )


def lane_section(
    title: str,
    identities: list,
    crop_files: set,
    color: str,
    icon: str,
    show_actions: bool = False,
    lane_id: str = None,
) -> Div:
    """
    A swimlane for a specific identity state.
    UX Intent: Clear separation of epistemic states.
    """
    cards = []
    for identity in identities:
        card = identity_card(identity, crop_files, lane_color=color, show_actions=show_actions)
        if card:
            cards.append(card)

    bg_colors = {
        "blue": "bg-blue-900/20",
        "emerald": "bg-emerald-900/20",
        "amber": "bg-amber-900/20",
        "red": "bg-red-900/20",
        "stone": "bg-slate-800/50",
        "rose": "bg-rose-900/20",
    }

    # Fix: Always render the container ID even if empty, so OOB swaps have a target.
    content_area = Div(*cards, id=lane_id, cls="min-h-[50px]") if cards else Div(
        P(
            f"No {title.lower()} identities",
            cls="text-slate-400 italic text-center py-8"
        ),
        id=lane_id,
        cls="min-h-[50px]"
    )

    return Div(
        # Lane header
        Div(
            Span(icon, cls="text-2xl"),
            H2(title, cls="text-xl font-serif font-bold text-white"),
            Span(
                f"({len(cards)})",
                cls="text-sm text-slate-400"
            ),
            cls="flex items-center gap-3 mb-4 pb-2 border-b border-slate-700"
        ),
        # Cards or empty state
        content_area,
        cls=f"mb-8 p-4 rounded {bg_colors.get(color, '')}"
    )


# =============================================================================
# ROUTES - HEALTH CHECK
# =============================================================================


@rt("/health")
def health():
    """Health check endpoint for Railway deployment."""
    registry = load_registry()

    # Count photos from photo_index.json
    photo_count = 0
    photo_index_path = data_path / "photo_index.json"
    if photo_index_path.exists():
        with open(photo_index_path) as f:
            index = json.load(f)
            photo_count = len(index.get("photos", {}))

    return {
        "status": "ok",
        "identities": len(registry.list_identities()),
        "photos": photo_count,
        "processing_enabled": PROCESSING_ENABLED,
    }


# =============================================================================
# LANDING PAGE
# =============================================================================


def _compute_landing_stats() -> dict:
    """Compute live stats for the landing page from actual data."""
    registry = load_registry()
    photo_count = 0
    total_faces = 0
    photo_index_path = data_path / "photo_index.json"
    if photo_index_path.exists():
        with open(photo_index_path) as f:
            pi = json.load(f)
        photo_count = len(pi.get("photos", {}))
        for p in pi.get("photos", {}).values():
            total_faces += len(p.get("face_ids", []))
    confirmed = registry.list_identities(state=IdentityState.CONFIRMED)
    named_count = len([i for i in confirmed if not i.get("name", "").startswith("Unidentified")])
    inbox = registry.list_identities(state=IdentityState.INBOX)
    proposed = registry.list_identities(state=IdentityState.PROPOSED)
    needs_help = len([i for i in (inbox + proposed) if not i.get("merged_into")])
    return {"photo_count": photo_count, "named_count": named_count,
            "needs_help": needs_help, "total_faces": total_faces}


LANDING_HERO_PHOTOS = [
    "Image 930_compress.jpg",
    "Image 931_compress.jpg",
    "Image 924_compress.jpg",
    "Image 964_compress.jpg",
    "Image 001_compress.jpg",
    "Image 013_compress.jpg",
    "Image 006_compress.jpg",
    "Image 046_compress.jpg",
]


def landing_page(user=None) -> tuple:
    """Welcoming landing page for the Rhodes-Capeluto family archive."""
    stats = _compute_landing_stats()
    hero_photos = []
    for i, filename in enumerate(LANDING_HERO_PHOTOS):
        size_cls = "col-span-2 row-span-2" if i in (0, 3, 5) else "col-span-1 row-span-1"
        hero_photos.append(Div(Img(src=photo_url(filename), alt="Rhodes-Capeluto family photo", cls="w-full h-full object-cover", loading="lazy"), cls=f"{size_cls} overflow-hidden rounded-lg"))
    if user:
        primary_cta = A("Continue Reviewing", href="/?section=to_review", cls="inline-block px-8 py-4 bg-indigo-600 text-white text-lg font-semibold rounded-xl hover:bg-indigo-500 transition-colors shadow-lg hover:shadow-xl")
        secondary_cta = A("Browse Photos", href="/?section=photos", cls="inline-block px-8 py-4 border-2 border-slate-500 text-slate-200 text-lg font-semibold rounded-xl hover:border-slate-300 hover:text-white transition-colors")
    else:
        primary_cta = A("Start Exploring", href="/?section=photos", cls="inline-block px-8 py-4 bg-indigo-600 text-white text-lg font-semibold rounded-xl hover:bg-indigo-500 transition-colors shadow-lg hover:shadow-xl")
        secondary_cta = A("Join the Project", href="/signup", cls="inline-block px-8 py-4 border-2 border-slate-500 text-slate-200 text-lg font-semibold rounded-xl hover:border-slate-300 hover:text-white transition-colors") if is_auth_enabled() else A("Browse People", href="/?section=confirmed", cls="inline-block px-8 py-4 border-2 border-slate-500 text-slate-200 text-lg font-semibold rounded-xl hover:border-slate-300 hover:text-white transition-colors")
    def step_card(icon_svg, title, description):
        return Div(Div(NotStr(icon_svg), cls="w-16 h-16 mx-auto mb-4 rounded-full bg-indigo-500/10 border border-indigo-500/30 flex items-center justify-center text-indigo-400"), H3(title, cls="text-lg font-semibold text-white mb-2"), P(description, cls="text-slate-400 text-sm leading-relaxed"), cls="text-center px-4")
    browse_icon = '<svg xmlns="http://www.w3.org/2000/svg" class="w-7 h-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M2.25 15.75l5.159-5.159a2.25 2.25 0 013.182 0l5.159 5.159m-1.5-1.5l1.409-1.409a2.25 2.25 0 013.182 0l2.909 2.909M3.75 21h16.5A2.25 2.25 0 0022.5 18.75V5.25A2.25 2.25 0 0020.25 3H3.75A2.25 2.25 0 001.5 5.25v13.5A2.25 2.25 0 003.75 21z"/></svg>'
    identify_icon = '<svg xmlns="http://www.w3.org/2000/svg" class="w-7 h-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 6a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0zM4.501 20.118a7.5 7.5 0 0114.998 0A17.933 17.933 0 0112 21.75c-2.676 0-5.216-.584-7.499-1.632z"/></svg>'
    connect_icon = '<svg xmlns="http://www.w3.org/2000/svg" class="w-7 h-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M21 8.25c0-2.485-2.099-4.5-4.688-4.5-1.935 0-3.597 1.126-4.312 2.733-.715-1.607-2.377-2.733-4.313-2.733C5.1 3.75 3 5.765 3 8.25c0 7.22 9 12 9 12s9-4.78 9-12z"/></svg>'
    arrow_svg = '<svg xmlns="http://www.w3.org/2000/svg" class="w-8 h-8 text-slate-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 4.5L21 12m0 0l-7.5 7.5M21 12H3"/></svg>'
    style = Style("html, body { height: 100%; margin: 0; } body { background-color: #0f172a; } .hero-grid { display: grid; grid-template-columns: repeat(4, 1fr); grid-auto-rows: 120px; gap: 0.5rem; } @media (min-width: 768px) { .hero-grid { grid-auto-rows: 140px; } } @media (min-width: 1024px) { .hero-grid { grid-auto-rows: 160px; } } .hero-overlay { background: linear-gradient(to bottom, rgba(15,23,42,0.3) 0%, rgba(15,23,42,0.6) 50%, rgba(15,23,42,0.95) 100%); } .stat-card { transition: transform 0.2s ease; } .stat-card:hover { transform: translateY(-2px); } @keyframes landing-fade-in { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } } .landing-animate { animation: landing-fade-in 0.6s ease-out both; } .landing-animate-delay-1 { animation-delay: 0.1s; } .landing-animate-delay-2 { animation-delay: 0.2s; }")
    nav_links = _public_nav_links(active="", user=user)
    if user:
        nav_links.append(Span(user.email.split("@")[0], cls="text-xs text-slate-500 ml-4"))
    # Pick a hero image URL for OG (first available featured photo)
    _og_hero_url = f"{SITE_URL}/static/crops/landing-hero.jpg"
    _featured = _get_featured_photos(limit=1)
    if _featured:
        _hero_url = _featured[0].get("url", "")
        _og_hero_url = _hero_url if _hero_url.startswith("http") else f"{SITE_URL}{_hero_url}"
    _og_landing_desc = f"A living archive of {stats['photo_count']} photographs and {stats['named_count']} identified people from the Rhodes-Capeluto family. Help us preserve our shared heritage."
    return (
        Title("Rhodesli — Rhodes-Capeluto Family Archive"),
        Meta(property="og:title", content="Rhodesli — Rhodes-Capeluto Family Archive"),
        Meta(property="og:description", content=_og_landing_desc),
        Meta(property="og:image", content=_og_hero_url),
        Meta(property="og:url", content=SITE_URL),
        Meta(property="og:type", content="website"),
        Meta(property="og:site_name", content="Rhodesli — Heritage Photo Archive"),
        Meta(name="twitter:card", content="summary_large_image"),
        Meta(name="twitter:title", content="Rhodesli — Rhodes-Capeluto Family Archive"),
        Meta(name="twitter:description", content=_og_landing_desc),
        Meta(name="twitter:image", content=_og_hero_url),
        Meta(name="description", content=_og_landing_desc),
        style,
        Div(
        Nav(Div(A(Span("Rhodesli", cls="text-xl font-bold text-white"), href="/", cls="hover:opacity-90"), Div(*nav_links, cls="hidden sm:flex items-center gap-6"), cls="max-w-6xl mx-auto px-6 flex items-center justify-between"), cls="fixed top-0 left-0 right-0 h-16 bg-slate-900/80 backdrop-blur-md border-b border-slate-800 z-50", id="landing-nav"),
        Section(Div(*hero_photos, cls="hero-grid"), Div(cls="hero-overlay absolute inset-0"), Div(H1("Preserving the faces and stories of the Rhodes-Capeluto family", cls="text-3xl md:text-4xl lg:text-5xl font-bold text-white leading-tight mb-6 landing-animate max-w-3xl"), P("A living archive of our shared history, brought together by family and powered by careful research. Every photo tells a story. Every face is a connection.", cls="text-lg md:text-xl text-slate-300 mb-10 max-w-2xl landing-animate landing-animate-delay-1"), Div(primary_cta, secondary_cta, cls="flex flex-wrap gap-4 landing-animate landing-animate-delay-2"), cls="absolute inset-0 flex flex-col justify-end px-6 md:px-12 lg:px-16 pb-12 md:pb-16"), cls="relative overflow-hidden pt-16", id="hero"),
        Section(Div(P("The archive so far", cls="text-sm font-semibold text-indigo-400 uppercase tracking-wider mb-8 text-center"), Div(Div(Div(str(stats["photo_count"]), cls="text-4xl md:text-5xl font-bold text-white mb-1"), Div("photos preserved", cls="text-sm text-slate-400"), cls="stat-card text-center p-6 bg-slate-800/50 rounded-xl border border-slate-700/50"), Div(Div(str(stats["named_count"]), cls="text-4xl md:text-5xl font-bold text-emerald-400 mb-1"), Div("people identified", cls="text-sm text-slate-400"), cls="stat-card text-center p-6 bg-slate-800/50 rounded-xl border border-slate-700/50"), Div(Div(str(stats["total_faces"]), cls="text-4xl md:text-5xl font-bold text-amber-400 mb-1"), Div("faces detected", cls="text-sm text-slate-400"), cls="stat-card text-center p-6 bg-slate-800/50 rounded-xl border border-slate-700/50"), A(Div(str(stats["needs_help"]), cls="text-4xl md:text-5xl font-bold text-blue-400 mb-1"), Div("faces need your help", cls="text-sm text-slate-400"), href="/?section=to_review", cls="stat-card text-center p-6 bg-slate-800/50 rounded-xl border border-slate-700/50 hover:border-blue-500/50 transition-colors block"), cls="grid grid-cols-2 md:grid-cols-4 gap-4 md:gap-6"), cls="max-w-4xl mx-auto px-6"), cls="py-16 md:py-20", id="stats"),
        Section(Div(P("How it works", cls="text-sm font-semibold text-indigo-400 uppercase tracking-wider mb-4 text-center"), H2("Help us piece together our family history", cls="text-2xl md:text-3xl font-bold text-white text-center mb-12"), Div(step_card(browse_icon, "Browse Photos", "Explore our growing collection of family photographs spanning generations and continents -- from Rhodes to New York and beyond."), Div(NotStr(arrow_svg), cls="hidden md:flex items-center justify-center"), step_card(identify_icon, "Help Identify People", "Do you recognize someone? Your knowledge of the family is invaluable. Confirm names, suggest identifications, or note who you remember."), Div(NotStr(arrow_svg), cls="hidden md:flex items-center justify-center"), step_card(connect_icon, "Connect with History", "Each identification connects a face to a story, strengthening our family tree and preserving memories for future generations."), cls="grid grid-cols-1 md:grid-cols-5 gap-8 md:gap-4 items-start"), cls="max-w-5xl mx-auto px-6"), cls="py-16 md:py-20 border-t border-slate-800", id="how-it-works"),
        Section(Div(H2(f"{stats['needs_help']} faces are waiting to be recognized", cls="text-2xl md:text-3xl font-bold text-white mb-4"), P("If you grew up hearing stories about the family, you might be the one who can put a name to a face. Every identification helps.", cls="text-slate-300 mb-8 max-w-xl mx-auto"), Div(primary_cta, A("Help Identify Faces", href="/?section=to_review", cls="inline-block px-8 py-4 border-2 border-blue-500 text-blue-300 text-lg font-semibold rounded-xl hover:border-blue-300 hover:text-white transition-colors"), cls="flex flex-wrap justify-center gap-4"), cls="text-center max-w-3xl mx-auto px-6"), cls="py-16 md:py-20 bg-gradient-to-b from-slate-800/50 to-transparent border-t border-slate-800", id="cta"),
        Section(Div(H2("About this project", cls="text-xl font-bold text-white mb-4"), P("Rhodesli is a community effort to preserve the photographic heritage of the Rhodes-Capeluto family and the broader Sephardic community of Rhodes. These photos, spanning decades of family life across continents, represent irreplaceable memories that connect us to our shared roots.", cls="text-slate-400 leading-relaxed mb-4"), P("Using careful face detection technology, we have begun the work of identifying the people in these photographs. But technology can only do so much -- we need family members who remember these faces and their stories to help complete the picture.", cls="text-slate-400 leading-relaxed"), cls="max-w-3xl mx-auto px-6"), cls="py-16 md:py-20 border-t border-slate-800", id="about"),
        Footer(Div(Div(Span("Rhodesli", cls="text-lg font-bold text-white"), Span(" -- A family heritage project", cls="text-sm text-slate-500"), cls="flex items-baseline gap-1 flex-wrap"), Div(A("Photos", href="/?section=photos", cls="text-xs text-slate-500 hover:text-slate-300"), Span("|", cls="text-slate-700"), A("People", href="/?section=confirmed", cls="text-xs text-slate-500 hover:text-slate-300"), Span("|", cls="text-slate-700"), A("Review Inbox", href="/?section=to_review", cls="text-xs text-slate-500 hover:text-slate-300"), cls="flex items-center gap-2"), cls="max-w-6xl mx-auto px-6 flex flex-col md:flex-row items-center justify-between gap-4"), cls="py-8 border-t border-slate-800"),
        cls="min-h-screen bg-slate-900"),
    )


# =============================================================================
# ROUTES - PHASE 2: TEACH MODE
# =============================================================================

def _compute_landing_stats() -> dict:
    """Compute live stats for the landing page."""
    registry = load_registry()
    _build_caches()
    all_identities = registry.list_identities()
    confirmed = registry.list_identities(state=IdentityState.CONFIRMED)
    inbox = registry.list_identities(state=IdentityState.INBOX)
    proposed = registry.list_identities(state=IdentityState.PROPOSED)
    total_faces = sum(
        len(i.get("anchor_ids", [])) + len(i.get("candidate_ids", []))
        for i in all_identities
    )
    skipped = registry.list_identities(state=IdentityState.SKIPPED)
    needs_help = sum(
        len(i.get("anchor_ids", [])) + len(i.get("candidate_ids", []))
        for i in inbox + proposed + skipped
    )
    # Collect confirmed names for display
    named_people = [
        i["name"] for i in confirmed
        if not i["name"].startswith("Unidentified")
    ]
    # Collect a few unidentified faces for the "Can you help?" teaser
    crop_files = get_crop_files()
    unidentified_faces = []
    unid_identities = [
        i for i in inbox + proposed
        if not i.get("merged_into")
    ]
    random.shuffle(unid_identities)
    for identity in unid_identities[:6]:
        face_ids = identity.get("anchor_ids", []) + identity.get("candidate_ids", [])
        if face_ids:
            url = resolve_face_image_url(face_ids[0], crop_files)
            if url:
                unidentified_faces.append({
                    "identity_id": identity["identity_id"],
                    "crop_url": url,
                })
        if len(unidentified_faces) >= 4:
            break
    # Source collections
    sources = set()
    if _photo_cache:
        for pd in _photo_cache.values():
            src = pd.get("source", "")
            if src:
                sources.add(src)
    return {
        "photo_count": len(_photo_cache) if _photo_cache else 0,
        "named_count": len(confirmed),
        "total_faces": total_faces,
        "needs_help": needs_help,
        "named_people": named_people,
        "unidentified_faces": unidentified_faces,
        "sources": sorted(sources),
    }


def _get_featured_photos(limit: int = 8) -> list:
    """Pick photos that have confirmed/named identities for the landing page hero.

    Returns richer data including face bounding boxes and photo dimensions
    for the interactive hover effect on the landing page.
    """
    registry = load_registry()
    confirmed = registry.list_identities(state=IdentityState.CONFIRMED)
    _build_caches()
    if not _photo_cache:
        return []

    dim_cache = _load_photo_dimensions_cache()

    # Build map of face_id -> identity name
    face_to_name = {}
    confirmed_face_ids = set()
    for identity in confirmed:
        name = identity.get("name", "")
        if name.startswith("Unidentified"):
            name = ""
        for fid in identity.get("anchor_ids", []) + identity.get("candidate_ids", []):
            confirmed_face_ids.add(fid)
            if name:
                face_to_name[fid] = name

    # Prefer landscape photos with many faces and confirmed identities
    scored_photos = []
    for photo_id, photo_data in _photo_cache.items():
        faces = photo_data.get("faces", [])
        num_faces = len(faces)
        confirmed_count = sum(1 for f in faces if f.get("face_id") in confirmed_face_ids)
        filename = photo_data["filename"]
        dims = dim_cache.get(filename) or dim_cache.get(Path(filename).name)
        w, h = dims if dims else (0, 0)
        is_landscape = w > h if w and h else False
        # Skip photos without cached dimensions (can't render face boxes)
        if w == 0 or h == 0:
            continue
        # Score: prefer landscape, more faces, more confirmed
        score = (confirmed_count * 3) + num_faces + (2 if is_landscape else 0)
        if num_faces >= 2:  # Only show photos with multiple people
            scored_photos.append((score, photo_id))

    scored_photos.sort(key=lambda x: x[0], reverse=True)
    featured_photo_ids = [pid for _, pid in scored_photos[:limit]]

    # If not enough, fill with any multi-face photos
    if len(featured_photo_ids) < limit:
        for photo_id in _photo_cache:
            if photo_id not in featured_photo_ids:
                faces = _photo_cache[photo_id].get("faces", [])
                if len(faces) >= 1:
                    featured_photo_ids.append(photo_id)
                    if len(featured_photo_ids) >= limit:
                        break

    results = []
    for pid in featured_photo_ids[:limit]:
        if pid not in _photo_cache:
            continue
        pdata = _photo_cache[pid]
        filename = pdata["filename"]
        dims = dim_cache.get(filename) or dim_cache.get(Path(filename).name)
        w, h = dims if dims else (0, 0)
        faces = pdata.get("faces", [])

        face_boxes = []
        for face in faces:
            fid = face.get("face_id", "")
            bbox = face.get("bbox", [])
            if bbox and w > 0 and h > 0:
                # Convert bbox from pixel coords to percentages
                x1, y1, x2, y2 = bbox
                face_boxes.append({
                    "left": round(x1 / w * 100, 2),
                    "top": round(y1 / h * 100, 2),
                    "width": round((x2 - x1) / w * 100, 2),
                    "height": round((y2 - y1) / h * 100, 2),
                    "name": face_to_name.get(fid, ""),
                })

        results.append({
            "id": pid,
            "url": photo_url(filename),
            "width": w,
            "height": h,
            "face_count": len(face_boxes),
            "face_boxes": face_boxes,
        })
    return results


def landing_page(stats, featured_photos):
    """Render the public landing page for the Rhodesli heritage archive.

    This page is only shown to anonymous visitors. Logged-in users are
    redirected to the dashboard by the GET / route handler.
    """
    auth_enabled = is_auth_enabled()

    # Build hero photo cards with face detection overlay data
    hero_cards = []
    for i, p in enumerate(featured_photos[:6]):
        # Build face detection overlay boxes (shown on hover)
        face_overlays = []
        for box in p.get("face_boxes", []):
            name = box.get("name", "")
            face_overlays.append(
                Div(
                    Span(name, cls="face-label") if name else None,
                    cls="face-box",
                    style=f"left:{box['left']}%;top:{box['top']}%;width:{box['width']}%;height:{box['height']}%;"
                )
            )
        # Determine grid span for visual variety
        span_cls = ""
        if i == 0:
            span_cls = "md:col-span-2 md:row-span-2"

        hero_cards.append(
            Div(
                Img(
                    src=p["url"],
                    alt="Archival photograph from the Jewish community of Rhodes",
                    loading="eager" if i < 2 else "lazy",
                    cls="w-full h-full object-cover transition-transform duration-700 group-hover:scale-105",
                    onerror="this.closest('.hero-card').style.display='none'"
                ),
                # Face detection overlay
                Div(
                    *face_overlays,
                    cls="face-overlay"
                ) if face_overlays else None,
                # Face count badge
                Div(
                    Span(f"{p['face_count']} faces detected", cls="text-xs"),
                    cls="absolute bottom-2 right-2 bg-black/70 text-amber-200 px-2 py-1 rounded opacity-0 group-hover:opacity-100 transition-opacity duration-300"
                ) if p.get("face_count", 0) > 0 else None,
                cls=f"hero-card group relative overflow-hidden {span_cls}",
            )
        )

    # "Can you help?" mystery faces
    mystery_faces = []
    for face in stats.get("unidentified_faces", []):
        mystery_faces.append(
            A(
                Img(
                    src=face["crop_url"],
                    alt="Unidentified person from the Rhodes archive",
                    loading="lazy",
                    cls="w-full h-full object-cover rounded-full border-2 border-amber-400/50 hover:border-amber-300 transition-all duration-300 hover:scale-110"
                ),
                href=f"/?section=to_review&current={face['identity_id']}",
                cls="block w-20 h-20 md:w-24 md:h-24 rounded-full overflow-hidden flex-shrink-0"
            )
        )

    # Navigation bar
    _nav_cls = "text-slate-300 hover:text-amber-200 transition-colors text-sm md:text-base"
    nav_items = [
        A("Photos", href="/photos", cls=_nav_cls),
        A("People", href="/people", cls=_nav_cls),
        A("Collections", href="/collections", cls=_nav_cls),
        A("Map", href="/map", cls=_nav_cls),
        A("Timeline", href="/timeline", cls=_nav_cls),
        A("Tree", href="/tree", cls=_nav_cls),
        A("Compare", href="/compare", cls=_nav_cls),
        A("About", href="/about", cls=_nav_cls),
    ]
    if auth_enabled:
        nav_items.append(
            A("Sign In", href="/login", cls="text-amber-300 hover:text-amber-200 font-medium transition-colors text-sm md:text-base")
        )

    # Named people for the ticker / display
    named_people = stats.get("named_people", [])

    landing_style = Style("""
        /* ============ LANDING PAGE STYLES ============ */
        html, body { height: 100%; margin: 0; }
        body { background-color: #1a1511; }

        /* Warm sepia/archival color palette */
        .landing-bg { background: linear-gradient(180deg, #1a1511 0%, #1e1a15 40%, #1a1511 100%); }

        /* Hero mosaic grid */
        .hero-mosaic {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 200px);
            gap: 3px;
        }
        @media (max-width: 767px) {
            .hero-mosaic {
                grid-template-columns: repeat(2, 1fr);
                grid-template-rows: repeat(3, 160px);
            }
            .hero-mosaic .md\\:col-span-2 { grid-column: span 2; }
            .hero-mosaic .md\\:row-span-2 { grid-row: span 1; }
        }
        @media (min-width: 768px) {
            .hero-mosaic {
                grid-template-rows: repeat(2, 220px);
            }
        }
        @media (min-width: 1024px) {
            .hero-mosaic {
                grid-template-rows: repeat(2, 260px);
            }
        }

        .hero-card {
            position: relative;
            overflow: hidden;
            background: #2a241e;
        }
        .hero-card::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(to bottom, transparent 60%, rgba(26, 21, 17, 0.6) 100%);
            pointer-events: none;
        }

        /* Face detection overlay */
        .face-overlay {
            position: absolute;
            inset: 0;
            opacity: 0;
            transition: opacity 0.4s ease;
            z-index: 5;
        }
        .hero-card:hover .face-overlay {
            opacity: 1;
        }
        .face-box {
            position: absolute;
            border: 2px solid rgba(251, 191, 36, 0.8);
            border-radius: 3px;
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.3);
        }
        .face-label {
            position: absolute;
            bottom: -22px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            font-size: 11px;
            color: #fbbf24;
            background: rgba(0, 0, 0, 0.8);
            padding: 1px 6px;
            border-radius: 3px;
        }

        /* Sepia film border on hero */
        .hero-frame {
            border: 3px solid #3d3428;
            border-radius: 4px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5), inset 0 0 40px rgba(0, 0, 0, 0.2);
            position: relative;
        }
        .hero-frame::before {
            content: '';
            position: absolute;
            inset: -1px;
            border: 1px solid rgba(251, 191, 36, 0.1);
            border-radius: 5px;
            pointer-events: none;
            z-index: 10;
        }

        /* Stat counter animation */
        .stat-number {
            font-size: 2.5rem;
            font-weight: 700;
            color: #f5e6d3;
            line-height: 1;
            font-variant-numeric: tabular-nums;
        }
        .stat-label {
            font-size: 0.8rem;
            color: #a09080;
            margin-top: 0.5rem;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }
        .stat-card {
            text-align: center;
            padding: 1.5rem 1rem;
            background: rgba(61, 52, 40, 0.3);
            border: 1px solid rgba(61, 52, 40, 0.5);
            border-radius: 8px;
            transition: transform 0.2s, border-color 0.2s;
        }
        .stat-card:hover {
            transform: translateY(-2px);
            border-color: rgba(251, 191, 36, 0.3);
        }

        /* Name ticker / scroll */
        .names-scroll {
            display: flex;
            gap: 2rem;
            animation: scroll-names 30s linear infinite;
            width: max-content;
        }
        @keyframes scroll-names {
            from { transform: translateX(0); }
            to { transform: translateX(-50%); }
        }
        .names-track {
            overflow: hidden;
            mask-image: linear-gradient(to right, transparent 0%, black 10%, black 90%, transparent 100%);
            -webkit-mask-image: linear-gradient(to right, transparent 0%, black 10%, black 90%, transparent 100%);
        }

        /* Animations */
        @keyframes fade-in-up {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in-up { animation: fade-in-up 0.8s ease-out both; }
        .delay-1 { animation-delay: 0.15s; }
        .delay-2 { animation-delay: 0.3s; }
        .delay-3 { animation-delay: 0.45s; }
        .delay-4 { animation-delay: 0.6s; }

        @keyframes gentle-pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        .animate-gentle-pulse { animation: gentle-pulse 3s ease-in-out infinite; }

        /* CTA buttons */
        .btn-primary {
            display: inline-block;
            padding: 0.875rem 2rem;
            background: linear-gradient(135deg, #b45309 0%, #d97706 100%);
            color: #fff;
            font-weight: 600;
            border-radius: 8px;
            transition: all 0.3s;
            text-decoration: none;
            font-size: 1rem;
            box-shadow: 0 2px 10px rgba(180, 83, 9, 0.3);
        }
        .btn-primary:hover {
            background: linear-gradient(135deg, #d97706 0%, #f59e0b 100%);
            box-shadow: 0 4px 20px rgba(180, 83, 9, 0.4);
            transform: translateY(-1px);
        }
        .btn-secondary {
            display: inline-block;
            padding: 0.875rem 2rem;
            border: 1px solid #5d4e3c;
            color: #d4c4a8;
            font-weight: 600;
            border-radius: 8px;
            transition: all 0.3s;
            text-decoration: none;
            font-size: 1rem;
        }
        .btn-secondary:hover {
            border-color: #a08c6e;
            background: rgba(61, 52, 40, 0.4);
            color: #f5e6d3;
        }

        /* About section separator */
        .ornament {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin: 0 auto;
            max-width: 200px;
        }
        .ornament::before, .ornament::after {
            content: '';
            flex: 1;
            height: 1px;
            background: linear-gradient(to right, transparent, #5d4e3c, transparent);
        }

        /* Mystery face glow */
        .mystery-face-ring {
            position: relative;
        }
        .mystery-face-ring::before {
            content: '';
            position: absolute;
            inset: -3px;
            border-radius: 50%;
            background: conic-gradient(from 0deg, #fbbf24, #b45309, #fbbf24);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: -1;
        }
        .mystery-face-ring:hover::before {
            opacity: 0.6;
            animation: gentle-pulse 2s ease-in-out infinite;
        }

        /* Responsive adjustments */
        @media (max-width: 640px) {
            .stat-number { font-size: 1.75rem; }
            .stat-card { padding: 1rem 0.5rem; }
        }

        /* ============================================================
           MOBILE RESPONSIVE STYLES
           ============================================================ */
        @media (max-width: 767px) {
            .main-content {
                margin-left: 0 !important;
                padding-top: 56px;
            }
            .main-content .main-inner {
                padding-left: 1rem;
                padding-right: 1rem;
                padding-top: 1rem;
            }
            .focus-card-layout {
                flex-direction: column !important;
                gap: 1rem !important;
            }
            .focus-card-layout .focus-thumbnail {
                width: 100% !important;
            }
            .focus-card-layout .focus-thumbnail > div {
                width: 100% !important;
                height: auto !important;
                aspect-ratio: 1 / 1;
                max-width: 200px;
                margin: 0 auto;
            }
            .focus-actions {
                flex-wrap: wrap !important;
            }
            .focus-actions button {
                flex: 1 1 auto;
                min-width: 80px;
            }
            .section-header {
                flex-direction: column !important;
                align-items: flex-start !important;
                gap: 0.75rem;
            }
            .filter-bar {
                flex-direction: column !important;
                align-items: stretch !important;
                gap: 0.5rem !important;
            }
            .filter-bar .ml-auto {
                margin-left: 0;
            }
            .identity-card-header {
                flex-direction: column !important;
                align-items: flex-start !important;
                gap: 0.5rem;
            }
            .neighbors-sidebar .flex.items-center {
                flex-wrap: wrap;
            }
            #toast-container {
                left: 1rem;
                right: 1rem;
                max-width: none;
            }
        }
        @media (min-width: 768px) and (max-width: 1023px) {
            .main-content {
                margin-left: 0 !important;
                padding-top: 56px;
            }
            .main-content .main-inner {
                padding-left: 2rem;
                padding-right: 2rem;
            }
        }
        @media (max-width: 1023px) {
            .mobile-header {
                display: flex !important;
            }
        }
        @media (min-width: 1024px) {
            .mobile-header {
                display: none !important;
            }
            .main-content {
                margin-left: 16rem;
            }
        }
    """)

    landing_script = Script("""
        // Animated counter for stats
        document.addEventListener('DOMContentLoaded', function() {
            var counters = document.querySelectorAll('[data-count]');
            var observer = new IntersectionObserver(function(entries) {
                entries.forEach(function(entry) {
                    if (entry.isIntersecting) {
                        var el = entry.target;
                        var target = parseInt(el.getAttribute('data-count'));
                        var duration = 1500;
                        var start = 0;
                        var startTime = null;
                        function step(timestamp) {
                            if (!startTime) startTime = timestamp;
                            var progress = Math.min((timestamp - startTime) / duration, 1);
                            // Ease out cubic
                            var eased = 1 - Math.pow(1 - progress, 3);
                            el.textContent = Math.floor(eased * target).toLocaleString();
                            if (progress < 1) {
                                requestAnimationFrame(step);
                            } else {
                                el.textContent = target.toLocaleString();
                            }
                        }
                        requestAnimationFrame(step);
                        observer.unobserve(el);
                    }
                });
            }, {threshold: 0.3});
            counters.forEach(function(c) { observer.observe(c); });
        });
    """)

    # Duplicate names list for seamless scroll effect
    names_display = named_people + named_people if named_people else []

    # OG meta tags for social sharing
    _og_hero_url = f"{SITE_URL}/static/crops/landing-hero.jpg"
    if featured_photos:
        _hero_url = featured_photos[0].get("url", "")
        _og_hero_url = _hero_url if _hero_url.startswith("http") else f"{SITE_URL}{_hero_url}"
    _og_desc = f"A living archive of {stats['photo_count']} photographs and {stats['named_count']} identified people from the Jewish community of Rhodes. Help us preserve our shared heritage."

    return (
        Title("Rhodesli -- Jewish Community of Rhodes Photo Archive"),
        Meta(property="og:title", content="Rhodesli -- Jewish Community of Rhodes Photo Archive"),
        Meta(property="og:description", content=_og_desc),
        Meta(property="og:image", content=_og_hero_url),
        Meta(property="og:url", content=SITE_URL),
        Meta(property="og:type", content="website"),
        Meta(property="og:site_name", content="Rhodesli -- Heritage Photo Archive"),
        Meta(name="twitter:card", content="summary_large_image"),
        Meta(name="twitter:title", content="Rhodesli -- Jewish Community of Rhodes Photo Archive"),
        Meta(name="twitter:description", content=_og_desc),
        Meta(name="twitter:image", content=_og_hero_url),
        Meta(name="description", content=_og_desc),
        landing_style,
        landing_script,
    Div(
        # Navigation
        Nav(
            Div(
                Div(
                    Span("Rhodesli", cls="text-xl md:text-2xl font-bold text-amber-100 tracking-wide"),
                    Span("Photo Archive", cls="text-xs text-amber-400/60 ml-2 hidden md:inline tracking-widest uppercase"),
                    cls="flex items-baseline"
                ),
                Div(*nav_items, cls="hidden sm:flex items-center gap-4 md:gap-6"),
                cls="max-w-6xl mx-auto px-4 md:px-6 py-4 flex items-center justify-between flex-wrap gap-3"
            ),
            cls="border-b border-amber-900/30 bg-black/20 backdrop-blur-sm sticky top-0 z-50"
        ),

        # Hero section
        Section(
            Div(
                # Headline area
                Div(
                    Div(
                        Div(cls="ornament mb-6"),
                        H1(
                            Span("Preserving the faces and stories", cls="block"),
                            Span("of the Jewish Community of Rhodes", cls="block text-amber-200"),
                            cls="text-3xl md:text-5xl lg:text-6xl font-bold text-amber-50 leading-tight tracking-tight"
                        ),
                        P("A digital archive using face recognition to reconnect generations of a Ladino-speaking "
                          "Sephardic community scattered by history. Browse photographs, identify faces, and help "
                          "preserve a living record.",
                          cls="text-base md:text-lg text-amber-100/60 mt-6 max-w-2xl mx-auto leading-relaxed"),
                        # CTA buttons
                        Div(
                            A("Start Exploring", href="/?section=photos", cls="btn-primary"),
                            A("Help Identify", href="/?section=skipped", cls="btn-secondary"),
                            cls="mt-8 flex flex-wrap gap-4 justify-center"
                        ),
                        cls="text-center animate-fade-in-up"
                    ),
                    cls="py-10 md:py-16 px-4 md:px-6"
                ),

                # Photo mosaic with face detection hover
                Div(
                    Div(
                        *hero_cards,
                        cls="hero-mosaic"
                    ),
                    # Instruction hint
                    P("Hover over photos to reveal face detection",
                      cls="text-center text-amber-400/40 text-xs mt-3 tracking-wide uppercase animate-gentle-pulse"),
                    cls="hero-frame animate-fade-in-up delay-1"
                ) if hero_cards else None,

                cls="max-w-5xl mx-auto"
            ),
            id="hero", cls="pt-4 pb-8 md:pb-12"
        ),

        # Names ticker -- confirmed identities scrolling
        Section(
            Div(
                P("Identified so far", cls="text-center text-amber-400/50 text-xs tracking-widest uppercase mb-3"),
                Div(
                    Div(
                        *[Span(name, cls="text-amber-200/70 whitespace-nowrap text-sm md:text-base") for name in names_display],
                        cls="names-scroll"
                    ),
                    cls="names-track"
                ),
                cls="max-w-5xl mx-auto"
            ),
            cls="py-6 px-4 border-y border-amber-900/20"
        ) if named_people else None,

        # Progress dashboard (FE-053) — prominent identification progress
        Section(
            Div(
                # Progress headline
                Div(
                    H2(
                        Span(str(stats["named_count"]), cls="text-amber-200"),
                        " of ",
                        Span(str(stats["total_faces"]), cls="text-amber-100/80"),
                        " faces identified",
                        cls="text-xl md:text-2xl font-bold text-amber-50 text-center"
                    ),
                    P("Help us name the rest \u2014 every identification preserves irreplaceable history.",
                      cls="text-amber-100/40 text-center text-sm mt-2"),
                    cls="mb-6"
                ),
                # Progress bar
                Div(
                    Div(
                        cls="h-full bg-gradient-to-r from-amber-600 to-amber-400 rounded-full transition-all duration-1000",
                        style=f"width: {min(100, int(stats['named_count'] / max(1, stats['total_faces']) * 100))}%",
                    ),
                    cls="w-full max-w-lg mx-auto h-3 bg-amber-900/30 rounded-full overflow-hidden border border-amber-900/40"
                ),
                Div(
                    Span(f"{min(100, int(stats['named_count'] / max(1, stats['total_faces']) * 100))}% complete",
                         cls="text-amber-400/60 text-xs"),
                    cls="text-center mt-2"
                ),
                cls="max-w-4xl mx-auto animate-fade-in-up"
            ),
            cls="py-8 md:py-10 px-4 md:px-6"
        ),

        # Stats section
        Section(
            Div(
                Div(
                    Div(
                        Div("0", cls="stat-number", **{"data-count": str(stats["photo_count"])}),
                        Div("archival photos", cls="stat-label"),
                        cls="stat-card animate-fade-in-up"
                    ),
                    Div(
                        Div("0", cls="stat-number", **{"data-count": str(stats["named_count"])}),
                        Div("people identified", cls="stat-label"),
                        cls="stat-card animate-fade-in-up delay-1"
                    ),
                    Div(
                        Div("0", cls="stat-number", **{"data-count": str(stats["total_faces"])}),
                        Div("faces detected by AI", cls="stat-label"),
                        cls="stat-card animate-fade-in-up delay-2"
                    ),
                    Div(
                        Div("0", cls="stat-number", **{"data-count": str(stats["needs_help"])}),
                        Div("awaiting identification", cls="stat-label"),
                        cls="stat-card animate-fade-in-up delay-3"
                    ),
                    cls="grid grid-cols-2 md:grid-cols-4 gap-3 md:gap-4"
                ),
                cls="max-w-4xl mx-auto"
            ),
            id="stats", cls="py-12 md:py-16 px-4 md:px-6"
        ),

        # "Can you help?" mystery faces section
        Section(
            Div(
                Div(
                    H2("Can you identify these faces?",
                       cls="text-2xl md:text-3xl font-bold text-amber-50 text-center mb-3"),
                    P("Our AI has detected these faces across the archive, but we do not know who they are. "
                      "If you recognize anyone, your knowledge is priceless.",
                      cls="text-amber-100/50 text-center max-w-xl mx-auto text-sm md:text-base"),
                    cls="mb-8"
                ),
                # Mystery face circles
                Div(
                    *[Div(face, cls="mystery-face-ring") for face in mystery_faces],
                    cls="flex justify-center gap-5 md:gap-8 flex-wrap"
                ) if mystery_faces else None,
                Div(
                    A("Help Identify People", href="/?section=skipped",
                      cls="btn-primary mt-8 inline-block"),
                    cls="text-center"
                ),
                cls="max-w-3xl mx-auto"
            ),
            id="identify", cls="py-12 md:py-16 px-4 md:px-6 bg-gradient-to-b from-transparent via-amber-900/10 to-transparent"
        ) if mystery_faces else None,

        # How it works
        Section(
            Div(
                Div(cls="ornament mb-8"),
                H2("How It Works", cls="text-2xl md:text-3xl font-bold text-amber-50 text-center mb-10"),
                Div(
                    Div(
                        Div(
                            Span("01", cls="text-3xl font-bold text-amber-500/30"),
                            cls="mb-3"
                        ),
                        H3("Scan & Detect", cls="text-lg font-semibold text-amber-100 mb-2"),
                        P("Advanced face detection AI scans archival photographs, finding and isolating every face "
                          "across decades of family photos.",
                          cls="text-amber-100/50 text-sm leading-relaxed"),
                        cls="p-6 bg-amber-900/10 rounded-lg border border-amber-900/20 hover:border-amber-700/30 transition-colors"
                    ),
                    Div(
                        Div(
                            Span("02", cls="text-3xl font-bold text-amber-500/30"),
                            cls="mb-3"
                        ),
                        H3("Match & Group", cls="text-lg font-semibold text-amber-100 mb-2"),
                        P("Facial embeddings connect the same person across different photos, even spanning decades. "
                          "The system proposes identity clusters for human review.",
                          cls="text-amber-100/50 text-sm leading-relaxed"),
                        cls="p-6 bg-amber-900/10 rounded-lg border border-amber-900/20 hover:border-amber-700/30 transition-colors"
                    ),
                    Div(
                        Div(
                            Span("03", cls="text-3xl font-bold text-amber-500/30"),
                            cls="mb-3"
                        ),
                        H3("Name & Preserve", cls="text-lg font-semibold text-amber-100 mb-2"),
                        P("Community members who recognize a face can name them, adding irreplaceable human knowledge. "
                          "Every identification is preserved for future generations.",
                          cls="text-amber-100/50 text-sm leading-relaxed"),
                        cls="p-6 bg-amber-900/10 rounded-lg border border-amber-900/20 hover:border-amber-700/30 transition-colors"
                    ),
                    cls="grid grid-cols-1 md:grid-cols-3 gap-4 md:gap-6"
                ),
                cls="max-w-5xl mx-auto"
            ),
            id="how-it-works", cls="py-12 md:py-16 px-4 md:px-6"
        ),

        # About section
        Section(
            Div(
                Div(cls="ornament mb-8"),
                H2("About This Archive", cls="text-2xl md:text-3xl font-bold text-amber-50 text-center mb-6"),
                Div(
                    P("For over two thousand years, a Jewish community flourished on the island of Rhodes, "
                      "at the crossroads of the Aegean. After the expulsion from Spain in 1492, Sephardic families "
                      "settled in the walled quarter known as ",
                      Em("La Juderia"),
                      ", bringing with them the Ladino language, rabbinical traditions, and a vibrant culture of "
                      "merchants, craftsmen, and scholars. By the late 19th century, the community numbered several "
                      "thousand. Six synagogues stood in La Juderia, and the narrow arched streets rang with "
                      "Judeo-Spanish songs and the bustle of the ",
                      Em("cortijos"),
                      ", the shared courtyards where families gathered.",
                      cls="text-amber-100/60 leading-relaxed mb-4"),
                    P("Beginning in the early 20th century, Rhodesli Jews emigrated in waves \u2014 first to nearby "
                      "communities, then further abroad as the Italian occupation of 1912 and later the racial laws "
                      "of 1938 uprooted families. Chain migration carried them to specific cities worldwide: Seattle "
                      "and Los Angeles, Montgomery, Atlanta, and New York, Buenos Aires and S\u00e3o Paulo, "
                      "communities in Africa, the Middle East, and beyond. The Holocaust of July 1944 devastated "
                      "those who remained \u2014 of the 1,673 Jews deported from Rhodes and Kos to Auschwitz, "
                      "only 151 survived.",
                      cls="text-amber-100/60 leading-relaxed mb-4"),
                    P("Rhodesli is a digital preservation project that uses machine learning to reconnect faces "
                      "and stories scattered across family collections worldwide. The photographs come from "
                      "descendants around the world. Every identification you make \u2014 every name you recognize, "
                      "every story you share \u2014 helps preserve this heritage.",
                      cls="text-amber-100/60 leading-relaxed mb-4"),
                    A("Read more about the project \u2192", href="/about",
                      cls="text-amber-300/70 hover:text-amber-200 text-sm inline-block"),
                    cls="max-w-2xl mx-auto text-center"
                ),
                cls="max-w-5xl mx-auto"
            ),
            id="about", cls="py-12 md:py-16 px-4 md:px-6 bg-gradient-to-b from-transparent via-amber-950/20 to-transparent"
        ),

        # Bottom CTA
        Section(
            Div(
                H2("Every name matters",
                   cls="text-2xl md:text-3xl font-bold text-amber-50 text-center mb-3"),
                P(f"{stats['needs_help']} faces are awaiting identification. Your family knowledge can bring them home.",
                  cls="text-amber-100/50 text-center mb-8 max-w-lg mx-auto"),
                Div(
                    A("Start Exploring", href="/?section=photos", cls="btn-primary"),
                    A("Browse People", href="/?section=confirmed", cls="btn-secondary"),
                    cls="flex flex-wrap gap-4 justify-center"
                ),
                cls="max-w-3xl mx-auto text-center"
            ),
            id="cta", cls="py-12 md:py-16 px-4 md:px-6"
        ),

        # Footer
        Footer(
            Div(
                Div(cls="ornament mb-4"),
                P("Rhodesli",
                  cls="text-amber-200/40 text-sm text-center font-semibold tracking-wide"),
                P("Preserving the photographic heritage of the Jewish Community of Rhodes",
                  cls="text-amber-100/25 text-xs text-center mt-1"),
                P(A("About Rhodesli", href="/about", cls="text-amber-200/40 hover:text-amber-200 underline"),
                  " · Built with care. No generative AI -- only forensic face matching.",
                  cls="text-amber-100/20 text-xs text-center mt-3"),
                cls="max-w-6xl mx-auto px-6 py-8"
            ),
            cls="border-t border-amber-900/20"
        ),
        cls="min-h-screen landing-bg"
    ),
    )


@rt("/about")
def get():
    """About page: history, how to help, how it works, roles, dynamic stats."""
    stats = _compute_landing_stats()

    return (
        Title("About Rhodesli"),
        Style("""
            .about-bg { background: linear-gradient(180deg, #1a1511 0%, #1e1a15 40%, #1a1511 100%); }
            .about-section { max-width: 48rem; margin: 0 auto; }
            .faq-q { cursor: pointer; }
            .faq-q:hover { color: #fbbf24; }
        """),
        Main(
            # Back nav
            Div(
                A("\u2190 Back to Archive", href="/", cls="text-amber-300/70 hover:text-amber-200 text-sm"),
                cls="max-w-3xl mx-auto px-6 pt-8"
            ),
            # Title
            Div(
                H1("About Rhodesli", cls="text-3xl font-serif font-bold text-amber-100 mb-2"),
                Div(cls="w-16 h-0.5 bg-amber-400/40 mb-6"),
                cls="max-w-3xl mx-auto px-6 pt-4"
            ),
            # The Community
            Div(
                H2("The Community", cls="text-xl font-serif font-semibold text-amber-200 mb-4"),
                P(
                    "For over two thousand years, a Jewish community flourished on the island of Rhodes, "
                    "at the crossroads of the Aegean. After the expulsion from Spain in 1492, Sephardic families "
                    "settled in the walled quarter known as ",
                    Em("La Juderia"),
                    ", bringing with them the Ladino language, rabbinical traditions, and a vibrant culture of "
                    "merchants, craftsmen, and scholars. By the late 19th century, the community numbered several "
                    "thousand \u2014 the second largest religious group on the island. Six synagogues stood in "
                    "La Juderia, and the narrow arched streets rang with Judeo-Spanish songs and the bustle "
                    "of the ",
                    Em("cortijos"),
                    ", the shared courtyards where families gathered.",
                    cls="text-slate-300 leading-relaxed mb-4"
                ),
                cls="about-section px-6 mb-10"
            ),
            # The Diaspora
            Div(
                H2("The Diaspora", cls="text-xl font-serif font-semibold text-amber-200 mb-4"),
                P(
                    "Beginning in the early 20th century, Rhodesli Jews emigrated in waves \u2014 first to the "
                    "nearby communities of Kos, Milas, and Bodrum, then further abroad as the Italian occupation "
                    "of 1912 and later the racial laws of 1938 uprooted families. Chain migration carried them "
                    "to specific cities worldwide: Seattle and Los Angeles on the American West Coast; Montgomery, "
                    "Atlanta, and New York in the East; Buenos Aires and S\u00e3o Paulo in South America; "
                    "Elizabethville and Salisbury in Central and Southern Africa; Alexandria and Cairo; and "
                    "communities in Havana, Asheville, Israel, Brussels, and Miami.",
                    cls="text-slate-300 leading-relaxed mb-4"
                ),
                P(
                    "The Holocaust of July 1944 devastated those who remained \u2014 of the 1,673 Jews deported "
                    "from Rhodes and Kos to Auschwitz, only 151 survived.",
                    cls="text-slate-300 leading-relaxed"
                ),
                cls="about-section px-6 mb-10"
            ),
            # The Project
            Div(
                H2("The Project", cls="text-xl font-serif font-semibold text-amber-200 mb-4"),
                P(
                    "Rhodesli is a digital preservation project that uses machine learning to reconnect faces "
                    "and stories scattered across family collections worldwide. By combining AI face detection "
                    "with the living memory of community descendants, we are building a searchable archive that "
                    "bridges generations. Every identification you make \u2014 every name you recognize, every "
                    "story you share \u2014 helps preserve this heritage.",
                    cls="text-slate-300 leading-relaxed mb-4"
                ),
                P(
                    f"The archive currently contains {stats['photo_count']} photographs with "
                    f"{stats['total_faces']} faces detected by AI. {stats['named_count']} people have "
                    f"been positively identified so far, with {stats['needs_help']} faces still awaiting "
                    f"identification.",
                    cls="text-slate-400 leading-relaxed italic"
                ),
                cls="about-section px-6 mb-10"
            ),
            # How to Help
            Div(
                H2("How to Help", cls="text-xl font-serif font-semibold text-amber-200 mb-4"),
                Div(
                    Div(
                        Span("1", cls="text-amber-400 font-bold text-lg mr-3"),
                        Div(
                            Span("Browse and identify", cls="text-slate-200 font-medium"),
                            P("Look through the photo archive. If you recognize a face, suggest a name. "
                              "Your family knowledge is irreplaceable.",
                              cls="text-slate-400 text-sm mt-1"),
                        ),
                        cls="flex items-start mb-4"
                    ),
                    Div(
                        Span("2", cls="text-amber-400 font-bold text-lg mr-3"),
                        Div(
                            Span("Suggest names", cls="text-slate-200 font-medium"),
                            P("Use the 'Suggest Name' button on any unidentified face. Even partial "
                              "information helps \u2014 a last name, a family branch, or a generation.",
                              cls="text-slate-400 text-sm mt-1"),
                        ),
                        cls="flex items-start mb-4"
                    ),
                    Div(
                        Span("3", cls="text-amber-400 font-bold text-lg mr-3"),
                        Div(
                            Span("Upload family photos", cls="text-slate-200 font-medium"),
                            P("If you have photographs from the Rhodesli community, upload them to grow "
                              "the archive. All uploads are reviewed before being added.",
                              cls="text-slate-400 text-sm mt-1"),
                        ),
                        cls="flex items-start mb-4"
                    ),
                    Div(
                        Span("4", cls="text-amber-400 font-bold text-lg mr-3"),
                        Div(
                            Span("Add context", cls="text-slate-200 font-medium"),
                            P("Add dates, locations, occasions, and stories to photographs and identities. "
                              "Context turns a photograph into a piece of history.",
                              cls="text-slate-400 text-sm mt-1"),
                        ),
                        cls="flex items-start mb-4"
                    ),
                ),
                cls="about-section px-6 mb-10"
            ),
            # How It Works
            Div(
                H2("How It Works", cls="text-xl font-serif font-semibold text-amber-200 mb-4"),
                Div(
                    Div(
                        Span("Detect", cls="text-amber-400 font-semibold"),
                        P(" \u2014 AI scans uploaded photographs and detects every face, creating a "
                          "mathematical fingerprint for each one.",
                          cls="text-slate-400 text-sm inline"),
                        cls="mb-3"
                    ),
                    Div(
                        Span("Group", cls="text-amber-400 font-semibold"),
                        P(" \u2014 The system compares fingerprints across all photos and proposes "
                          "clusters: faces that likely belong to the same person.",
                          cls="text-slate-400 text-sm inline"),
                        cls="mb-3"
                    ),
                    Div(
                        Span("Verify", cls="text-amber-400 font-semibold"),
                        P(" \u2014 Community members review these proposals. Confirmations strengthen "
                          "the system. Corrections help it learn. Nothing is permanent \u2014 every "
                          "decision can be undone.",
                          cls="text-slate-400 text-sm inline"),
                        cls="mb-3"
                    ),
                ),
                cls="about-section px-6 mb-10"
            ),
            # Roles
            Div(
                H2("Roles", cls="text-xl font-serif font-semibold text-amber-200 mb-4"),
                Div(
                    Div(
                        Span("Visitors", cls="text-slate-200 font-medium"),
                        P(" can browse the entire archive freely without an account \u2014 every photograph, "
                          "every identified person, every face detection.",
                          cls="text-slate-400 text-sm inline"),
                        cls="mb-3"
                    ),
                    Div(
                        Span("Contributors", cls="text-slate-200 font-medium"),
                        P(" can suggest names, upload photos, and add annotations. All suggestions "
                          "are reviewed by an admin before being applied.",
                          cls="text-slate-400 text-sm inline"),
                        cls="mb-3"
                    ),
                    Div(
                        Span("Admins", cls="text-slate-200 font-medium"),
                        P(" review community suggestions, confirm identities, merge duplicates, "
                          "and manage the archive.",
                          cls="text-slate-400 text-sm inline"),
                        cls="mb-3"
                    ),
                ),
                cls="about-section px-6 mb-10"
            ),
            # FAQ
            Div(
                H2("Frequently Asked Questions", cls="text-xl font-serif font-semibold text-amber-200 mb-4"),
                Div(
                    Div(
                        H3("Is this generative AI?", cls="text-slate-200 font-medium faq-q mb-1"),
                        P("No. Rhodesli uses forensic face matching only \u2014 it compares mathematical "
                          "fingerprints of real faces. It never generates, invents, or fabricates anything.",
                          cls="text-slate-400 text-sm mb-4"),
                    ),
                    Div(
                        H3("Can I undo mistakes?", cls="text-slate-200 font-medium faq-q mb-1"),
                        P("Yes. Confirmations, rejections, and merges can all be undone. The system keeps "
                          "full history. No data is ever permanently deleted.",
                          cls="text-slate-400 text-sm mb-4"),
                    ),
                    Div(
                        H3("Do I need an account to browse?", cls="text-slate-200 font-medium faq-q mb-1"),
                        P("No. The entire archive is publicly browsable. An account is only needed to "
                          "submit suggestions, upload photos, or add annotations.",
                          cls="text-slate-400 text-sm mb-4"),
                    ),
                    Div(
                        H3("How can I contribute photos?", cls="text-slate-200 font-medium faq-q mb-1"),
                        P("Sign up with an invite code, then use the Upload page to add photographs. "
                          "All uploads are reviewed before being added to the archive.",
                          cls="text-slate-400 text-sm mb-4"),
                    ),
                ),
                cls="about-section px-6 mb-10"
            ),
            # Footer
            Div(
                P("Built with care. No generative AI \u2014 only forensic face matching.",
                  cls="text-amber-100/30 text-xs text-center"),
                A("\u2190 Back to Archive", href="/",
                  cls="text-amber-300/60 hover:text-amber-200 text-sm block text-center mt-3"),
                cls="about-section px-6 py-8 border-t border-amber-900/20"
            ),
            cls="min-h-screen about-bg"
        ),
    )


def _personalized_discovery_banner(interest_surnames: list[str], confirmed_list: list,
                                    crop_files: set, counts: dict) -> Div:
    """Render a personalized discovery banner showing people matching user's interest surnames.

    Shown at top of Needs Help section when user selected surnames during onboarding.
    """
    from core.registry import _load_surname_variants
    variant_lookup = _load_surname_variants()

    # Expand surnames to include variants
    target_names = set()
    for surname in interest_surnames:
        target_names.add(surname.lower())
        variants = variant_lookup.get(surname.lower(), [])
        target_names.update(variants)

    # Find matching confirmed identities
    matches = []
    for identity in confirmed_list:
        name = (identity.get("name") or "").strip()
        if not name or name.startswith("Unidentified"):
            continue
        name_words = [w.lower() for w in name.split()]
        if any(w in target_names for w in name_words):
            face_ids = identity.get("anchor_ids", []) + identity.get("candidate_ids", [])
            crop_url = resolve_face_image_url(face_ids[0], crop_files) if face_ids else None
            if crop_url:
                matches.append({
                    "name": name,
                    "crop_url": crop_url,
                    "identity_id": identity["identity_id"],
                })

    if not matches:
        return Div()  # Empty — no banner

    # Show up to 5 matching people as a horizontal strip
    people_thumbs = []
    for m in matches[:5]:
        people_thumbs.append(
            A(
                Div(
                    Img(src=m["crop_url"], alt=m["name"],
                        cls="w-12 h-12 rounded-full object-cover border-2 border-amber-400/50"),
                    Span(m["name"].split()[0], cls="text-xs text-slate-400 mt-1 truncate w-14 text-center"),
                    cls="flex flex-col items-center",
                ),
                href=f"/?section=confirmed&current={m['identity_id']}",
                cls="hover:opacity-80 transition-opacity",
            )
        )

    surnames_display = " & ".join(interest_surnames[:3])
    more = f" +{len(interest_surnames) - 3}" if len(interest_surnames) > 3 else ""

    return Div(
        Div(
            Div(
                P(f"People from the {surnames_display}{more} families",
                  cls="text-sm font-medium text-amber-200"),
                P(f"{len(matches)} identified \u2014 can you help find more?",
                  cls="text-xs text-slate-400"),
                cls="flex-1",
            ),
            Div(*people_thumbs, cls="flex gap-3"),
            cls="flex items-center gap-4",
        ),
        A("View all \u2192", href=f"/?section=confirmed",
          cls="text-xs text-amber-400 hover:text-amber-300 mt-2 inline-block"),
        cls="bg-amber-900/20 border border-amber-700/30 rounded-lg p-4 mb-4",
    )


@rt("/")
def get(section: str = None, view: str = "focus", current: str = None,
        filter_source: str = "", filter_collection: str = "",
        sort_by: str = "newest", filter: str = "", request=None, sess=None):
    """
    Landing page (no section) or Command Center (with section parameter).
    Public access -- anyone can view. Action buttons shown only to admins.
    Logged-in users with no section go to the triage dashboard.
    """
    user = get_current_user(sess or {})

    # Read interest surnames from cookie for personalization
    interest_surnames = []
    if request:
        raw = request.cookies.get("rhodesli_interest_surnames", "")
        if raw:
            from urllib.parse import unquote
            interest_surnames = [s.strip() for s in unquote(raw).split(",") if s.strip()]

    # If no section specified:
    # - Logged-in users: go to inbox if items exist, otherwise Needs Help
    # - Anonymous users see the public landing page
    if section is None:
        if user is not None:
            # Smart redirect: skip empty inbox, go to Needs Help
            registry_check = load_registry()
            inbox_count = len(registry_check.list_identities(state=IdentityState.INBOX))
            proposed_count = len(registry_check.list_identities(state=IdentityState.PROPOSED))
            if inbox_count + proposed_count > 0:
                section = "to_review"
            else:
                section = "skipped"  # Needs Help — always has items to review
        else:
            stats = _compute_landing_stats()
            featured_photos = _get_featured_photos(8)
            return landing_page(stats, featured_photos)


    user_is_admin = (user.is_admin if user else False) if is_auth_enabled() else True

    registry = load_registry()
    crop_files = get_crop_files()

    # Fetch all identity states
    inbox = registry.list_identities(state=IdentityState.INBOX)
    proposed = registry.list_identities(state=IdentityState.PROPOSED)
    confirmed_list = registry.list_identities(state=IdentityState.CONFIRMED)
    skipped_list = registry.list_identities(state=IdentityState.SKIPPED)
    rejected = registry.list_identities(state=IdentityState.REJECTED)
    contested = registry.list_identities(state=IdentityState.CONTESTED)

    # Combine into 4 workflow sections
    to_review = inbox + proposed  # Items needing attention
    dismissed = rejected + contested  # Items explicitly dismissed

    # Sort each section
    to_review.sort(key=lambda x: x.get("created_at", ""), reverse=True)
    confirmed_list.sort(key=lambda x: (x.get("name") or "", x.get("updated_at", "")))
    skipped_list.sort(key=lambda x: x.get("updated_at", ""), reverse=True)
    dismissed.sort(key=lambda x: x.get("updated_at", ""), reverse=True)

    # Canonical sidebar counts (single source of truth)
    counts = _compute_sidebar_counts(registry)

    # Validate section parameter
    valid_sections = ("to_review", "confirmed", "skipped", "rejected", "photos")
    if section not in valid_sections:
        section = "to_review"

    # Validate view parameter
    if view not in ("focus", "browse", "match"):
        view = "focus"

    # Personalized discovery banner when user has interest surnames
    discovery_banner = None
    if interest_surnames and section == "skipped":
        discovery_banner = _personalized_discovery_banner(interest_surnames, confirmed_list, crop_files, counts)

    # Render the appropriate section
    if section == "to_review":
        main_content = render_to_review_section(to_review, crop_files, view, counts, current_id=current, is_admin=user_is_admin, sort_by=sort_by, triage_filter=filter)
    elif section == "confirmed":
        main_content = render_confirmed_section(confirmed_list, crop_files, counts, is_admin=user_is_admin, sort_by=sort_by)
    elif section == "skipped":
        skipped_view = view if view in ("focus", "browse") else "focus"
        main_content = render_skipped_section(skipped_list, crop_files, counts, is_admin=user_is_admin, view_mode=skipped_view, current_id=current)
    elif section == "photos":
        main_content = render_photos_section(counts, registry, crop_files, filter_source, sort_by, filter_collection)
    else:  # rejected
        main_content = render_rejected_section(dismissed, crop_files, counts, is_admin=user_is_admin)

    # Prepend discovery banner to main content if present
    if discovery_banner:
        main_content = Div(discovery_banner, main_content)

    style = Style("""
        html, body {
            height: 100%;
            margin: 0;
            overflow-x: hidden;
        }
        body {
            background-color: #0f172a;
        }
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes slide-out-right {
            from { opacity: 1; transform: translateX(0); }
            to { opacity: 0; transform: translateX(100px); }
        }
        @keyframes card-enter {
            from { opacity: 0; transform: scale(0.97) translateY(8px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
        @keyframes card-exit {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0; transform: scale(0.97) translateY(-8px); }
        }
        .animate-fade-in {
            animation: fade-in 0.3s ease-out;
        }
        .animate-slide-out {
            animation: slide-out-right 0.3s ease-in forwards;
        }
        .animate-card-enter {
            animation: card-enter 0.35s ease-out;
        }
        /* HTMX swap transitions for focus card */
        #focus-card {
            animation: card-enter 0.35s ease-out;
        }
        /* Match mode pair transition */
        .match-pair {
            animation: card-enter 0.35s ease-out;
        }
        .htmx-indicator {
            display: none;
        }
        .htmx-request .htmx-indicator {
            display: inline;
        }
        /* Keyboard focus states */
        button:focus-visible {
            outline: 2px solid #0ea5e9;
            outline-offset: 2px;
        }
        /* Card state transitions */
        .identity-card {
            transition: all 0.2s ease-out;
        }
        .identity-card:hover {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }
        /* Darkroom theme - monospace for data */
        .font-data {
            font-family: 'JetBrains Mono', 'Fira Code', 'SF Mono', Consolas, monospace;
        }
        /* Collapsible sidebar */
        .sidebar-container {
            width: 15rem;
            transition: width 0.2s ease, transform 0.3s ease;
        }
        .sidebar-container.collapsed {
            width: 3.5rem;
        }
        .sidebar-container.collapsed .sidebar-label,
        .sidebar-container.collapsed .sidebar-search,
        .sidebar-container.collapsed .sidebar-search-results {
            display: none;
        }
        .sidebar-container.collapsed .sidebar-nav-item {
            justify-content: center;
            padding-left: 0;
            padding-right: 0;
        }
        .sidebar-container.collapsed .sidebar-icon {
            margin: 0;
        }
        .sidebar-container.collapsed .sidebar-chevron {
            transform: rotate(180deg);
        }
        .sidebar-container.collapsed .sidebar-collapse-btn {
            margin: 0 auto;
        }
        .sidebar-search-results:not(:empty) {
            position: absolute;
            left: 0.75rem;
            right: 0.75rem;
            top: 100%;
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 0.5rem;
            max-height: 300px;
            overflow-y: auto;
            z-index: 50;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        /* Mobile responsive sidebar */
        @media (max-width: 767px) {
            #sidebar {
                width: 15rem !important;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
            }
            #sidebar.open {
                transform: translateX(0);
            }
            #sidebar .sidebar-label { display: inline !important; }
            #sidebar .sidebar-search { display: block !important; }
            .main-content {
                margin-left: 0 !important;
            }
        }
        @media (min-width: 768px) {
            #sidebar { transform: translateX(0); }
        }
        @media (min-width: 1024px) {
            .main-content {
                margin-left: 15rem;
                transition: margin-left 0.2s ease;
            }
            .main-content.sidebar-collapsed {
                margin-left: 3.5rem;
            }
        }
    """)

    # Mobile header (shown only on small screens)
    mobile_header = Div(
        Button(
            # Hamburger icon
            Svg(
                Path(stroke_linecap="round", stroke_linejoin="round", stroke_width="2",
                     d="M4 6h16M4 12h16M4 18h16"),
                cls="w-6 h-6", fill="none", stroke="currentColor", viewBox="0 0 24 24"
            ),
            onclick="toggleSidebar()",
            cls="p-2 text-slate-300 hover:text-white min-h-[44px] min-w-[44px] flex items-center justify-center"
        ),
        Span("Rhodesli", cls="text-lg font-bold text-white"),
        cls="mobile-header lg:hidden flex items-center gap-3 px-4 py-3 bg-slate-800 border-b border-slate-700 sticky top-0 z-30"
    )

    # Sidebar overlay for mobile
    sidebar_overlay = Div(
        onclick="closeSidebar()",
        cls="sidebar-overlay fixed inset-0 bg-black/50 z-30 hidden lg:hidden"
    )

    # Sidebar toggle script (mobile open/close + desktop collapse/expand)
    sidebar_script = Script("""
        // Mobile: open/close sidebar
        function toggleSidebar() {
            var sb = document.getElementById('sidebar');
            var ov = document.querySelector('.sidebar-overlay');
            sb.classList.toggle('open');
            sb.classList.toggle('-translate-x-full');
            ov.classList.toggle('hidden');
        }
        function closeSidebar() {
            var sb = document.getElementById('sidebar');
            var ov = document.querySelector('.sidebar-overlay');
            sb.classList.remove('open');
            sb.classList.add('-translate-x-full');
            ov.classList.add('hidden');
        }
        // Desktop: collapse/expand sidebar
        function toggleSidebarCollapse() {
            var sb = document.getElementById('sidebar');
            var mc = document.querySelector('.main-content');
            var isCollapsed = sb.classList.toggle('collapsed');
            if (mc) mc.classList.toggle('sidebar-collapsed', isCollapsed);
            try { localStorage.setItem('sidebar_collapsed', isCollapsed ? 'true' : 'false'); } catch(e) {}
        }
        // Restore sidebar state from localStorage on page load
        (function() {
            try {
                var collapsed = localStorage.getItem('sidebar_collapsed') === 'true';
                if (collapsed && window.innerWidth >= 1024) {
                    var sb = document.getElementById('sidebar');
                    var mc = document.querySelector('.main-content');
                    if (sb) sb.classList.add('collapsed');
                    if (mc) mc.classList.add('sidebar-collapsed');
                }
            } catch(e) {}
            // Close search results when clicking outside
            document.addEventListener('click', function(e) {
                var search = document.querySelector('.sidebar-search');
                var results = document.getElementById('sidebar-search-results');
                if (search && results && !search.contains(e.target)) {
                    results.innerHTML = '';
                }
            });
        })();
    """)

    # Mobile bottom tab navigation (lg:hidden)
    mobile_tabs = Nav(
        A(
            Svg(
                Path(d="M4 6h16M4 10h16M4 14h16M4 18h16"),
                cls="w-5 h-5", fill="none", stroke="currentColor", viewBox="0 0 24 24",
                stroke_width="2", stroke_linecap="round",
            ),
            Span("Photos", cls="text-[10px]"),
            href="/?section=photos",
            cls=f"flex flex-col items-center justify-center gap-0.5 min-h-[44px] min-w-[44px] "
                f"{'text-indigo-400' if section == 'photos' else 'text-slate-400 hover:text-slate-200'}",
        ),
        A(
            Svg(
                Path(d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"),
                cls="w-5 h-5", fill="none", stroke="currentColor", viewBox="0 0 24 24",
                stroke_width="2", stroke_linecap="round", stroke_linejoin="round",
            ),
            Span("People", cls="text-[10px]"),
            href="/?section=confirmed&view=browse",
            cls=f"flex flex-col items-center justify-center gap-0.5 min-h-[44px] min-w-[44px] "
                f"{'text-emerald-400' if section == 'confirmed' else 'text-slate-400 hover:text-slate-200'}",
        ),
        A(
            Svg(
                Path(d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4"),
                cls="w-5 h-5", fill="none", stroke="currentColor", viewBox="0 0 24 24",
                stroke_width="2", stroke_linecap="round", stroke_linejoin="round",
            ),
            Span("Matches", cls="text-[10px]"),
            href="/?section=to_review&view=focus",
            cls=f"flex flex-col items-center justify-center gap-0.5 min-h-[44px] min-w-[44px] "
                f"{'text-amber-400' if section == 'to_review' else 'text-slate-400 hover:text-slate-200'}",
        ),
        A(
            Svg(
                Path(d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"),
                cls="w-5 h-5", fill="none", stroke="currentColor", viewBox="0 0 24 24",
                stroke_width="2", stroke_linecap="round", stroke_linejoin="round",
            ),
            Span("Search", cls="text-[10px]"),
            href="/?section=confirmed&view=browse",
            cls="flex flex-col items-center justify-center gap-0.5 min-h-[44px] min-w-[44px] text-slate-400 hover:text-slate-200",
            onclick="toggleSidebar(); setTimeout(function() { var s = document.querySelector('#sidebar input[type=search]'); if (s) s.focus(); }, 300); return false;",
        ),
        cls="fixed bottom-0 left-0 right-0 bg-slate-800 border-t border-slate-700 flex items-center justify-around py-1 z-40 lg:hidden",
        id="mobile-tabs",
    )

    return Title("Rhodesli Identity System"), style, Div(
        # Toast container for notifications
        toast_container(),
        # Mobile header
        mobile_header,
        # Sidebar overlay (mobile backdrop)
        sidebar_overlay,
        # Sidebar (fixed)
        sidebar(counts, section, user=user),
        # Main content (offset for sidebar, bottom padding for mobile tabs)
        Main(
            # First-time welcome banner (non-blocking, dismissible)
            _welcome_banner() if not user else None,
            # Admin dashboard banner (only for admins)
            _admin_dashboard_banner(counts, section) if user_is_admin else None,
            Div(
                main_content,
                cls="max-w-6xl mx-auto px-4 sm:px-8 py-6 pb-20 lg:pb-6"
            ),
            cls="main-content min-h-screen overflow-x-hidden"
        ),
        # Mobile bottom tabs
        mobile_tabs,
        # Photo modal (unified lightbox for all photo viewing)
        photo_modal(),
        # Side-by-side comparison modal for merge evaluation
        compare_modal(),
        # Login modal (shown when unauthenticated user triggers protected action)
        login_modal(),
        # Guest-or-login modal container (swapped in by annotation submit)
        Div(id="guest-or-login-modal"),
        # Styled confirmation modal (replaces native browser confirm())
        confirm_modal(),
        sidebar_script,
        # Client-side instant name filter with fuzzy matching (FE-030/FE-031/FE-033)
        Script("""
            (function() {
                // Levenshtein edit distance for fuzzy name matching
                function levenshtein(a, b) {
                    if (a.length < b.length) return levenshtein(b, a);
                    if (b.length === 0) return a.length;
                    var prev = [];
                    for (var j = 0; j <= b.length; j++) prev[j] = j;
                    for (var i = 1; i <= a.length; i++) {
                        var curr = [i];
                        for (var j = 1; j <= b.length; j++) {
                            var cost = a[i-1] === b[j-1] ? 0 : 1;
                            curr[j] = Math.min(curr[j-1] + 1, prev[j] + 1, prev[j-1] + cost);
                        }
                        prev = curr;
                    }
                    return prev[b.length];
                }
                // Fuzzy match: exact substring OR Levenshtein distance <= threshold per word
                function fuzzyMatch(query, name) {
                    if (!query) return true;
                    if (name.indexOf(query) !== -1) return true;
                    var words = name.split(/\\s+/);
                    var maxDist = query.length <= 8 ? 2 : 3;
                    for (var w = 0; w < words.length; w++) {
                        if (levenshtein(query, words[w]) <= maxDist) return true;
                    }
                    return false;
                }
                var filterTimer = null;
                function sidebarFilterCards(query) {
                    // Filter both standalone cards and wrapper divs (Needs Help has card+hint wrappers)
                    var cards = document.querySelectorAll('.identity-card, .identity-card-wrapper');
                    var q = (query || '').toLowerCase().trim();
                    for (var i = 0; i < cards.length; i++) {
                        var name = cards[i].getAttribute('data-name') || '';
                        if (fuzzyMatch(q, name)) {
                            cards[i].style.display = '';
                        } else {
                            cards[i].style.display = 'none';
                        }
                    }
                }
                var input = document.getElementById('sidebar-search-input');
                if (input) {
                    input.addEventListener('input', function() {
                        var val = this.value;
                        clearTimeout(filterTimer);
                        filterTimer = setTimeout(function() {
                            sidebarFilterCards(val);
                        }, 150);
                    });
                }
                // Expose for testing
                window.sidebarFilterCards = sidebarFilterCards;
            })();
        """),
        # Hash-based scroll + highlight for search result navigation
        Script("""
            (function() {
                if (window.location.hash) {
                    var target = document.querySelector(window.location.hash);
                    if (target) {
                        target.scrollIntoView({behavior: 'smooth', block: 'center'});
                        target.classList.add('ring-2', 'ring-blue-400');
                        setTimeout(function() {
                            target.classList.remove('ring-2', 'ring-blue-400');
                        }, 2000);
                    }
                }
            })();
        """),
        # Global share utility functions (used by share buttons on all pages)
        Script("""
            function _sharePhotoUrl(url, shareTitle, shareText) {
                // Always copy to clipboard first (desktop-friendly).
                // On mobile, also offer native share sheet after copying.
                _copyAndToast(url);
                var isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                if (isMobile && navigator.share) {
                    var shareData = { url: url };
                    if (shareTitle) shareData.title = shareTitle;
                    if (shareText) shareData.text = shareText;
                    navigator.share(shareData).catch(function() {});
                }
            }
            function _copyAndToast(url) {
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(url).then(function() {
                        _showShareToast('Link copied!');
                    }).catch(function() { _showShareToast('Could not copy link'); });
                } else {
                    var input = document.createElement('input');
                    input.value = url;
                    document.body.appendChild(input);
                    input.select();
                    document.execCommand('copy');
                    document.body.removeChild(input);
                    _showShareToast('Link copied!');
                }
            }
            function _showShareToast(message) {
                var existing = document.getElementById('share-toast');
                if (existing) existing.remove();
                var toast = document.createElement('div');
                toast.id = 'share-toast';
                toast.textContent = message;
                toast.style.cssText = 'position:fixed;bottom:24px;left:50%;transform:translateX(-50%);background:#334155;color:#e2e8f0;padding:10px 20px;border-radius:8px;font-size:14px;z-index:9999;transition:opacity 0.3s;box-shadow:0 4px 12px rgba(0,0,0,0.3);';
                document.body.appendChild(toast);
                setTimeout(function() { toast.style.opacity = '0'; }, 2000);
                setTimeout(function() { toast.remove(); }, 2500);
            }
        """),
        # Global event delegation for lightbox/photo navigation (BUG-001 fix).
        # ONE listener on document handles all nav clicks and keyboard events.
        # This never needs rebinding because it's on document, not swapped DOM.
        Script("""
            // --- Global event delegation for photo/lightbox navigation ---
            // Click delegation: dispatch based on data-action attribute
            document.addEventListener('click', function(e) {
                var btn = e.target.closest('[data-action]');
                if (!btn) return;
                var action = btn.getAttribute('data-action');

                // Share photo/page (used across all surfaces)
                if (action === 'share-photo') {
                    var url = btn.getAttribute('data-share-url') || '';
                    if (url && !url.startsWith('http')) {
                        url = window.location.origin + url;
                    }
                    var shareTitle = btn.getAttribute('data-share-title') || '';
                    var shareText = btn.getAttribute('data-share-text') || '';
                    _sharePhotoUrl(url || window.location.href, shareTitle, shareText);
                    return;
                }

                // Photo modal prev/next (Photos grid browsing)
                if (action === 'photo-nav-prev' || action === 'photo-nav-next') {
                    e.preventDefault();
                    var idx = parseInt(btn.getAttribute('data-nav-idx'), 10);
                    if (typeof photoNavTo === 'function' && !isNaN(idx)) {
                        photoNavTo(idx);
                    } else {
                        var url = btn.getAttribute('data-nav-url');
                        if (url) htmx.ajax('GET', url, {target:'#photo-modal-content', swap:'innerHTML'});
                    }
                    return;
                }

                // Identity photo lightbox prev/next — HTMX handles these via
                // hx-get. data-action is for keyboard delegation below.
            });

            // Keyboard delegation: one global listener, reads DOM for current state.
            // Priority: modals first, then suppress in text fields, then mode shortcuts.

            // Undo stack: stores last 10 actions for Z-key undo
            if (!window._undoStack) window._undoStack = [];

            // Capture undo data before HTMX actions fire
            document.addEventListener('click', function(e) {
                var btn = e.target.closest('[data-undo-type]');
                if (btn) {
                    var undoInfo = {
                        type: btn.getAttribute('data-undo-type'),
                        url: btn.getAttribute('data-undo-url') || '',
                        identity: btn.getAttribute('data-undo-identity') || '',
                        ts: Date.now()
                    };
                    window._undoStack.push(undoInfo);
                    if (window._undoStack.length > 10) window._undoStack.shift();
                }
            }, true);

            document.addEventListener('keydown', function(e) {
                // --- Modal navigation (highest priority) ---
                // Unified photo modal (handles both photo grid browsing and identity photo browsing)
                var photoModal = document.getElementById('photo-modal');
                if (photoModal && !photoModal.classList.contains('hidden')) {
                    if (e.key === 'ArrowLeft') {
                        // Try photo grid nav first, then identity lightbox nav
                        var prev = document.querySelector('[data-action="photo-nav-prev"]');
                        if (prev) { prev.click(); e.preventDefault(); }
                        else {
                            var lbPrev = document.querySelector('[data-action="lightbox-prev"]');
                            if (lbPrev) { lbPrev.click(); e.preventDefault(); }
                            else if (typeof photoNavTo === 'function' && window._photoNavIdx > 0) {
                                photoNavTo(window._photoNavIdx - 1); e.preventDefault();
                            }
                        }
                    } else if (e.key === 'ArrowRight') {
                        var next = document.querySelector('[data-action="photo-nav-next"]');
                        if (next) { next.click(); e.preventDefault(); }
                        else {
                            var lbNext = document.querySelector('[data-action="lightbox-next"]');
                            if (lbNext) { lbNext.click(); e.preventDefault(); }
                            else if (typeof photoNavTo === 'function' && window._photoNavIdx < (window._photoNavIds||[]).length - 1) {
                                photoNavTo(window._photoNavIdx + 1); e.preventDefault();
                            }
                        }
                    } else if (e.key === 'Escape') {
                        photoModal.classList.add('hidden'); e.preventDefault();
                    }
                    return;
                }

                // --- Suppress shortcuts when typing in INPUT or TEXTAREA ---
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                // --- Ignore when modifier keys are held (Cmd+R, Ctrl+S, etc.) ---
                if (e.metaKey || e.ctrlKey || e.altKey) return;

                // --- Z = Undo last action (works in all focus modes) ---
                if (e.key === 'z' || e.key === 'Z') {
                    e.preventDefault();
                    if (!window._undoStack || window._undoStack.length === 0) return;
                    var last = window._undoStack.pop();
                    if (last.type === 'skip') {
                        // Skip undo: navigate back to the skipped identity
                        window.location.href = '/?section=skipped&view=focus&current=' + last.identity;
                    } else if (last.url) {
                        // Merge/reject undo: POST to undo endpoint, then reload focus on that identity
                        fetch(last.url, {method: 'POST', headers: {'HX-Request': 'true'}}).then(function() {
                            window.location.href = '/?section=skipped&view=focus&current=' + last.identity;
                        });
                    }
                    return;
                }

                // --- Match mode shortcuts: Y=Same, N=Different, S=Skip ---
                var matchBtn = null;
                if (e.key === 'y' || e.key === 'Y') matchBtn = document.getElementById('match-btn-same');
                else if (e.key === 'n' || e.key === 'N') matchBtn = document.getElementById('match-btn-diff');
                else if (e.key === 's' || e.key === 'S') matchBtn = document.getElementById('match-btn-skip');
                if (matchBtn) { e.preventDefault(); matchBtn.click(); return; }

                // --- Focus mode shortcuts ---
                // Skipped focus mode: Y=Same Person, N=Not Same, Enter=I Know Them, S=Skip, Z=Undo
                // Inbox focus mode: C=Confirm, S=Skip, R=Reject, F=Find Similar
                var focusBtn = null;
                var isSkippedFocus = document.querySelector('[data-focus-mode="skipped"]');
                if (isSkippedFocus) {
                    if (e.key === 'y' || e.key === 'Y') focusBtn = document.getElementById('focus-btn-confirm');
                    else if (e.key === 'n' || e.key === 'N') focusBtn = document.getElementById('focus-btn-reject');
                    else if (e.key === 'Enter') focusBtn = document.getElementById('focus-btn-name');
                    else if (e.key === 's' || e.key === 'S') focusBtn = document.getElementById('focus-btn-skip');
                } else {
                    if (e.key === 'c' || e.key === 'C') focusBtn = document.getElementById('focus-btn-confirm');
                    else if (e.key === 's' || e.key === 'S') focusBtn = document.getElementById('focus-btn-skip');
                    else if (e.key === 'r' || e.key === 'R') focusBtn = document.getElementById('focus-btn-reject');
                    else if (e.key === 'f' || e.key === 'F') focusBtn = document.getElementById('focus-btn-similar');
                }
                if (focusBtn) { e.preventDefault(); focusBtn.click(); return; }
            });
        """),
        cls="h-full"
    )


@rt("/confirm/{identity_id}")
def post(identity_id: str, from_focus: bool = False, filter: str = "", sess=None):
    """
    Confirm an identity (move from PROPOSED to CONFIRMED).
    Requires admin.
    """
    denied = _check_admin(sess)
    if denied:
        return denied
    try:
        registry = load_registry()
    except Exception:
        # Lock contention or file access error
        return Response(
            to_xml(toast("System busy. Please try again.", "warning")),
            status_code=423,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    try:
        identity = registry.get_identity(identity_id)
    except KeyError:
        return Response(
            to_xml(toast("Identity not found.", "error")),
            status_code=404,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # Confirm the identity
    try:
        registry.confirm_identity(identity_id, user_source="web")
        save_registry(registry)
    except Exception as e:
        # Could be variance explosion or other error
        return Response(
            to_xml(toast(f"Cannot confirm: {str(e)}", "error")),
            status_code=409,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # If from focus mode, return the next focus card
    if from_focus:
        return (
            get_next_focus_card(exclude_id=identity_id, triage_filter=filter),
            toast("Identity confirmed.", "success"),
        )

    # Return updated card (now CONFIRMED, no action buttons)
    crop_files = get_crop_files()
    updated_identity = registry.get_identity(identity_id)

    # Return the card plus a success toast
    return (
        identity_card(updated_identity, crop_files, lane_color="emerald", show_actions=False),
        toast("Identity confirmed.", "success"),
    )


@rt("/reject/{identity_id}")
def post(identity_id: str, from_focus: bool = False, filter: str = "", sess=None):
    """Contest/reject an identity (move to CONTESTED). Requires admin."""
    denied = _check_admin(sess)
    if denied:
        return denied
    try:
        registry = load_registry()
    except Exception:
        return Response(
            to_xml(toast("System busy. Please try again.", "warning")),
            status_code=423,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    try:
        identity = registry.get_identity(identity_id)
    except KeyError:
        return Response(
            to_xml(toast("Identity not found.", "error")),
            status_code=404,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    try:
        registry.contest_identity(identity_id, user_source="web", reason="Rejected via UI")
        save_registry(registry)
    except Exception as e:
        return Response(
            to_xml(toast(f"Cannot reject: {str(e)}", "error")),
            status_code=409,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # If from focus mode, return the next focus card
    if from_focus:
        return (
            get_next_focus_card(exclude_id=identity_id, triage_filter=filter),
            toast("Identity contested.", "warning"),
        )

    crop_files = get_crop_files()
    updated_identity = registry.get_identity(identity_id)

    return (
        identity_card(updated_identity, crop_files, lane_color="red", show_actions=False),
        toast("Identity contested.", "warning"),
    )


# =============================================================================
# ROUTES - PHOTO CONTEXT NAVIGATOR (LIGHT TABLE)
# =============================================================================

@rt("/api/photo/{photo_id}")
def get(photo_id: str):
    """
    Get photo metadata with face bounding boxes.

    Returns JSON with:
    - photo_url: Static path to the photo
    - image_width, image_height: Original dimensions
    - faces: List of face objects with bbox, face_id, display_name, identity_id
    """
    photo = get_photo_metadata(photo_id)
    if not photo:
        return JSONResponse(
            {"error": "Photo not found", "photo_id": photo_id},
            status_code=404,
        )

    # Get image dimensions for face overlay positioning
    width, height = get_photo_dimensions(photo["filename"])
    if width == 0 or height == 0:
        return JSONResponse(
            {"error": "Could not read photo dimensions", "photo_id": photo_id},
            status_code=404,
        )

    # Build face list with identity information
    registry = load_registry()
    faces = []

    for face_data in photo["faces"]:
        face_id = face_data["face_id"]
        bbox = face_data["bbox"]  # [x1, y1, x2, y2]

        # Find identity for this face
        identity = get_identity_for_face(registry, face_id)

        # Convert bbox from [x1, y1, x2, y2] to {x, y, w, h}
        x1, y1, x2, y2 = bbox
        # UI BOUNDARY: sanitize display_name for safe JSON rendering
        raw_display_name = identity.get("name", "Unidentified") if identity else "Unidentified"
        face_obj = {
            "face_id": face_id,
            "bbox": {
                "x": x1,
                "y": y1,
                "w": x2 - x1,
                "h": y2 - y1,
            },
            "display_name": ensure_utf8_display(raw_display_name),
            "identity_id": identity["identity_id"] if identity else None,
            "is_selected": False,
        }
        faces.append(face_obj)

    return JSONResponse({
        "photo_url": photo_url(photo["filename"]),
        "image_width": width,
        "image_height": height,
        "faces": faces,
    })


@rt("/api/photo/{photo_id}/collection")
def post(photo_id: str, sess, collection: str = ""):
    """
    Update a photo's collection (classification) label.

    Admin-only. Updates photo_index.json and invalidates caches.
    """
    admin_err = _check_admin(sess)
    if admin_err:
        return admin_err
    photo_reg = load_photo_registry()
    photo_path = photo_reg.get_photo_path(photo_id)
    if not photo_path:
        return Response("Photo not found", status_code=404)
    photo_reg.set_collection(photo_id, collection.strip())
    save_photo_registry(photo_reg)
    global _photo_cache
    _photo_cache = None
    return Div(
        Span(f"Collection updated to: {collection.strip() or '(none)'}",
             cls="text-sm text-emerald-400"),
        id=f"collection-status-{photo_id}",
    )


@rt("/api/photo/{photo_id}/source")
def post(photo_id: str, sess, source: str = ""):
    """
    Update a photo's source (provenance/origin) label.

    Admin-only. Updates photo_index.json and invalidates caches.
    """
    admin_err = _check_admin(sess)
    if admin_err:
        return admin_err
    photo_reg = load_photo_registry()
    photo_path = photo_reg.get_photo_path(photo_id)
    if not photo_path:
        return Response("Photo not found", status_code=404)
    photo_reg.set_source(photo_id, source.strip())
    save_photo_registry(photo_reg)
    global _photo_cache
    _photo_cache = None
    return Div(
        Span(f"Source updated to: {source.strip() or '(none)'}",
             cls="text-sm text-emerald-400"),
        id=f"source-status-{photo_id}",
    )


@rt("/api/photo/{photo_id}/source-url")
def post(photo_id: str, sess, source_url: str = ""):
    """
    Update a photo's source URL (citation link).

    Admin-only. Updates photo_index.json and invalidates caches.
    """
    admin_err = _check_admin(sess)
    if admin_err:
        return admin_err
    photo_reg = load_photo_registry()
    photo_path = photo_reg.get_photo_path(photo_id)
    if not photo_path:
        return Response("Photo not found", status_code=404)
    photo_reg.set_source_url(photo_id, source_url.strip())
    save_photo_registry(photo_reg)
    global _photo_cache
    _photo_cache = None
    if source_url.strip():
        return Div(
            Span("Source URL: ", cls="text-slate-500 text-sm"),
            A(source_url.strip(), href=source_url.strip(), target="_blank",
              rel="noopener", cls="text-indigo-400 hover:text-indigo-300 underline text-sm"),
            id=f"source-url-status-{photo_id}",
        )
    return Div(
        Span("Source URL cleared", cls="text-sm text-emerald-400"),
        id=f"source-url-status-{photo_id}",
    )


def _load_corrections_log() -> dict:
    """Load corrections log. Creates file if it doesn't exist."""
    corrections_path = data_path / "corrections_log.json"
    if not corrections_path.exists():
        return {"schema_version": 1, "corrections": []}
    try:
        with open(corrections_path) as f:
            return json.load(f)
    except Exception:
        return {"schema_version": 1, "corrections": []}


def _save_corrections_log(data: dict):
    """Save corrections log atomically."""
    corrections_path = data_path / "corrections_log.json"
    import tempfile
    tmp_fd, tmp_path = tempfile.mkstemp(dir=str(data_path), suffix=".json")
    try:
        with os.fdopen(tmp_fd, "w") as f:
            json.dump(data, f, indent=2)
        os.replace(tmp_path, str(corrections_path))
    except Exception:
        if os.path.exists(tmp_path):
            os.unlink(tmp_path)
        raise


@rt("/api/photo/{photo_id}/correct-date")
async def post(photo_id: str, correction_year: int = None, sess=None):
    """Submit a date correction for a photo. Updates date labels and logs the correction.

    Auth: any logged-in user can correct (or admin when auth disabled).
    Returns updated date section HTML via HTMX swap.
    """
    if is_auth_enabled():
        user = get_current_user(sess or {})
        if not user:
            return Response("", status_code=401)
        contributor_email = user.email
        contributor_type = "admin" if user.is_admin else "registered"
    else:
        contributor_email = "local"
        contributor_type = "admin"

    if not correction_year or correction_year < 1850 or correction_year > 2030:
        return Div(
            Span("Invalid year (1850-2030)", cls="text-sm text-red-400"),
            id=f"date-section-{photo_id[:8]}",
        )

    # Load current label
    labels = _load_date_labels()
    label = labels.get(photo_id)
    if not label:
        return Div(
            Span("No date label found", cls="text-sm text-red-400"),
            id=f"date-section-{photo_id[:8]}",
        )

    # Record correction
    import uuid
    from datetime import datetime, timezone
    old_decade = label.get("estimated_decade")
    old_year = label.get("best_year_estimate")
    new_decade = (correction_year // 10) * 10

    correction_entry = {
        "id": f"corr_{uuid.uuid4().hex[:12]}",
        "photo_id": photo_id,
        "field": "estimated_decade",
        "old_value": {"decade": old_decade, "year": old_year},
        "new_value": {"decade": new_decade, "year": correction_year},
        "old_source": label.get("source", "gemini"),
        "new_source": "human",
        "contributor_email": contributor_email,
        "contributor_type": contributor_type,
        "status": "applied",
        "timestamp": datetime.now(timezone.utc).isoformat(),
    }

    # Save correction log
    log = _load_corrections_log()
    log["corrections"].append(correction_entry)
    _save_corrections_log(log)

    # Update the in-memory label cache
    label["estimated_decade"] = new_decade
    label["best_year_estimate"] = correction_year
    label["confidence"] = "high"
    label["source"] = "human"
    label["probable_range"] = [correction_year - 2, correction_year + 2]

    # Return updated date section with verified styling
    return Div(
        Div(
            P(f"circa {correction_year}", cls="text-lg font-serif text-amber-200 mb-1 inline"),
            Span("\u2713 Verified", cls="text-[11px] text-emerald-400 ml-2"),
            cls="flex items-center",
        ),
        Div(
            Span("Confidence: high", cls="text-[11px] px-2 py-0.5 rounded-full bg-emerald-500/20 text-emerald-400"),
            cls="flex items-center gap-2"
        ),
        P("Thanks! Your correction helps improve our AI.", cls="text-[11px] text-emerald-400/70 mt-2 italic"),
        id=f"date-section-{photo_id[:8]}",
        data_testid="verified-field",
    )


def photo_view_content(
    photo_id: str,
    selected_face_id: str = None,
    is_partial: bool = False,
    prev_id: str = None,
    next_id: str = None,
    nav_idx: int = -1,
    nav_total: int = 0,
    identity_id: str = None,
    is_admin: bool = False,
    from_compare: bool = False,
) -> tuple:
    """
    Build the photo view content with face overlays.

    Optional navigation context for prev/next arrows:
    - prev_id/next_id: Photo IDs for adjacent photos
    - nav_idx/nav_total: Position counter for "X of Y" display
    - identity_id: Compute navigation from identity's unique photos

    Returns FastHTML elements for the photo viewer.
    """
    photo = get_photo_metadata(photo_id)
    if not photo:
        error_content = Div(
            P("Photo not found", cls="text-red-400 font-bold"),
            P(f"ID: {photo_id}", cls="text-slate-400 text-sm font-data"),
            cls="text-center p-8"
        )
        return (error_content,) if is_partial else (Title("Photo Not Found"), error_content)

    # Get image dimensions for face overlay positioning
    # This handles inbox uploads which are stored outside raw_photos/
    width, height = get_photo_dimensions(photo["filename"])

    # If dimensions aren't available (e.g., R2 mode without cached dimensions),
    # we can still show the photo - just without face overlays
    has_dimensions = width > 0 and height > 0

    registry = load_registry()

    # Identity-based navigation: when identity_id is provided and no explicit
    # prev/next, compute navigation from the identity's unique photo list.
    if identity_id and not prev_id and not next_id:
        try:
            identity_nav = registry.get_identity(identity_id)
            all_faces = identity_nav.get("anchor_ids", []) + identity_nav.get("candidate_ids", [])
            # Build ordered list of unique photo IDs from identity's faces
            seen_pids = []
            for f in all_faces:
                fid = f if isinstance(f, str) else f.get("face_id", "")
                pid = get_photo_id_for_face(fid)
                if pid and pid not in seen_pids:
                    seen_pids.append(pid)
            if photo_id in seen_pids:
                idx = seen_pids.index(photo_id)
                if idx > 0:
                    prev_id = seen_pids[idx - 1]
                if idx < len(seen_pids) - 1:
                    next_id = seen_pids[idx + 1]
                nav_idx = idx
                nav_total = len(seen_pids)
        except KeyError:
            pass

    # Build face overlays with CSS percentages for responsive scaling
    # Only if we have dimensions (needed for percentage calculations)
    from urllib.parse import quote as _url_quote
    face_overlays = []
    if has_dimensions:
        for face_data in photo["faces"]:
            face_id = face_data["face_id"]
            face_id_encoded = _url_quote(face_id, safe="")
            bbox = face_data["bbox"]  # [x1, y1, x2, y2]
            x1, y1, x2, y2 = bbox

            # Convert to percentages for responsive positioning
            left_pct = (x1 / width) * 100
            top_pct = (y1 / height) * 100
            width_pct = ((x2 - x1) / width) * 100
            height_pct = ((y2 - y1) / height) * 100

            # Get identity info
            identity = get_identity_for_face(registry, face_id)
            # UI BOUNDARY: sanitize display_name for safe rendering
            raw_name = identity.get("name", "Unidentified") if identity else "Unidentified"
            display_name = ensure_utf8_display(raw_name)
            identity_id = identity["identity_id"] if identity else None

            # Calculate age at time of photo if both birth year and photo year exist
            age_at_photo = None
            if identity_id and identity and identity.get("state") == "CONFIRMED":
                birth_year, by_source, _ = _get_birth_year(identity_id, identity, include_unreviewed=False)
                if birth_year:
                    # Get photo year from date labels or photo metadata
                    date_labels = _load_date_labels()
                    date_label = date_labels.get(photo_id, {})
                    photo_year = date_label.get("best_year_estimate")
                    if not photo_year:
                        date_taken = photo.get("date_taken", "")
                        if date_taken and len(str(date_taken)) >= 4:
                            try:
                                photo_year = int(str(date_taken)[:4])
                            except (ValueError, TypeError):
                                pass
                    if photo_year:
                        age_at_photo = int(photo_year) - birth_year

            # Determine section based on identity state for navigation
            if identity:
                state = identity.get("state", "INBOX")
                nav_section = _section_for_state(state)
            else:
                state = None
                nav_section = "to_review"

            # Determine if this face is selected
            is_selected = face_id == selected_face_id

            # Build the overlay div with status-based colors
            overlay_classes = "face-overlay absolute cursor-pointer transition-all"
            status_badge = None
            if is_selected:
                overlay_classes += " border-2 border-amber-500 bg-amber-500/20"
            elif state == "CONFIRMED":
                overlay_classes += " border-2 border-emerald-500 bg-emerald-500/10 hover:bg-emerald-500/20 hover:border-emerald-300"
                status_badge = Span("\u2713", cls="absolute -top-1.5 -right-1.5 w-4 h-4 bg-emerald-500 text-white text-[10px] font-bold rounded-full flex items-center justify-center pointer-events-none")
            elif state == "SKIPPED":
                overlay_classes += " border-2 border-amber-500 bg-amber-500/10 hover:bg-amber-500/20 hover:border-amber-300"
                status_badge = Span("\u23ed", cls="absolute -top-1.5 -right-1.5 w-4 h-4 bg-amber-500 text-white text-[8px] rounded-full flex items-center justify-center pointer-events-none")
            elif state in ("REJECTED", "CONTESTED"):
                overlay_classes += " border-2 border-red-500 bg-red-500/10 hover:bg-red-500/20 hover:border-red-300"
                status_badge = Span("\u2717", cls="absolute -top-1.5 -right-1.5 w-4 h-4 bg-red-500 text-white text-[10px] font-bold rounded-full flex items-center justify-center pointer-events-none")
            elif state == "PROPOSED":
                overlay_classes += " border-2 border-indigo-400 bg-indigo-400/10 hover:bg-indigo-400/20 hover:border-indigo-300"
            else:
                # INBOX or unassigned — dashed border signals "needs attention"
                overlay_classes += " border-2 border-dashed border-slate-400 bg-slate-400/5 hover:bg-slate-400/15 hover:border-white"

            # Tag dropdown for this face (hidden by default)
            tag_dropdown_id = f"tag-dropdown-{face_id.replace(':', '-').replace(' ', '_')}"
            tag_results_id = f"tag-results-{face_id.replace(':', '-').replace(' ', '_')}"

            # Click handler: confirmed faces navigate to identity card;
            # all other faces open the tag dropdown.
            if state == "CONFIRMED" and identity_id:
                tag_script = (
                    f"on click halt the event's bubbling "
                    f"then add .hidden to #photo-modal "
                    f"then go to url '/?section={nav_section}&view=browse#identity-{identity_id}'"
                )
            else:
                tag_script = (
                    f"on click halt the event's bubbling "
                    f"then set dropdowns to <div.tag-dropdown/> in closest .photo-viewer "
                    f"then for dd in dropdowns "
                    f"  if dd.id is not '{tag_dropdown_id}' add .hidden to dd end "
                    f"end "
                    f"then toggle .hidden on #{tag_dropdown_id} "
                    f"then set el to first <input/> in #{tag_dropdown_id} "
                    f"then if el call el.focus()"
                )

            tag_placeholder = "Type name to tag..." if is_admin else "Who is this person?"
            tag_dropdown = Div(
                # Search input
                Input(
                    type="text",
                    placeholder=tag_placeholder,
                    cls="w-full px-2 py-1.5 text-sm bg-slate-800 border border-slate-600 text-white rounded "
                        "focus:outline-none focus:ring-1 focus:ring-indigo-400 placeholder-slate-500",
                    hx_get=f"/api/face/tag-search?face_id={face_id_encoded}",
                    hx_trigger="keyup changed delay:300ms",
                    hx_target=f"#{tag_results_id}",
                    hx_include="this",
                    name="q",
                    autocomplete="off",
                ),
                # Results container (pre-populated with existing suggestions if any)
                Div(
                    *_existing_suggestions_for_identity(identity_id, face_id_encoded),
                    id=tag_results_id, cls="mt-1 max-h-48 overflow-y-auto"
                ),
                # Bottom actions
                Div(
                    Button(
                        "Go to Face Card",
                        cls="text-xs text-indigo-400 hover:text-indigo-300",
                        **{"_": f"on click add .hidden to #photo-modal then go to url '/?section={nav_section}&view=browse#identity-{identity_id}'"} if identity_id else {},
                        type="button",
                    ) if identity_id else None,
                    Button(
                        "Close",
                        cls="text-xs text-slate-400 hover:text-slate-300 ml-auto",
                        **{"_": f"on click add .hidden to #{tag_dropdown_id}"},
                        type="button",
                    ),
                    cls="flex items-center justify-between mt-2 pt-1 border-t border-slate-700"
                ),
                id=tag_dropdown_id,
                cls="hidden tag-dropdown absolute top-full left-0 mt-1 w-56 sm:w-64 bg-slate-800 border border-slate-600 "
                    "rounded-lg shadow-xl p-2 z-20",
                **{"_": "on click halt the event's bubbling"},  # Prevent clicks inside from closing
            )

            # Build inline quick-action buttons for admin users
            # Only for actionable states (INBOX, PROPOSED, SKIPPED)
            quick_actions = None
            if is_admin and identity_id and state in ("INBOX", "PROPOSED", "SKIPPED"):
                action_btns = []
                # Confirm button
                action_btns.append(Button(
                    "\u2713",
                    cls="w-6 h-6 rounded-full bg-emerald-600 hover:bg-emerald-500 text-white text-xs "
                        "flex items-center justify-center",
                    hx_post=f"/api/face/quick-action?identity_id={identity_id}&action=confirm&photo_id={photo_id}",
                    hx_target="#photo-modal-content",
                    hx_swap="innerHTML",
                    title="Confirm",
                    type="button",
                    **{"_": "on click halt the event's bubbling"},
                ))
                # Skip button (not for SKIPPED state)
                if state in ("INBOX", "PROPOSED"):
                    action_btns.append(Button(
                        "\u23f8",
                        cls="w-6 h-6 rounded-full bg-amber-500 hover:bg-amber-400 text-white text-xs "
                            "flex items-center justify-center",
                        hx_post=f"/api/face/quick-action?identity_id={identity_id}&action=skip&photo_id={photo_id}",
                        hx_target="#photo-modal-content",
                        hx_swap="innerHTML",
                        title="Skip",
                        type="button",
                        **{"_": "on click halt the event's bubbling"},
                    ))
                # Reject button
                action_btns.append(Button(
                    "\u2717",
                    cls="w-6 h-6 rounded-full bg-red-600 hover:bg-red-500 text-white text-xs "
                        "flex items-center justify-center",
                    hx_post=f"/api/face/quick-action?identity_id={identity_id}&action=reject&photo_id={photo_id}",
                    hx_target="#photo-modal-content",
                    hx_swap="innerHTML",
                    title="Reject",
                    type="button",
                    **{"_": "on click halt the event's bubbling"},
                ))
                quick_actions = Div(
                    *action_btns,
                    cls="quick-actions absolute bottom-1 left-1/2 -translate-x-1/2 flex gap-1 "
                        "opacity-0 group-hover:opacity-100 transition-opacity z-10",
                )

            # Name label: always visible for confirmed, hover for others
            if state == "CONFIRMED":
                # Always-visible name label below the face box
                # Include age at time of photo if both birth year and photo year are known
                label_text = display_name
                if age_at_photo is not None and age_at_photo >= 0:
                    label_text = f"{display_name}, ~{age_at_photo}"
                name_label = Span(
                    label_text,
                    cls="absolute -bottom-5 left-1/2 -translate-x-1/2 bg-black/70 text-white text-[11px] px-1.5 py-0.5 rounded whitespace-nowrap pointer-events-none max-w-[150%] truncate"
                )
                hover_tooltip = None
            else:
                # Hover tooltip for non-confirmed
                name_label = None
                hover_tooltip = Span(
                    display_name,
                    cls="absolute -top-8 left-1/2 -translate-x-1/2 bg-stone-800 text-white text-xs px-2 py-1 rounded opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap pointer-events-none"
                )

            overlay = Div(
                hover_tooltip,
                name_label,
                status_badge,
                quick_actions,
                tag_dropdown,
                cls=f"{overlay_classes} group",
                style=f"left: {left_pct:.2f}%; top: {top_pct:.2f}%; width: {width_pct:.2f}%; height: {height_pct:.2f}%;",
                title=display_name,
                data_face_id=face_id,
                data_identity_id=identity_id or "",
                **{"_": tag_script},
            )
            face_overlays.append(overlay)

    # Build navigation buttons (for Photos section browsing)
    nav_prev = None
    nav_next = None
    nav_counter = None
    nav_keyboard_script = None

    if prev_id or next_id or (nav_total > 0):
        # Build navigation buttons with data-action attributes for event delegation.
        # The global delegation handler (in the page layout) reads data-action,
        # data-nav-idx, and data-nav-url to dispatch navigation. This pattern
        # survives HTMX content swaps because the listener is on document, not
        # on the swapped DOM nodes.
        # Build URL suffix for identity context continuity
        _id_suffix = f"&identity_id={identity_id}" if identity_id else ""
        if prev_id:
            prev_url = f"/photo/{prev_id}/partial?nav_idx={nav_idx - 1}&nav_total={nav_total}{_id_suffix}"
            nav_prev = Button(
                Span("\u25C0", cls="text-xl"),
                cls="absolute left-2 top-1/2 -translate-y-1/2 bg-black/60 hover:bg-black/80 text-white "
                    "w-12 h-12 rounded-full flex items-center justify-center transition-colors z-10",
                type="button",
                title="Previous photo",
                id="photo-nav-prev",
                data_action="photo-nav-prev",
                data_nav_idx=str(nav_idx - 1),
                data_nav_url=prev_url,
            )
        if next_id:
            next_url = f"/photo/{next_id}/partial?nav_idx={nav_idx + 1}&nav_total={nav_total}{_id_suffix}"
            nav_next = Button(
                Span("\u25B6", cls="text-xl"),
                cls="absolute right-2 top-1/2 -translate-y-1/2 bg-black/60 hover:bg-black/80 text-white "
                    "w-12 h-12 rounded-full flex items-center justify-center transition-colors z-10",
                type="button",
                title="Next photo",
                id="photo-nav-next",
                data_action="photo-nav-next",
                data_nav_idx=str(nav_idx + 1),
                data_nav_url=next_url,
            )
        # Boundary indicators for first/last photo
        if not prev_id and nav_total > 1:
            nav_prev = Div(
                Span("\u25C0", cls="text-xl opacity-30"),
                cls="absolute left-2 top-1/2 -translate-y-1/2 bg-black/30 text-white/30 "
                    "w-12 h-12 rounded-full flex items-center justify-center z-10 cursor-default",
                title="First photo",
            )
        if not next_id and nav_total > 1:
            nav_next = Div(
                Span("\u25B6", cls="text-xl opacity-30"),
                cls="absolute right-2 top-1/2 -translate-y-1/2 bg-black/30 text-white/30 "
                    "w-12 h-12 rounded-full flex items-center justify-center z-10 cursor-default",
                title="Last photo",
            )
        if nav_idx >= 0 and nav_total > 0:
            nav_counter = Span(
                f"{nav_idx + 1} / {nav_total}",
                cls="text-slate-400 text-sm ml-auto"
            )
        # No per-swap keyboard script needed — the global event delegation
        # handler in the page layout handles ArrowLeft/ArrowRight/Escape.

    # "Back to Compare" button when opened from compare modal
    back_to_compare = None
    if from_compare:
        back_to_compare = Div(
            Button(
                "\u2190 Back to Compare",
                cls="text-sm text-indigo-400 hover:text-indigo-300 px-3 py-1.5 rounded border border-indigo-500/30 hover:border-indigo-400/50 transition-colors",
                **{"_": "on click add .hidden to #photo-modal then remove .hidden from #compare-modal"},
                type="button",
            ),
            cls="mb-3"
        )

    # Main content
    content = Div(
        back_to_compare,
        # Photo container with overlays and nav arrows
        Div(
            Img(
                src=photo_url(photo["filename"]),
                alt=photo["filename"],
                cls="max-w-full h-auto"
            ),
            *face_overlays,
            # Face overlay legend
            Div(
                Span(cls="inline-block w-2.5 h-2.5 rounded-sm border-2 border-emerald-500 mr-0.5"),
                Span("Identified", cls="text-slate-400 mr-2"),
                Span(cls="inline-block w-2.5 h-2.5 rounded-sm border-2 border-amber-500 mr-0.5"),
                Span("Help Identify", cls="text-slate-400 mr-2"),
                Span(cls="inline-block w-2.5 h-2.5 rounded-sm border-2 border-dashed border-slate-400 mr-0.5"),
                Span("New", cls="text-slate-400"),
                cls="absolute bottom-1 right-1 bg-black/60 rounded px-2 py-0.5 flex items-center gap-0.5 text-[10px]",
            ) if face_overlays else None,
            nav_prev,
            nav_next,
            cls="relative inline-block max-w-full"
        ),
        # Photo info
        Div(
            Div(
                P(
                    photo["filename"],
                    cls="text-slate-300 text-sm font-data font-medium"
                ),
                nav_counter,
                Span(
                    share_button(photo_id, style="link", label="Share"),
                    A(
                        "Open",
                        href=f"/photo/{photo_id}",
                        cls="text-xs text-indigo-400 hover:text-indigo-300 underline",
                        target="_blank",
                        rel="noopener",
                    ),
                    cls="ml-auto flex items-center gap-3",
                ),
                cls="flex items-center gap-2"
            ),
            P(
                f"{len(photo['faces'])} face{'s' if len(photo['faces']) != 1 else ''} detected",
                cls="text-slate-400 text-sm"
            ),
            P(
                f"{width} x {height} px" if has_dimensions else "Dimensions unavailable",
                cls="text-slate-500 text-xs font-data"
            ),
            P(
                "(Face overlays require cached dimensions)",
                cls="text-slate-600 text-xs italic"
            ) if not has_dimensions and photo["faces"] else None,
            # Collection / Source / Source URL display
            Div(
                P(
                    Span("Collection: ", cls="text-slate-500"),
                    Span(photo.get("collection", ""), cls="text-slate-300"),
                    cls="text-xs"
                ) if photo.get("collection") else None,
                P(
                    Span("Source: ", cls="text-slate-500"),
                    Span(photo.get("source", ""), cls="text-slate-300"),
                    cls="text-xs"
                ) if photo.get("source") else None,
                P(
                    Span("Source URL: ", cls="text-slate-500"),
                    A(photo.get("source_url", ""), href=photo.get("source_url", ""),
                      target="_blank", rel="noopener",
                      cls="text-indigo-400 hover:text-indigo-300 underline"),
                    cls="text-xs"
                ) if photo.get("source_url") else None,
                cls="mt-1 space-y-0.5"
            ) if photo.get("collection") or photo.get("source") or photo.get("source_url") else None,
            # Stored photo metadata (BE-012)
            _photo_metadata_display(photo),
            # Photo annotations display + form (AN-002–AN-006)
            _photo_annotations_section(photo_id, is_admin),
            # AI Analysis metadata panel (date estimate, scene, tags, evidence)
            _build_ai_analysis_section(photo_id, is_admin),
            cls="mt-4"
        ),
        nav_keyboard_script,
        cls="photo-viewer p-2 sm:p-4 overflow-x-hidden"
    )

    if is_partial:
        return (content,)

    # Full page with styling
    style = Style("""
        .face-overlay {
            box-sizing: border-box;
        }
        .face-overlay:hover {
            z-index: 10;
        }
    """)

    return (
        Title(f"Photo - {photo['filename']}"),
        style,
        Main(
            # Back button
            A(
                "< Back to Workstation",
                href="/",
                cls="text-slate-400 hover:text-slate-300 mb-4 inline-block"
            ),
            H1(
                "Photo Context",
                cls="text-2xl font-serif font-bold text-white mb-4"
            ),
            content,
            cls="p-4 md:p-8 max-w-6xl mx-auto bg-slate-900 min-h-screen"
        ),
    )


def public_person_page(
    person_id: str,
    view: str = "faces",
    user=None,
    is_admin: bool = False,
) -> tuple:
    """
    Build the public shareable person page.

    Shows all photos of a specific identified person — the page you share
    when you want to say "Look at all these photos of Aunt Selma!"
    No authentication required.
    """
    registry = load_registry()
    try:
        identity = registry.get_identity(person_id)
    except KeyError:
        identity = None

    # Check for merged identities
    if identity and identity.get("merged_into"):
        identity = None

    if not identity:
        style_404 = Style("html, body { margin: 0; } body { background-color: #0f172a; }")
        return (
            Title("Person Not Found - Rhodesli"),
            style_404,
            Main(
                Nav(
                    Div(
                        A(Span("Rhodesli", cls="text-xl font-bold text-white"), href="/", cls="hover:opacity-90"),
                        cls="max-w-5xl mx-auto px-6 flex items-center justify-between h-16"
                    ),
                    cls="bg-slate-900/80 backdrop-blur-md border-b border-slate-800"
                ),
                Div(
                    Div(
                        Span("404", cls="text-6xl font-bold text-slate-700 block mb-4"),
                        H1("Person not found", cls="text-2xl font-serif font-bold text-white mb-3"),
                        P("This person hasn't been identified in our archive yet.", cls="text-slate-400 mb-8"),
                        A("Explore the Archive", href="/?section=photos",
                          cls="inline-block px-6 py-3 bg-indigo-600 text-white font-medium rounded-lg hover:bg-indigo-500 transition-colors"),
                        cls="text-center"
                    ),
                    cls="flex items-center justify-center min-h-[60vh]"
                ),
                cls="min-h-screen bg-slate-900"
            ),
        )

    raw_name = ensure_utf8_display(identity.get("name"))
    display_name = raw_name or f"Person {person_id[:8]}"
    state = identity.get("state", "INBOX")
    is_confirmed = state == "CONFIRMED" and not display_name.startswith("Unidentified")
    from urllib.parse import quote as _url_quote

    # Get all face IDs for this person
    anchor_ids = identity.get("anchor_ids", [])
    candidate_ids = identity.get("candidate_ids", [])
    all_face_ids = anchor_ids + candidate_ids
    face_id_strings = [f if isinstance(f, str) else f.get("face_id", "") for f in all_face_ids]

    # Get photos where this person appears
    photo_reg = load_photo_registry()
    photo_ids = photo_reg.get_photos_for_faces(face_id_strings)
    crop_files = get_crop_files()

    # Get best face crop for avatar
    best_face_id = get_best_face_id(all_face_ids)
    avatar_url = resolve_face_image_url(best_face_id, crop_files) if best_face_id and crop_files else None

    # Get collections this person appears in
    collections = set()
    for pid in photo_ids:
        pm = get_photo_metadata(pid)
        if pm and pm.get("collection"):
            collections.add(pm["collection"])

    # --- Build face gallery items ---
    face_gallery_items = []
    for face_id_entry in all_face_ids:
        fid = face_id_entry if isinstance(face_id_entry, str) else face_id_entry.get("face_id", "")
        crop_url = resolve_face_image_url(fid, crop_files) if crop_files else None
        if not crop_url:
            continue
        # Find the photo for this face
        face_photo_id = get_photo_id_for_face(fid)
        face_photo = get_photo_metadata(face_photo_id) if face_photo_id else None
        source_label = ""
        if face_photo:
            source_label = face_photo.get("collection", "") or face_photo.get("source", "") or ""

        face_gallery_items.append(
            A(
                Img(
                    src=crop_url,
                    alt=f"{display_name}",
                    cls="w-28 h-28 sm:w-32 sm:h-32 rounded-lg object-cover border-2 border-slate-700 hover:border-emerald-500/50 transition-colors",
                    onerror="this.style.display='none'",
                ),
                P(source_label, cls="text-[10px] text-slate-500 mt-1 text-center truncate max-w-[120px]") if source_label else None,
                href=f"/photo/{face_photo_id}" if face_photo_id else "#",
                cls="flex flex-col items-center group",
                title=f"View photo of {display_name}",
            )
        )

    # --- Build photo gallery items ---
    photo_gallery_items = []
    for pid in sorted(photo_ids):
        pm = get_photo_metadata(pid)
        if not pm:
            continue
        filename = pm["filename"]
        collection_label = pm.get("collection", "") or ""
        photo_gallery_items.append(
            A(
                Div(
                    Img(
                        src=photo_url(filename),
                        alt=f"Photo featuring {display_name}",
                        cls="w-full h-48 sm:h-56 object-cover rounded-lg",
                        loading="lazy",
                    ),
                    cls="relative overflow-hidden rounded-lg",
                ),
                P(collection_label, cls="text-[10px] text-slate-500 mt-1 text-center truncate") if collection_label else None,
                href=f"/photo/{pid}",
                cls="flex flex-col group",
                title=f"View photo of {display_name}",
            )
        )

    # --- Build "Appears with" section ---
    appears_with = []
    for pid in photo_ids:
        pm = get_photo_metadata(pid)
        if not pm:
            continue
        for face_data in pm.get("faces", []):
            other_fid = face_data.get("face_id", "")
            if other_fid in face_id_strings:
                continue  # skip self
            other_identity = get_identity_for_face(registry, other_fid)
            if not other_identity:
                continue
            other_id = other_identity["identity_id"]
            other_state = other_identity.get("state", "")
            other_name = ensure_utf8_display(other_identity.get("name", ""))
            if other_state != "CONFIRMED" or other_name.startswith("Unidentified"):
                continue
            if other_id == person_id:
                continue
            # Avoid duplicates
            if any(a["id"] == other_id for a in appears_with):
                continue
            other_best_face = get_best_face_id(
                other_identity.get("anchor_ids", []) + other_identity.get("candidate_ids", [])
            )
            other_crop = resolve_face_image_url(other_best_face, crop_files) if other_best_face and crop_files else None
            appears_with.append({
                "id": other_id,
                "name": other_name,
                "crop_url": other_crop,
            })

    appears_with_section = None
    if appears_with:
        companion_cards = []
        shown = appears_with[:8]
        for companion in shown:
            crop_el = Img(
                src=companion["crop_url"],
                alt=companion["name"],
                cls="w-12 h-12 rounded-full object-cover border-2 border-slate-700",
                onerror="this.style.display='none'",
            ) if companion["crop_url"] else Div(
                Span("?", cls="text-lg text-slate-500"),
                cls="w-12 h-12 rounded-full bg-slate-800 border-2 border-slate-700 flex items-center justify-center",
            )
            companion_cards.append(
                A(
                    crop_el,
                    Span(companion["name"], cls="text-xs text-slate-400 mt-1 text-center truncate max-w-[80px]"),
                    href=f"/person/{companion['id']}",
                    cls="flex flex-col items-center gap-1 hover:opacity-80 transition-opacity",
                    title=f"View {companion['name']}",
                )
            )
        if len(appears_with) > 8:
            companion_cards.append(
                Span(f"+{len(appears_with) - 8} more", cls="text-xs text-slate-500 self-center ml-2")
            )
        appears_with_section = Div(
            H3("Often appears with", cls="text-lg font-serif font-semibold text-slate-300 mb-4"),
            Div(*companion_cards, cls="flex flex-wrap gap-4 items-start"),
            cls="mt-10 pt-8 border-t border-slate-800",
        )

    # --- Family relationships (from GEDCOM import) ---
    family_section = None
    try:
        rel_graph = _load_relationship_graph()
        if rel_graph.get("relationships"):
            from rhodesli_ml.graph.relationship_graph import get_relationships_for_person
            rels = get_relationships_for_person(rel_graph, person_id)

            family_items = []
            rel_labels = {
                "parents": "Parents",
                "children": "Children",
                "spouses": "Spouse",
                "siblings": "Siblings",
            }
            for rel_type, label in rel_labels.items():
                rel_ids = rels.get(rel_type, [])
                if not rel_ids:
                    continue
                names = []
                for rid in rel_ids:
                    try:
                        r_ident = registry.get_identity(rid)
                        r_name = ensure_utf8_display(r_ident.get("name", "Unknown"))
                        names.append(A(r_name, href=f"/person/{rid}",
                                       cls="text-indigo-400 hover:text-indigo-300 underline"))
                    except KeyError:
                        continue
                if names:
                    separator = []
                    for i, n in enumerate(names):
                        if i > 0:
                            separator.append(Span(", ", cls="text-slate-500"))
                        separator.append(n)
                    family_items.append(Div(
                        Span(f"{label}: ", cls="text-slate-400 text-sm font-medium w-20 inline-block"),
                        *separator,
                        cls="text-sm py-1"
                    ))

            if family_items:
                family_items.append(
                    A("View in Family Tree →", href=f"/tree?person={person_id}",
                      cls="text-xs text-indigo-400 hover:text-indigo-300 mt-3 inline-block",
                      data_testid="family-tree-link"),
                )
                family_section = Div(
                    H3("Family", cls="text-lg font-serif font-semibold text-slate-300 mb-4"),
                    *family_items,
                    cls="mt-10 pt-8 border-t border-slate-800",
                )
    except Exception:
        pass  # Graceful degradation if graph not available

    # --- Closest connections (from social graph) ---
    connections_section = None
    try:
        from rhodesli_ml.graph.social_graph import build_social_graph, get_closest_connections
        social = build_social_graph(
            _load_relationship_graph(),
            json.loads((data_path / "co_occurrence_graph.json").read_text(encoding="utf-8")) if (data_path / "co_occurrence_graph.json").exists() else {"edges": []},
        )
        closest = get_closest_connections(social, person_id, n=5)
        if closest:
            conn_items = []
            for conn in closest:
                try:
                    c_ident = registry.get_identity(conn["person_id"])
                    c_name = ensure_utf8_display(c_ident.get("name", "Unknown"))
                except (KeyError, TypeError):
                    continue
                edge_type = conn.get("edge_type", "indirect")
                if edge_type == "spouse_of":
                    badge = Span("Spouse", cls="text-[10px] px-1.5 py-0.5 rounded bg-amber-900/40 text-amber-400 ml-2")
                elif edge_type in ("parent_child", "child_of"):
                    badge = Span("Family", cls="text-[10px] px-1.5 py-0.5 rounded bg-amber-900/40 text-amber-400 ml-2")
                elif edge_type == "sibling_of":
                    badge = Span("Sibling", cls="text-[10px] px-1.5 py-0.5 rounded bg-amber-900/40 text-amber-400 ml-2")
                elif edge_type == "photographed_with":
                    photo_ct = conn.get("photo_count", 0)
                    photo_label = f"{photo_ct} shared photo{'s' if photo_ct != 1 else ''}" if photo_ct else "Photos"
                    badge = Span(photo_label, cls="text-[10px] px-1.5 py-0.5 rounded bg-blue-900/40 text-blue-400 ml-2")
                else:
                    steps = conn.get("path_length", 0)
                    badge = Span(f"{steps} step{'s' if steps != 1 else ''}", cls="text-[10px] px-1.5 py-0.5 rounded bg-slate-800 text-slate-400 ml-2")
                conn_items.append(Div(
                    A(c_name, href=f"/person/{conn['person_id']}", cls="text-indigo-400 hover:text-indigo-300 text-sm"),
                    badge,
                    cls="flex items-center py-1",
                ))
            if conn_items:
                conn_items.append(Div(
                    A("Find connections →", href=f"/connect?person_a={person_id}", cls="text-xs text-indigo-400 hover:text-indigo-300 mr-4"),
                    A("View in Tree →", href=f"/tree?person={person_id}", cls="text-xs text-indigo-400 hover:text-indigo-300"),
                    cls="mt-2 flex gap-4",
                ))
                connections_section = Div(
                    H3("Connections", cls="text-lg font-serif font-semibold text-slate-300 mb-4"),
                    *conn_items,
                    cls="mt-10 pt-8 border-t border-slate-800",
                    data_testid="connections-section",
                )
    except Exception:
        pass  # Graceful degradation

    # --- Approved annotations (bio, story, etc.) ---
    annotations_section = None
    try:
        annotations_data = _load_annotations()
        approved_anns = [
            ann for ann in annotations_data.get("annotations", {}).values()
            if ann.get("target_type") == "identity"
            and ann.get("target_id") == person_id
            and ann.get("status") == "approved"
        ]
        if approved_anns:
            type_labels = {"bio": "Bio", "relationship": "Relationship", "story": "Story",
                           "name_suggestion": "Name", "caption": "Caption"}
            # Deduplicate by value
            seen_values = set()
            unique_anns = []
            for ann in sorted(approved_anns, key=lambda a: a.get("submitted_at", "")):
                if ann["value"] not in seen_values:
                    seen_values.add(ann["value"])
                    unique_anns.append(ann)
            ann_items = []
            for ann in unique_anns:
                label = type_labels.get(ann["type"], ann["type"].title())
                ann_items.append(Div(
                    Span(f"{label}", cls="text-xs text-slate-500 font-medium block mb-0.5"),
                    P(f"\u201c{ann['value']}\u201d", cls="text-slate-300 text-sm italic"),
                    cls="py-2",
                ))
            annotations_section = Div(
                H3("Community Notes", cls="text-lg font-serif font-semibold text-slate-300 mb-4"),
                *ann_items,
                cls="mt-10 pt-8 border-t border-slate-800",
            )
    except Exception:
        pass

    # --- Open Graph meta tags ---
    og_title = f"{display_name} — Rhodesli Heritage Archive"
    photo_count = len(photo_ids)
    collection_count = len(collections)
    if photo_count > 0:
        og_description = f"Appears in {photo_count} {'photo' if photo_count == 1 else 'photos'} across {collection_count} {'collection' if collection_count == 1 else 'collections'}. Help identify more photos of {display_name}."
    else:
        og_description = f"{display_name} in the Rhodesli Heritage Archive. Explore photographs from the Jewish community of Rhodes."

    og_image_url = avatar_url or ""
    if og_image_url and not og_image_url.startswith("http"):
        og_image_url = f"{SITE_URL}{og_image_url}"
    og_page_url = f"{SITE_URL}/person/{person_id}"

    og_meta_tags = (
        Meta(property="og:title", content=og_title),
        Meta(property="og:description", content=og_description),
        Meta(property="og:image", content=og_image_url),
        Meta(property="og:url", content=og_page_url),
        Meta(property="og:type", content="profile"),
        Meta(property="og:site_name", content="Rhodesli — Heritage Photo Archive"),
        Meta(name="twitter:card", content="summary"),
        Meta(name="twitter:title", content=og_title),
        Meta(name="twitter:description", content=og_description),
        Meta(name="twitter:image", content=og_image_url),
        Meta(name="description", content=og_description),
    )

    # --- Navigation ---
    nav_links = _public_nav_links(active="people", user=user)

    # --- View toggle ---
    faces_active = view != "photos"
    toggle = Div(
        A(
            "Faces",
            href=f"/person/{person_id}?view=faces",
            cls="px-4 py-2 text-sm font-medium rounded-lg transition-colors " + (
                "bg-indigo-600 text-white" if faces_active else "text-slate-400 hover:text-white hover:bg-slate-700/50"
            ),
        ),
        A(
            "Photos",
            href=f"/person/{person_id}?view=photos",
            cls="px-4 py-2 text-sm font-medium rounded-lg transition-colors " + (
                "bg-indigo-600 text-white" if not faces_active else "text-slate-400 hover:text-white hover:bg-slate-700/50"
            ),
        ),
        cls="flex gap-1 bg-slate-800/50 p-1 rounded-xl",
    )

    # --- Gallery content ---
    gallery_items = face_gallery_items if faces_active else photo_gallery_items
    gallery_count = len(gallery_items)
    gallery_grid_cls = "grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-3 sm:gap-4" if faces_active else "grid grid-cols-2 sm:grid-cols-3 gap-4"

    if gallery_items:
        gallery_content = Div(*gallery_items, cls=gallery_grid_cls)
    else:
        gallery_content = Div(
            P("No photos available yet.", cls="text-slate-500 text-center py-8"),
        )

    # --- Status badge ---
    if is_confirmed:
        badge = Span("Identified", cls="text-xs text-emerald-400 bg-emerald-500/10 px-2.5 py-1 rounded-full border border-emerald-500/20")
    else:
        badge = Span("Under Review", cls="text-xs text-amber-400 bg-amber-500/10 px-2.5 py-1 rounded-full border border-amber-500/20")

    # --- Birth year (Gatekeeper: public sees confirmed only, admin sees ML estimates) ---
    # Public: only confirmed metadata birth years
    person_birth_year, by_source, by_confidence = _get_birth_year(person_id, identity, include_unreviewed=False)
    birth_year_line = None
    if person_birth_year:
        birth_year_line = f"Born {person_birth_year}"

    # Admin: also check for pending ML suggestion
    ml_suggestion_card = None
    if is_admin and not person_birth_year:
        _admin_by, _admin_src, _admin_conf = _get_birth_year(person_id, identity, include_unreviewed=True)
        if _admin_by and _admin_src == "ml_inferred":
            estimates = _load_birth_year_estimates()
            est = estimates.get(person_id, {})
            est_range = est.get("birth_year_range", [])
            range_str = f"{est_range[0]}\u2013{est_range[1]}" if len(est_range) == 2 else ""
            n_photos = est.get("n_with_age_data", 0)
            conf_label = (_admin_conf or "low").capitalize()
            conf_cls = {
                "High": "text-emerald-400 bg-emerald-500/10 border-emerald-500/20",
                "Medium": "text-amber-400 bg-amber-500/10 border-amber-500/20",
                "Low": "text-slate-400 bg-slate-500/10 border-slate-500/20",
            }.get(conf_label, "text-slate-400 bg-slate-500/10 border-slate-500/20")
            ml_suggestion_card = Div(
                Div(
                    Span("\u2728 ", cls="mr-1"),
                    Span("ML Estimate", cls="text-xs font-semibold text-indigo-300"),
                    cls="mb-2",
                ),
                Div(
                    Span(f"Born c. {_admin_by}", cls="text-white text-sm font-medium"),
                    Span(f" ({range_str})" if range_str else "", cls="text-slate-400 text-xs"),
                    cls="mb-1",
                ),
                Div(
                    Span(conf_label, cls=f"text-xs px-2 py-0.5 rounded-full border {conf_cls} mr-2"),
                    Span(f"Based on {n_photos} photo{'s' if n_photos != 1 else ''}", cls="text-xs text-slate-500"),
                    cls="mb-3",
                ),
                Div(
                    Button("Accept", type="button",
                           hx_post=f"/api/ml-review/birth-year/{person_id}/accept",
                           hx_target=f"#ml-suggestion-{person_id}",
                           hx_swap="outerHTML",
                           hx_vals=json.dumps({"birth_year": _admin_by}),
                           cls="px-3 py-1 bg-emerald-600 hover:bg-emerald-500 text-white text-xs rounded"),
                    Button("Edit & Accept", type="button",
                           onclick=f"document.getElementById('ml-edit-{person_id}').classList.toggle('hidden')",
                           cls="px-3 py-1 bg-indigo-600 hover:bg-indigo-500 text-white text-xs rounded"),
                    Button("Reject", type="button",
                           hx_post=f"/api/ml-review/birth-year/{person_id}/reject",
                           hx_target=f"#ml-suggestion-{person_id}",
                           hx_swap="outerHTML",
                           hx_confirm="Reject this ML birth year estimate?",
                           cls="px-3 py-1 bg-red-600/80 hover:bg-red-500 text-white text-xs rounded"),
                    cls="flex gap-2 flex-wrap",
                ),
                # Inline edit form (hidden by default)
                Div(
                    Form(
                        Div(
                            Label("Birth year:", cls="text-xs text-slate-400"),
                            Input(type="number", name="birth_year", value=str(_admin_by),
                                  cls="bg-slate-700 border border-slate-600 rounded px-2 py-1 text-xs text-white w-24"),
                            cls="flex items-center gap-2",
                        ),
                        Div(
                            Label("Source:", cls="text-xs text-slate-400"),
                            Input(type="text", name="source_detail", placeholder="e.g. Italian census 1903",
                                  cls="bg-slate-700 border border-slate-600 rounded px-2 py-1 text-xs text-white w-48"),
                            cls="flex items-center gap-2 mt-2",
                        ),
                        Button("Save", type="submit",
                               cls="mt-2 px-3 py-1 bg-emerald-600 hover:bg-emerald-500 text-white text-xs rounded"),
                        hx_post=f"/api/ml-review/birth-year/{person_id}/accept",
                        hx_target=f"#ml-suggestion-{person_id}",
                        hx_swap="outerHTML",
                    ),
                    id=f"ml-edit-{person_id}",
                    cls="hidden mt-3 pt-3 border-t border-slate-700/50",
                ),
                id=f"ml-suggestion-{person_id}",
                cls="bg-indigo-500/5 border border-indigo-500/20 rounded-lg p-4 mt-3 mb-3 text-left max-w-sm mx-auto",
                data_testid="ml-suggestion-card",
            )

    # --- Stats line ---
    stats_parts = []
    if birth_year_line:
        stats_parts.append(birth_year_line)
    if photo_count > 0:
        stats_parts.append(f"Appears in {photo_count} {'photo' if photo_count == 1 else 'photos'}")
    if collection_count > 0:
        stats_parts.append(f"{collection_count} {'collection' if collection_count == 1 else 'collections'}")
    stats_line = " · ".join(stats_parts) if stats_parts else None

    # --- Life details section (show even when empty, with contribution prompts) ---
    life_detail_items = []
    death_year = identity.get("death_year")
    birth_place = identity.get("birth_place")
    death_place = identity.get("death_place")
    maiden_name = identity.get("maiden_name")

    def _life_detail_row(label, value, prompt_text):
        if value:
            return Div(
                Span(f"{label}: ", cls="text-slate-500 text-sm w-20 inline-block"),
                Span(str(value), cls="text-slate-300 text-sm"),
                cls="py-0.5",
            )
        else:
            return Div(
                Span(f"{label}: ", cls="text-slate-500 text-sm w-20 inline-block"),
                Span("Unknown", cls="text-slate-600 text-sm italic"),
                A(f" — {prompt_text}", href=f"/identify/{person_id}" if not is_confirmed else "#",
                  cls="text-indigo-400/60 hover:text-indigo-300 text-xs ml-1",
                  data_action="share-photo" if is_confirmed else None,
                  data_share_url=f"{SITE_URL}/person/{person_id}" if is_confirmed else None,
                  data_share_title=f"Help us learn more about {display_name}" if is_confirmed else None,
                ) if not is_admin else None,
                cls="py-0.5",
            )

    # Only show life details section if person is identified or under active review
    if is_confirmed or identity.get("state") in ("PROPOSED", "INBOX"):
        if not person_birth_year:
            life_detail_items.append(_life_detail_row("Born", None, "Do you know?"))
        if not death_year:
            life_detail_items.append(_life_detail_row("Died", None, "Do you know?"))
        if birth_place or not is_confirmed:
            life_detail_items.append(_life_detail_row("From", birth_place, "Can you help?"))
        elif not birth_place:
            life_detail_items.append(_life_detail_row("From", None, "Can you help?"))
        if death_place:
            life_detail_items.append(_life_detail_row("Resting", death_place, ""))
        if maiden_name:
            life_detail_items.append(Div(
                Span("Maiden: ", cls="text-slate-500 text-sm w-20 inline-block"),
                Span(maiden_name, cls="text-slate-300 text-sm"),
                cls="py-0.5",
            ))

    # Only show section if there are empty fields to prompt about (or filled fields to display)
    life_details_section = None
    if life_detail_items:
        life_details_section = Div(
            *life_detail_items,
            cls="text-center mb-4",
            data_testid="life-details",
        )

    # --- Page style ---
    page_style = Style("""
        html, body { margin: 0; }
        body { background-color: #0f172a; }
    """)

    # --- Share button ---
    share_btn = Button(
        NotStr('<svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4 mr-1.5 inline" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"/></svg>'),
        "Share",
        cls="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 text-white text-sm rounded-lg transition-colors inline-flex items-center",
        type="button",
        data_action="share-photo",
        data_share_url=og_page_url,
    )

    return (
        Title(f"{display_name} — Rhodesli Heritage Archive"),
        *og_meta_tags,
        page_style,
        Main(
            # Top navigation bar
            Nav(
                Div(
                    A(Span("Rhodesli", cls="text-xl font-bold text-white"), href="/", cls="hover:opacity-90"),
                    Div(
                        *nav_links,
                        A("Explore More Photos", href="/photos",
                          cls="text-indigo-400 hover:text-indigo-300 text-sm font-medium transition-colors ml-4"),
                        cls="hidden sm:flex items-center gap-6"
                    ),
                    cls="max-w-5xl mx-auto px-6 flex items-center justify-between h-16"
                ),
                cls="bg-slate-900/80 backdrop-blur-md border-b border-slate-800 sticky top-0 z-50"
            ),

            # Hero section
            Section(
                Div(
                    # Avatar
                    Div(
                        Img(
                            src=avatar_url,
                            alt=display_name,
                            cls="w-32 h-32 rounded-full object-cover border-4 border-emerald-500/30 shadow-lg shadow-emerald-500/10",
                            onerror="this.style.display='none'",
                        ) if avatar_url else Div(
                            Span(display_name[0].upper() if display_name else "?", cls="text-4xl font-serif text-slate-400"),
                            cls="w-32 h-32 rounded-full bg-slate-800 border-4 border-slate-700 flex items-center justify-center",
                        ),
                        cls="flex justify-center mb-6",
                    ),
                    # Name + badge
                    Div(
                        H1(display_name, cls="text-3xl sm:text-4xl font-serif font-bold text-white mb-3"),
                        badge,
                        cls="text-center mb-3",
                    ),
                    # Stats line
                    P(stats_line, cls="text-slate-400 text-sm text-center mb-4") if stats_line else None,
                    # Life details (birth/death/place with prompts for unknowns)
                    life_details_section,
                    # Admin: ML birth year suggestion card (Gatekeeper pattern)
                    ml_suggestion_card,
                    # Admin: inline metadata editing
                    Div(
                        Form(
                            Div(
                                Div(
                                    Label("Birth year:", cls="text-xs text-slate-500"),
                                    Input(type="number", name="birth_year",
                                          value=str(person_birth_year) if person_birth_year else "",
                                          placeholder="e.g. 1905",
                                          cls="bg-slate-800 border border-slate-600 rounded px-2 py-0.5 text-xs text-white w-24"),
                                    cls="flex items-center gap-1",
                                ),
                                Div(
                                    Label("Death year:", cls="text-xs text-slate-500"),
                                    Input(type="number", name="death_year",
                                          value=str(identity.get("death_year", "")) if identity.get("death_year") else "",
                                          placeholder="e.g. 1985",
                                          cls="bg-slate-800 border border-slate-600 rounded px-2 py-0.5 text-xs text-white w-24"),
                                    cls="flex items-center gap-1",
                                ),
                                cls="flex flex-wrap gap-3 mb-1",
                            ),
                            Div(
                                Div(
                                    Label("Birth place:", cls="text-xs text-slate-500"),
                                    Input(type="text", name="birth_place",
                                          value=identity.get("birth_place", ""),
                                          placeholder="e.g. Rhodes, Greece",
                                          list="places-list",
                                          cls="bg-slate-800 border border-slate-600 rounded px-2 py-0.5 text-xs text-white w-40"),
                                    cls="flex items-center gap-1",
                                ),
                                Div(
                                    Label("Death place:", cls="text-xs text-slate-500"),
                                    Input(type="text", name="death_place",
                                          value=identity.get("death_place", ""),
                                          placeholder="e.g. New York, NY",
                                          list="places-list",
                                          cls="bg-slate-800 border border-slate-600 rounded px-2 py-0.5 text-xs text-white w-40"),
                                    cls="flex items-center gap-1",
                                ),
                                cls="flex flex-wrap gap-3 mb-1",
                            ),
                            Div(
                                Label("Maiden name:", cls="text-xs text-slate-500"),
                                Input(type="text", name="maiden_name",
                                      value=identity.get("maiden_name", ""),
                                      cls="bg-slate-800 border border-slate-600 rounded px-2 py-0.5 text-xs text-white w-40"),
                                cls="flex items-center gap-1 mb-2",
                            ),
                            Button("Save Metadata", type="submit",
                                   cls="px-3 py-1 bg-indigo-600 hover:bg-indigo-500 text-white text-xs rounded"),
                            Div(id=f"metadata-status-{person_id}", cls="inline ml-2"),
                            hx_post=f"/api/identity/{person_id}/metadata",
                            hx_target=f"#metadata-status-{person_id}",
                            hx_swap="innerHTML",
                        ),
                        _place_datalist(),
                        cls="mt-3 mb-4 bg-slate-800/50 rounded-lg p-3 border border-slate-700/50 text-left",
                        data_testid="person-metadata-edit",
                    ) if is_admin and is_confirmed else None,
                    # Action buttons
                    Div(
                        share_btn,
                        cls="flex justify-center gap-3 mb-4",
                    ),
                    # Cross-feature action bar
                    Div(
                        A("Timeline", href=f"/timeline?person={person_id}",
                          cls="px-3 py-1.5 text-xs rounded-full bg-slate-800/60 text-slate-300 hover:text-white border border-slate-700/50 hover:border-indigo-500/50 transition-colors"),
                        A("Map", href=f"/map?person={person_id}",
                          cls="px-3 py-1.5 text-xs rounded-full bg-slate-800/60 text-slate-300 hover:text-white border border-slate-700/50 hover:border-indigo-500/50 transition-colors"),
                        A("Family Tree", href=f"/tree?person={person_id}",
                          cls="px-3 py-1.5 text-xs rounded-full bg-slate-800/60 text-slate-300 hover:text-white border border-slate-700/50 hover:border-indigo-500/50 transition-colors"),
                        A("Connections", href=f"/connect?person_a={person_id}",
                          cls="px-3 py-1.5 text-xs rounded-full bg-slate-800/60 text-slate-300 hover:text-white border border-slate-700/50 hover:border-indigo-500/50 transition-colors"),
                        cls="flex flex-wrap justify-center gap-2 mb-8",
                        data_testid="person-action-bar",
                    ),
                    cls="max-w-3xl mx-auto pt-12 pb-8 px-6",
                ),
                cls="border-b border-slate-800",
            ),

            # Gallery section
            Section(
                Div(
                    # Section header with toggle
                    Div(
                        H2(
                            f"{'Faces' if faces_active else 'Photos'} of {display_name}",
                            cls="text-xl font-serif font-semibold text-white",
                        ),
                        Div(
                            toggle,
                            Span(f"{gallery_count} {'face' if gallery_count == 1 else 'faces'}" if faces_active else f"{gallery_count} {'photo' if gallery_count == 1 else 'photos'}", cls="text-xs text-slate-500 ml-3 self-center"),
                            cls="flex items-center",
                        ),
                        cls="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4 mb-6",
                    ),
                    gallery_content,

                    # Family relationships (from GEDCOM)
                    family_section if family_section else None,

                    # Closest connections (social graph)
                    connections_section if connections_section else None,

                    # Appears with section
                    appears_with_section if appears_with_section else None,

                    # Approved community annotations
                    annotations_section if annotations_section else None,

                    # Comments section
                    _person_comments_section(person_id, is_admin),

                    cls="max-w-5xl mx-auto px-6 py-10",
                ),
            ),

            # CTA section
            Section(
                Div(
                    H3(f"Do you have more photos of {display_name}?", cls="text-lg font-serif text-white mb-2"),
                    P("Upload your family photos to help us build a more complete picture.", cls="text-slate-400 text-sm mb-4"),
                    Div(
                        A("Upload Photos", href="/?section=upload",
                          cls="inline-block px-5 py-2.5 bg-amber-600 hover:bg-amber-500 text-white text-sm font-medium rounded-lg transition-colors"),
                        A("Help Identify", href=f"/identify/{person_id}",
                          cls="inline-block px-5 py-2.5 bg-indigo-600 hover:bg-indigo-500 text-white text-sm font-medium rounded-lg transition-colors") if not is_confirmed else None,
                        cls="flex flex-wrap justify-center gap-3",
                    ),
                    cls="text-center",
                ),
                cls="py-12 border-t border-slate-800",
            ),

            # Footer
            Div(
                Div(
                    P("Rhodesli Heritage Archive", cls="text-xs text-slate-500 mb-1 font-serif"),
                    P("Preserving the memory of the Jewish community of Rhodes", cls="text-[10px] text-slate-600 italic"),
                    Div(
                        A("Photos", href="/photos", cls="text-xs text-slate-500 hover:text-slate-300"),
                        Span("·", cls="text-slate-700"),
                        A("People", href="/people", cls="text-xs text-slate-500 hover:text-slate-300"),
                        cls="flex items-center gap-2 mt-2"
                    ),
                    cls="max-w-5xl mx-auto px-6 flex flex-col items-center"
                ),
                cls="py-8 border-t border-slate-800",
            ),

            # Share JS (standalone page uses reusable _share_script)
            _share_script(),
            Script("""
                document.addEventListener('click', function(e) {
                    var toggleBtn = e.target.closest('[data-action="toggle-date-correction"]');
                    if (toggleBtn) {
                        var photoId = toggleBtn.getAttribute('data-photo-id') || toggleBtn.closest('[data-photo-id]')?.getAttribute('data-photo-id');
                        if (!photoId) {
                            var form = document.querySelector('[id^="date-correction-form-"]');
                            if (form) form.classList.toggle('hidden');
                            return;
                        }
                        var formId = 'date-correction-form-' + photoId.substring(0, 8);
                        var form = document.getElementById(formId);
                        if (form) form.classList.toggle('hidden');
                        return;
                    }
                });
            """),
            cls="min-h-screen bg-slate-900",
        ),
    )


@rt("/person/{person_id}")
def get(person_id: str, view: str = "faces", sess=None):
    """
    Public shareable person page showing all photos of a specific person.

    No authentication required — anyone can view.

    Query params:
    - view: "faces" (default) or "photos" — gallery view mode
    """
    user = get_current_user(sess or {}) if is_auth_enabled() else None
    user_is_admin = (user.is_admin if user else False) if is_auth_enabled() else True
    return public_person_page(person_id, view=view, user=user, is_admin=user_is_admin)


# --- Shareable Identification Pages ---
# These are the crowdsourcing mechanism — URLs shared in Facebook groups,
# family chats, and emails to help identify unknown people in photos.
# No login required. Responses saved for admin review.


def _share_script():
    """Reusable share script for standalone public pages."""
    return Script("""
        function _sharePhotoUrl(url, shareTitle, shareText) {
            _copyAndToast(url);
            var isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            if (isMobile && navigator.share) {
                var shareData = { url: url };
                if (shareTitle) shareData.title = shareTitle;
                if (shareText) shareData.text = shareText;
                navigator.share(shareData).catch(function() {});
            }
        }
        function _copyAndToast(url) {
            if (navigator.clipboard) {
                navigator.clipboard.writeText(url).then(function() {
                    _showShareToast('Link copied!');
                }).catch(function() { _showShareToast('Could not copy link'); });
            } else {
                var input = document.createElement('input');
                input.value = url;
                document.body.appendChild(input);
                input.select();
                document.execCommand('copy');
                document.body.removeChild(input);
                _showShareToast('Link copied!');
            }
        }
        function _showShareToast(message) {
            var existing = document.getElementById('share-toast');
            if (existing) existing.remove();
            var toast = document.createElement('div');
            toast.id = 'share-toast';
            toast.textContent = message;
            toast.style.cssText = 'position:fixed;bottom:24px;left:50%;transform:translateX(-50%);background:#334155;color:#e2e8f0;padding:10px 20px;border-radius:8px;font-size:14px;z-index:9999;transition:opacity 0.3s;box-shadow:0 4px 12px rgba(0,0,0,0.3);';
            document.body.appendChild(toast);
            setTimeout(function() { toast.style.opacity = '0'; }, 2000);
            setTimeout(function() { toast.remove(); }, 2500);
        }
        document.addEventListener('click', function(e) {
            var shareBtn = e.target.closest('[data-action="share-photo"]');
            if (shareBtn) {
                var url = shareBtn.getAttribute('data-share-url') || window.location.href;
                var shareTitle = shareBtn.getAttribute('data-share-title') || '';
                var shareText = shareBtn.getAttribute('data-share-text') || '';
                _sharePhotoUrl(url, shareTitle, shareText);
            }
        });
    """)


_identification_responses_cache = None

def _load_identification_responses() -> dict:
    """Load identification responses from data file."""
    global _identification_responses_cache
    if _identification_responses_cache is not None:
        return _identification_responses_cache
    resp_path = data_path / "identification_responses.json"
    default = {"schema_version": 1, "responses": []}
    if resp_path.exists():
        try:
            with open(resp_path, encoding="utf-8") as f:
                _identification_responses_cache = json.load(f)
        except (json.JSONDecodeError, OSError):
            _identification_responses_cache = default
    else:
        _identification_responses_cache = default
    return _identification_responses_cache


def _save_identification_responses(data: dict):
    """Save identification responses atomically."""
    global _identification_responses_cache
    resp_path = data_path / "identification_responses.json"
    import tempfile
    tmp_fd, tmp_path = tempfile.mkstemp(dir=str(data_path), suffix=".json")
    try:
        with os.fdopen(tmp_fd, "w") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
        os.replace(tmp_path, str(resp_path))
        _identification_responses_cache = data
    except Exception:
        try:
            os.unlink(tmp_path)
        except OSError:
            pass


@rt("/identify/{person_id}")
def get(person_id: str, sess=None):
    """
    Shareable 'Can you identify this person?' page.

    No authentication required. Shows the face, source photos, best matches,
    and a simple response form. This is the URL you share in Facebook groups
    and family chats to crowdsource identification.
    """
    user = get_current_user(sess or {}) if is_auth_enabled() else None

    registry = load_registry()
    identity = _safe_get_identity(registry, person_id)
    if not identity or identity.get("merged_into"):
        return Title("Person Not Found"), Main(
            Div(H2("Person not found", cls="text-xl text-white"), cls="text-center py-20"),
            cls="min-h-screen bg-slate-900",
        )

    display_name = ensure_utf8_display(identity.get("name", "Unknown"))
    state = identity.get("state", "INBOX")
    is_identified = state == "CONFIRMED" and not display_name.startswith("Unidentified")

    # If already identified, redirect to person page
    if is_identified:
        from starlette.responses import RedirectResponse
        return RedirectResponse(f"/person/{person_id}", status_code=303)

    # Get face crops and photos
    all_face_ids = identity.get("anchor_ids", []) + identity.get("candidate_ids", [])
    face_id_strings = [f if isinstance(f, str) else f.get("face_id", "") for f in all_face_ids]
    photo_reg = load_photo_registry()
    photo_ids = list(photo_reg.get_photos_for_faces(face_id_strings))
    crop_files = get_crop_files()
    best_face_id = get_best_face_id(all_face_ids)
    avatar_url = resolve_face_image_url(best_face_id, crop_files) if best_face_id and crop_files else None

    # Build face image
    face_section = Div(
        Img(src=avatar_url, alt="Unidentified person",
            cls="w-48 h-48 sm:w-64 sm:h-64 rounded-2xl object-cover border-4 border-amber-500/30 shadow-lg shadow-amber-500/10 mx-auto") if avatar_url else
        Div(Span("?", cls="text-6xl text-slate-500"), cls="w-48 h-48 rounded-2xl bg-slate-800 border-4 border-slate-700 flex items-center justify-center mx-auto"),
        cls="mb-8",
    )

    # Source photos
    _build_caches()
    photo_cards = []
    for pid in photo_ids[:4]:
        pm = (_photo_cache or {}).get(pid, {})
        if not pm:
            pm = photo_reg._photos.get(pid, {})
        photo_path = pm.get("path", "")
        if photo_path:
            photo_url = storage.get_photo_url(photo_path)
            collection = pm.get("collection", "")
            photo_cards.append(
                A(
                    Img(src=photo_url, alt="Source photo", cls="w-full h-40 object-cover rounded-lg"),
                    P(collection, cls="text-xs text-slate-500 mt-1 truncate") if collection else None,
                    href=f"/photo/{pid}",
                    cls="block hover:opacity-80 transition-opacity",
                )
            )

    photos_section = Div(
        H3("Appears in these photos", cls="text-sm font-semibold text-slate-400 mb-3"),
        Div(*photo_cards, cls="grid grid-cols-2 sm:grid-cols-4 gap-3"),
        cls="mb-10",
    ) if photo_cards else None

    # Best matches (nearest neighbors)
    match_cards = []
    try:
        from core.neighbors import find_nearest_neighbors
        if face_id_strings:
            neighbors = find_nearest_neighbors(face_id_strings[0], k=3)
            for n_face_id, dist in neighbors:
                n_ident = get_identity_for_face(registry, n_face_id)
                if n_ident and n_ident.get("identity_id") != person_id:
                    n_name = ensure_utf8_display(n_ident.get("name", "Unknown"))
                    n_crop = resolve_face_image_url(n_face_id, crop_files) if crop_files else None
                    n_id = n_ident.get("identity_id", "")
                    match_cards.append(
                        A(
                            Img(src=n_crop, alt=n_name, cls="w-20 h-20 rounded-xl object-cover") if n_crop else
                            Div(Span("?", cls="text-xl text-slate-500"), cls="w-20 h-20 rounded-xl bg-slate-800 flex items-center justify-center"),
                            P(n_name if not n_name.startswith("Unidentified") else "Unknown", cls="text-xs text-slate-300 mt-1 text-center truncate w-20"),
                            href=f"/identify/{person_id}/match/{n_id}",
                            cls="flex flex-col items-center hover:opacity-80 transition-opacity",
                        )
                    )
    except Exception:
        pass

    matches_section = Div(
        H3("Possible matches", cls="text-sm font-semibold text-slate-400 mb-3"),
        Div(*match_cards, cls="flex gap-4 justify-center"),
        cls="mb-10",
    ) if match_cards else None

    # Response form
    form_section = Div(
        H3("Do you recognize this person?", cls="text-lg font-serif font-semibold text-white mb-4"),
        Form(
            Input(type="hidden", name="person_id", value=person_id),
            Div(
                Label("Their name", fr="resp_name", cls="text-sm text-slate-400 block mb-1"),
                Input(type="text", name="name", id="resp_name", placeholder="e.g., Sarah Capeluto",
                      cls="w-full px-4 py-2.5 bg-slate-800 border border-slate-700 rounded-lg text-white placeholder-slate-500 focus:border-indigo-500 focus:outline-none"),
                cls="mb-4",
            ),
            Div(
                Label("How do you know?", fr="resp_relationship", cls="text-sm text-slate-400 block mb-1"),
                Input(type="text", name="relationship", id="resp_relationship", placeholder="e.g., She's my grandmother",
                      cls="w-full px-4 py-2.5 bg-slate-800 border border-slate-700 rounded-lg text-white placeholder-slate-500 focus:border-indigo-500 focus:outline-none"),
                cls="mb-4",
            ),
            Div(
                Label("Your email (optional, for follow-up)", fr="resp_email", cls="text-sm text-slate-400 block mb-1"),
                Input(type="email", name="email", id="resp_email", placeholder="you@example.com",
                      cls="w-full px-4 py-2.5 bg-slate-800 border border-slate-700 rounded-lg text-white placeholder-slate-500 focus:border-indigo-500 focus:outline-none"),
                cls="mb-6",
            ),
            Button("Yes, I know this person!", type="submit",
                   cls="w-full py-3 bg-emerald-600 hover:bg-emerald-500 text-white font-semibold rounded-lg transition-colors"),
            hx_post=f"/api/identify/{person_id}/respond",
            hx_target="#identify-response-area",
            hx_swap="innerHTML",
        ),
        id="identify-response-area",
        cls="bg-slate-800/50 rounded-xl p-6 border border-slate-700/50 max-w-md mx-auto",
    )

    # Share button
    share_url = f"{SITE_URL}/identify/{person_id}"
    share_btn = Button(
        "Share to help identify",
        cls="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 text-white text-sm font-medium rounded-lg transition-colors",
        data_action="share-photo",
        data_share_url=share_url,
        data_share_title="Can you identify this person?",
        data_share_text=f"Help us identify this person in the Rhodesli Heritage Archive",
    )

    # OG tags
    og_image = avatar_url or ""
    if og_image and not og_image.startswith("http"):
        og_image = f"{SITE_URL}{og_image}"
    og_meta = (
        Meta(property="og:title", content="Can you identify this person? — Rhodesli"),
        Meta(property="og:description", content="Help us identify this person from the Rhodes Jewish Heritage Archive. Share with family members who might recognize them."),
        Meta(property="og:image", content=og_image),
        Meta(property="og:url", content=share_url),
        Meta(property="og:type", content="website"),
        Meta(property="og:site_name", content="Rhodesli — Heritage Photo Archive"),
        Meta(name="twitter:card", content="summary_large_image"),
        Meta(name="twitter:title", content="Can you identify this person?"),
        Meta(name="twitter:description", content="Help us identify this person from the Rhodes Jewish Heritage Archive."),
        Meta(name="twitter:image", content=og_image),
    )

    # "Explore the Archive" section — pull visitors deeper into the app
    explore_links = []
    if len(photo_ids) > 1:
        explore_links.append(
            A(f"See all {len(photo_ids)} photos of this person",
              href=f"/identify/{person_id}#photos",
              cls="px-4 py-2.5 bg-slate-800 hover:bg-slate-700 text-slate-200 text-sm font-medium rounded-lg transition-colors border border-slate-700 min-h-[44px] flex items-center"),
        )
    explore_links.extend([
        A("Browse all photos",
          href="/photos",
          cls="px-4 py-2.5 bg-slate-800 hover:bg-slate-700 text-slate-200 text-sm font-medium rounded-lg transition-colors border border-slate-700 min-h-[44px] flex items-center"),
        A("View identified people",
          href="/people",
          cls="px-4 py-2.5 bg-slate-800 hover:bg-slate-700 text-slate-200 text-sm font-medium rounded-lg transition-colors border border-slate-700 min-h-[44px] flex items-center"),
        A("Explore the timeline",
          href="/timeline",
          cls="px-4 py-2.5 bg-slate-800 hover:bg-slate-700 text-slate-200 text-sm font-medium rounded-lg transition-colors border border-slate-700 min-h-[44px] flex items-center"),
    ])
    explore_section = Div(
        H3("Explore the Archive", cls="text-lg font-serif font-semibold text-white text-center mb-4"),
        P("Hundreds of photos from the Rhodes Jewish community await identification.",
          cls="text-sm text-slate-400 text-center mb-5"),
        Div(*explore_links, cls="flex flex-wrap justify-center gap-3"),
        cls="mt-10 pt-6 border-t border-slate-700/30",
    )

    nav_links = _public_nav_links(user=user)
    page_style = Style("html, body { margin: 0; } body { background-color: #0f172a; }")

    return (
        Title("Can you identify this person? — Rhodesli"),
        *og_meta,
        page_style,
        Main(
            # Navigation
            Nav(
                Div(
                    A(Span("Rhodesli", cls="text-lg font-serif font-bold text-white"), href="/"),
                    Div(*nav_links, cls="hidden sm:flex items-center gap-6"),
                    cls="max-w-5xl mx-auto px-6 flex items-center justify-between h-16",
                ),
                cls="bg-slate-900/80 backdrop-blur-md border-b border-slate-800 sticky top-0 z-50",
            ),
            # Content
            Section(
                Div(
                    H1("Can you identify this person?", cls="text-2xl sm:text-3xl font-serif font-bold text-white text-center mb-2"),
                    P("This person appears in photos from the Rhodes Jewish Heritage Archive. If you recognize them, please let us know.",
                      cls="text-slate-400 text-sm text-center mb-8 max-w-lg mx-auto"),
                    face_section,
                    photos_section,
                    matches_section,
                    form_section,
                    Div(share_btn, cls="flex justify-center mt-8 mb-4"),
                    explore_section,
                    cls="max-w-3xl mx-auto pt-10 pb-16 px-6",
                ),
            ),
            cls="min-h-screen bg-slate-900 text-white",
        ),
        _share_script(),
    )


@rt("/api/identify/{person_id}/respond")
def post(person_id: str, name: str = "", relationship: str = "", email: str = "", sess=None):
    """Save an identification response. No login required."""
    if not name.strip():
        return Div(
            P("Please enter a name for this person.", cls="text-amber-400 text-sm"),
            cls="py-2",
        )

    import hashlib
    responses = _load_identification_responses()
    responses["responses"].append({
        "person_id": person_id,
        "suggested_name": name.strip(),
        "relationship": relationship.strip(),
        "email": email.strip(),
        "timestamp": datetime.now().isoformat(),
        "status": "pending",
    })
    _save_identification_responses(responses)

    return Div(
        Div(
            P("Thank you!", cls="text-lg font-semibold text-emerald-400 mb-1"),
            P(f"Your identification of this person as \"{name.strip()}\" has been submitted. An admin will review it shortly.", cls="text-slate-300 text-sm"),
            cls="bg-emerald-900/20 border border-emerald-800/50 rounded-xl p-6 text-center",
        ),
    )


def _get_match_response_counts(person_a: str, person_b: str) -> dict:
    """Count community responses for a match pair (checks both orderings)."""
    responses = _load_identification_responses()
    counts = {"yes": 0, "no": 0, "unsure": 0, "total": 0}
    for r in responses.get("responses", []):
        if r.get("type") != "match_confirmation":
            continue
        pa, pb = r.get("person_a"), r.get("person_b")
        if (pa == person_a and pb == person_b) or (pa == person_b and pb == person_a):
            ans = r.get("answer", "")
            if ans in counts:
                counts[ans] += 1
            counts["total"] += 1
    return counts


def _match_community_summary(person_a: str, person_b: str):
    """Render community response summary for match mode (admin view)."""
    counts = _get_match_response_counts(person_a, person_b)
    if counts["total"] == 0:
        return None
    return Div(
        Span("Community: ", cls="text-xs text-slate-500"),
        Span(f'{counts["yes"]} Yes', cls="text-xs text-emerald-400 font-medium"),
        Span(" · ", cls="text-xs text-slate-600"),
        Span(f'{counts["no"]} No', cls="text-xs text-rose-400 font-medium"),
        Span(" · ", cls="text-xs text-slate-600"),
        Span(f'{counts["unsure"]} Unsure', cls="text-xs text-slate-400 font-medium"),
        cls="text-center mt-3 py-2 px-3 bg-amber-900/20 border border-amber-800/30 rounded-lg",
    )


def _match_source_photo_card(face_id, photo_id, label, registry=None, crop_files=None):
    """Build a source photo thumbnail with face highlight for the match page.

    When registry and crop_files are provided, also builds face chips for
    other faces in the same photo (shown below the lightbox image).
    """
    if not photo_id:
        return None
    photo_data = get_photo_metadata(photo_id)
    if not photo_data:
        return None

    filename = photo_data.get("filename", "")
    photo_url = storage.get_photo_url(filename)
    width = photo_data.get("width", 0)
    height = photo_data.get("height", 0)

    # Find face bbox for highlight overlay
    bbox_overlay = None
    if width and height:
        for face in photo_data.get("faces", []):
            if face.get("face_id") == face_id:
                bbox = face.get("bbox")
                if bbox and len(bbox) == 4:
                    x1, y1, x2, y2 = [float(v) for v in bbox]
                    left_pct = (x1 / width) * 100
                    top_pct = (y1 / height) * 100
                    w_pct = ((x2 - x1) / width) * 100
                    h_pct = ((y2 - y1) / height) * 100
                    bbox_overlay = Div(
                        cls="absolute border-2 border-amber-400 rounded-sm",
                        style=f"left:{left_pct:.1f}%;top:{top_pct:.1f}%;width:{w_pct:.1f}%;height:{h_pct:.1f}%",
                    )
                break

    # Get collection and date
    collection = photo_data.get("collection", "")
    date_text, _, _ = _get_date_badge(photo_id)

    meta_parts = []
    if collection:
        meta_parts.append(Span(collection, cls="text-slate-400 text-xs"))
    if date_text:
        meta_parts.append(Span(date_text, cls="text-slate-400 text-xs"))

    # Build face chips for other faces in this photo
    face_chips_data = []
    if registry and crop_files:
        for face in photo_data.get("faces", []):
            fid = face.get("face_id", "")
            if not fid or fid == face_id:
                continue
            ident = get_identity_for_face(registry, fid)
            if ident:
                iid = ident.get("identity_id", "")
                iname = ensure_utf8_display(ident.get("name", "Unknown"))
                istate = ident.get("state", "INBOX")
                chip_url = resolve_face_image_url(fid, crop_files)
                face_chips_data.append((iid, iname, istate, chip_url))

    # Encode face chips as data attribute for lightbox JS
    import json as _json_fc
    chips_json = _json_fc.dumps(face_chips_data) if face_chips_data else "[]"

    # Build face bbox data for lightbox overlays
    face_bboxes = []
    if width and height:
        for face in photo_data.get("faces", []):
            fid = face.get("face_id", "")
            bbox = face.get("bbox")
            if bbox and len(bbox) == 4:
                x1, y1, x2, y2 = [float(v) for v in bbox]
                ident = get_identity_for_face(registry, fid) if registry else None
                fname = ensure_utf8_display((ident or {}).get("name", "")) if ident else ""
                fstate = (ident or {}).get("state", "INBOX") if ident else "INBOX"
                fident_id = (ident or {}).get("identity_id", "") if ident else ""
                is_highlight = fid == face_id
                # Clean name for display — don't show "Unidentified Person 42"
                display_fname = fname if fname and not fname.startswith("Unidentified") else ""
                face_bboxes.append({
                    "left": round((x1 / width) * 100, 1),
                    "top": round((y1 / height) * 100, 1),
                    "width": round(((x2 - x1) / width) * 100, 1),
                    "height": round(((y2 - y1) / height) * 100, 1),
                    "name": display_fname,
                    "state": fstate,
                    "identity_id": fident_id,
                    "highlight": is_highlight,
                })
    bboxes_json = _json_fc.dumps(face_bboxes)

    return Div(
        P(label, cls="text-xs text-slate-500 uppercase tracking-wider mb-2 font-medium"),
        Div(
            Img(src=photo_url, alt=f"Source photo for {label}",
                cls="w-full h-auto rounded-lg cursor-pointer transition-opacity hover:opacity-90"),
            bbox_overlay,
            cls="relative inline-block w-full",
            data_action="open-lightbox",
            data_photo_url=photo_url,
            data_photo_label=label,
            data_photo_id=photo_id,
            data_face_chips=chips_json,
            data_face_bboxes=bboxes_json,
            data_collection=collection,
            data_date=date_text or "",
            style="cursor:pointer",
        ) if photo_url else None,
        Div(*meta_parts, cls="flex gap-3 mt-1") if meta_parts else None,
        # Inline face chips preview below the thumbnail
        _match_face_chips_inline(face_chips_data) if face_chips_data else None,
        cls="mb-6",
    )


def _match_face_chips_inline(chips_data):
    """Render small face chip thumbnails below a source photo card."""
    if not chips_data:
        return None
    chip_els = []
    for iid, iname, istate, chip_url in chips_data[:8]:  # Cap at 8
        href = f"/person/{iid}" if istate == "CONFIRMED" else f"/identify/{iid}"
        short_name = iname if not iname.startswith("Unidentified") else "Unknown"
        chip_els.append(
            A(
                Img(src=chip_url, alt=short_name,
                    cls="w-8 h-8 rounded-full object-cover border border-slate-600") if chip_url else
                Div("?", cls="w-8 h-8 rounded-full bg-slate-700 border border-slate-600 flex items-center justify-center text-xs text-slate-400"),
                Span(short_name, cls="text-[10px] text-slate-400 block text-center truncate w-12 mt-0.5"),
                href=href,
                title=f"View {iname}" if not iname.startswith("Unidentified") else "Help identify this person",
                cls="flex flex-col items-center hover:opacity-80 transition-opacity",
            )
        )
    return Div(
        P("Also in this photo:", cls="text-[10px] text-slate-500 uppercase tracking-wider mb-1.5"),
        Div(*chip_els, cls="flex flex-wrap gap-2"),
        cls="mt-3 pt-2 border-t border-slate-700/30",
    )


def _match_lightbox_script():
    """JS for the match page lightbox with face overlays, metadata, zoom."""
    return Script("""
    (function() {
        var scale = 1;
        var lightbox = document.getElementById('match-lightbox');
        var lbImg = document.getElementById('match-lightbox-img');
        var lbFaces = document.getElementById('match-lightbox-faces');
        var lbOverlays = document.getElementById('match-lightbox-overlays');
        var lbMeta = document.getElementById('match-lightbox-meta');
        if (!lightbox) return;

        function openLightbox(src, chipsJson, bboxesJson, photoId, collection, dateText) {
            scale = 1;
            lbImg.src = src;
            lbImg.style.transform = 'scale(1)';

            // Build face bbox overlays on the lightbox image
            lbOverlays.innerHTML = '';
            try {
                var bboxes = JSON.parse(bboxesJson || '[]');
                bboxes.forEach(function(b) {
                    var div = document.createElement('div');
                    div.style.position = 'absolute';
                    div.style.left = b.left + '%';
                    div.style.top = b.top + '%';
                    div.style.width = b.width + '%';
                    div.style.height = b.height + '%';
                    div.style.pointerEvents = 'auto';
                    div.style.cursor = 'pointer';
                    var borderColor = b.highlight ? 'rgba(245,158,11,0.8)' : (b.state === 'CONFIRMED' ? 'rgba(16,185,129,0.6)' : 'rgba(148,163,184,0.4)');
                    div.style.border = '2px solid ' + borderColor;
                    div.style.borderRadius = '2px';
                    if (b.highlight) div.style.boxShadow = '0 0 8px rgba(245,158,11,0.4)';
                    if (b.name && !b.name.startsWith('Unidentified')) {
                        div.title = b.name;
                        var label = document.createElement('span');
                        label.textContent = b.name;
                        label.style.cssText = 'position:absolute;bottom:-18px;left:0;font-size:10px;color:#e2e8f0;white-space:nowrap;text-shadow:0 1px 3px rgba(0,0,0,0.8);';
                        div.appendChild(label);
                    }
                    if (b.identity_id) {
                        div.addEventListener('click', function(e) {
                            e.stopPropagation();
                            var href = b.state === 'CONFIRMED' ? '/person/' + b.identity_id : '/identify/' + b.identity_id;
                            window.location.href = href;
                        });
                    }
                    lbOverlays.appendChild(div);
                });
            } catch(e) {}

            // Build metadata bar
            lbMeta.innerHTML = '';
            var metaParts = [];
            if (collection) metaParts.push(collection);
            if (dateText) metaParts.push(dateText);
            if (metaParts.length > 0) {
                var metaP = document.createElement('p');
                metaP.textContent = metaParts.join(' · ');
                metaP.className = 'text-sm text-slate-300';
                lbMeta.appendChild(metaP);
            }
            if (photoId) {
                var link = document.createElement('a');
                link.href = '/photo/' + photoId;
                link.textContent = 'View Photo Page →';
                link.className = 'text-xs text-indigo-400 hover:text-indigo-300 inline-block mt-1 transition-colors';
                lbMeta.appendChild(link);
            }

            // Build face chips in lightbox
            lbFaces.innerHTML = '';
            try {
                var chips = JSON.parse(chipsJson || '[]');
                if (chips.length > 0) {
                    var heading = document.createElement('p');
                    heading.textContent = 'Also in this photo:';
                    heading.className = 'text-xs text-slate-400 uppercase tracking-wider mb-2 text-center';
                    lbFaces.appendChild(heading);
                    var row = document.createElement('div');
                    row.className = 'flex flex-wrap justify-center gap-3';
                    chips.forEach(function(c) {
                        var iid = c[0], iname = c[1], istate = c[2], chipUrl = c[3];
                        var href = istate === 'CONFIRMED' ? '/person/' + iid : '/identify/' + iid;
                        var shortName = iname.startsWith('Unidentified') ? 'Unknown' : iname;
                        var a = document.createElement('a');
                        a.href = href;
                        a.title = iname.startsWith('Unidentified') ? 'Help identify' : 'View ' + iname;
                        a.className = 'flex flex-col items-center hover:opacity-80 transition-opacity';
                        if (chipUrl) {
                            var img = document.createElement('img');
                            img.src = chipUrl;
                            img.alt = shortName;
                            img.className = 'w-10 h-10 rounded-full object-cover border border-slate-500';
                            a.appendChild(img);
                        } else {
                            var placeholder = document.createElement('div');
                            placeholder.textContent = '?';
                            placeholder.className = 'w-10 h-10 rounded-full bg-slate-700 border border-slate-500 flex items-center justify-center text-xs text-slate-400';
                            a.appendChild(placeholder);
                        }
                        var nameSpan = document.createElement('span');
                        nameSpan.textContent = shortName;
                        nameSpan.className = 'text-xs text-slate-300 mt-1 text-center max-w-[60px] truncate';
                        a.appendChild(nameSpan);
                        row.appendChild(a);
                    });
                    lbFaces.appendChild(row);
                }
            } catch(e) {}
            lightbox.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
        }
        function closeLightbox() {
            lightbox.classList.add('hidden');
            document.body.style.overflow = '';
            lbImg.src = '';
            lbOverlays.innerHTML = '';
            lbMeta.innerHTML = '';
        }

        // Event delegation for open/close
        document.addEventListener('click', function(e) {
            // Open lightbox
            var trigger = e.target.closest('[data-action="open-lightbox"]');
            if (trigger) {
                e.preventDefault();
                openLightbox(
                    trigger.dataset.photoUrl,
                    trigger.dataset.faceChips,
                    trigger.dataset.faceBboxes || '[]',
                    trigger.dataset.photoId || '',
                    trigger.dataset.collection || '',
                    trigger.dataset.date || ''
                );
                return;
            }
            // Close via X button
            if (e.target.closest('[data-action="close-lightbox"]')) {
                closeLightbox();
                return;
            }
            // Close via background click
            if (e.target.closest('[data-action="close-lightbox-bg"]') && e.target === lightbox) {
                closeLightbox();
                return;
            }
        });

        // Escape key closes lightbox
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && !lightbox.classList.contains('hidden')) {
                closeLightbox();
            }
        });

        // Scroll-zoom on desktop
        lbImg.addEventListener('wheel', function(e) {
            e.preventDefault();
            scale = Math.max(0.5, Math.min(5, scale + (e.deltaY > 0 ? -0.15 : 0.15)));
            lbImg.style.transform = 'scale(' + scale + ')';
        }, {passive: false});

        // Pinch-to-zoom on mobile
        var lastDist = 0;
        lbImg.addEventListener('touchstart', function(e) {
            if (e.touches.length === 2) {
                var dx = e.touches[0].clientX - e.touches[1].clientX;
                var dy = e.touches[0].clientY - e.touches[1].clientY;
                lastDist = Math.sqrt(dx * dx + dy * dy);
            }
        }, {passive: true});
        lbImg.addEventListener('touchmove', function(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                var dx = e.touches[0].clientX - e.touches[1].clientX;
                var dy = e.touches[0].clientY - e.touches[1].clientY;
                var dist = Math.sqrt(dx * dx + dy * dy);
                if (lastDist > 0) {
                    var delta = (dist - lastDist) * 0.005;
                    scale = Math.max(0.5, Math.min(5, scale + delta));
                    lbImg.style.transform = 'scale(' + scale + ')';
                }
                lastDist = dist;
            }
        }, {passive: false});
        lbImg.addEventListener('touchend', function() { lastDist = 0; });
    })();
    """)


@rt("/identify/{person_a}/match/{person_b}")
def get(person_a: str, person_b: str, sess=None):
    """
    Shareable match confirmation page — 'Are these the same person?'

    Shows two faces side by side with source photos for comparison.
    No login required. This is the core crowdsourcing mechanism.
    """
    user = get_current_user(sess or {}) if is_auth_enabled() else None
    is_admin = (user.is_admin if user else False) if is_auth_enabled() else True

    registry = load_registry()
    ident_a = _safe_get_identity(registry, person_a)
    ident_b = _safe_get_identity(registry, person_b)

    if not ident_a or not ident_b:
        return Title("People Not Found"), Main(
            Div(H2("One or both people not found", cls="text-xl text-white"), cls="text-center py-20"),
            cls="min-h-screen bg-slate-900",
        )

    _build_caches()
    crop_files = get_crop_files()
    name_a = ensure_utf8_display(ident_a.get("name", "Unknown"))
    name_b = ensure_utf8_display(ident_b.get("name", "Unknown"))
    display_a = name_a if not name_a.startswith("Unidentified") else "Person A"
    display_b = name_b if not name_b.startswith("Unidentified") else "Person B"

    # Get face crops
    faces_a = ident_a.get("anchor_ids", []) + ident_a.get("candidate_ids", [])
    faces_b = ident_b.get("anchor_ids", []) + ident_b.get("candidate_ids", [])
    best_a = get_best_face_id(faces_a)
    best_b = get_best_face_id(faces_b)
    crop_a = resolve_face_image_url(best_a, crop_files) if best_a and crop_files else None
    crop_b = resolve_face_image_url(best_b, crop_files) if best_b and crop_files else None

    # Source photo info
    photo_id_a = get_photo_id_for_face(best_a) if best_a else None
    photo_id_b = get_photo_id_for_face(best_b) if best_b else None
    photo_data_a = get_photo_metadata(photo_id_a) if photo_id_a else None
    photo_data_b = get_photo_metadata(photo_id_b) if photo_id_b else None
    collection_a = (photo_data_a or {}).get("collection", "")
    collection_b = (photo_data_b or {}).get("collection", "")
    date_a, _, _ = _get_date_badge(photo_id_a) if photo_id_a else (None, None, None)
    date_b, _, _ = _get_date_badge(photo_id_b) if photo_id_b else (None, None, None)

    def _face_card(crop_url, display_name, collection, date_text, pid, state, all_faces=None, crop_files_ref=None):
        """Build a face card with optional carousel for multi-face identities."""
        meta_items = []
        if collection:
            meta_items.append(P(collection, cls="text-xs text-slate-400 text-center"))
        if date_text:
            meta_items.append(P(date_text, cls="text-xs text-slate-500 text-center"))
        # Link to person page (CONFIRMED) or identify page (all others)
        person_href = f"/person/{pid}" if state == "CONFIRMED" else f"/identify/{pid}"
        profile_label = f"View {display_name}'s Profile" if state == "CONFIRMED" else f"Help Identify {display_name}"

        # Build face data for carousel (if multiple faces)
        face_data_list = []
        if all_faces and crop_files_ref and len(all_faces) > 1:
            for fid_entry in all_faces:
                fid = fid_entry if isinstance(fid_entry, str) else fid_entry.get("face_id", "")
                furl = resolve_face_image_url(fid, crop_files_ref)
                if furl:
                    fpid = get_photo_id_for_face(fid)
                    face_data_list.append({"crop_url": furl, "photo_id": fpid or ""})

        has_carousel = len(face_data_list) > 1

        face_img = (
            Img(src=crop_url, alt=display_name, id=f"face-img-{pid}",
                cls="w-40 h-40 sm:w-52 sm:h-52 rounded-2xl object-cover border-2 border-slate-700 mx-auto shadow-lg"
                    " transition-transform duration-200 hover:scale-105 hover:shadow-[0_0_12px_rgba(255,191,0,0.5)]") if crop_url else
            Div(Span("?", cls="text-5xl text-slate-500"),
                cls="w-40 h-40 sm:w-52 sm:h-52 rounded-2xl bg-slate-800 border-2 border-slate-700 flex items-center justify-center mx-auto")
        )

        # Carousel navigation arrows
        carousel_el = None
        if has_carousel:
            import json as json_mod
            carousel_el = Div(
                Button(
                    NotStr("&#8249;"),
                    cls="w-8 h-8 bg-slate-700/80 hover:bg-slate-600 text-white rounded-full flex items-center justify-center text-lg transition-colors",
                    data_action="face-carousel-prev",
                    data_target=pid,
                    type="button",
                ),
                Span(f"1 of {len(face_data_list)}", id=f"face-counter-{pid}",
                     cls="text-xs text-slate-400"),
                Button(
                    NotStr("&#8250;"),
                    cls="w-8 h-8 bg-slate-700/80 hover:bg-slate-600 text-white rounded-full flex items-center justify-center text-lg transition-colors",
                    data_action="face-carousel-next",
                    data_target=pid,
                    type="button",
                ),
                cls="flex items-center justify-center gap-3 mt-2",
                data_faces=json_mod.dumps(face_data_list),
                data_idx="0",
                id=f"face-carousel-{pid}",
            )

        return Div(
            A(face_img, href=person_href, title=f"View {display_name}"),
            carousel_el,
            A(display_name, href=person_href,
              cls="text-sm text-slate-200 mt-3 text-center font-semibold block hover:text-indigo-400 transition-colors"),
            *meta_items,
            A(profile_label + " →", href=person_href,
              cls="text-xs text-indigo-400 hover:text-indigo-300 text-center mt-2 block transition-colors"),
            cls="flex flex-col items-center",
        )

    # Community response counts
    resp_counts = _get_match_response_counts(person_a, person_b)
    response_summary = None
    if resp_counts["total"] > 0:
        parts = []
        if resp_counts["yes"]:
            parts.append(Span(f'{resp_counts["yes"]} Yes', cls="text-emerald-400 font-medium"))
        if resp_counts["no"]:
            parts.append(Span(f'{resp_counts["no"]} No', cls="text-rose-400 font-medium"))
        if resp_counts["unsure"]:
            parts.append(Span(f'{resp_counts["unsure"]} Not Sure', cls="text-slate-400 font-medium"))
        response_summary = Div(
            P(f'{resp_counts["total"]} {"person has" if resp_counts["total"] == 1 else "people have"} weighed in',
              cls="text-sm text-slate-400 text-center mb-1"),
            Div(*[Span(p, Span(" · ", cls="text-slate-600")) if i < len(parts) - 1 else p
                  for i, p in enumerate(parts)],
                cls="flex items-center justify-center gap-1 text-sm"),
            cls="mt-4 pt-3 border-t border-slate-700/50",
        )

    # Response form with name/note fields
    respond_url = f"/api/identify/{person_a}/match/{person_b}/respond"
    response_area = Div(
        H3("What do you think?", cls="text-lg font-serif font-semibold text-white text-center mb-2"),
        P("Your knowledge helps preserve family history.",
          cls="text-sm text-slate-400 text-center mb-6"),
        # Vote buttons
        Div(
            Button("Yes, Same Person",
                   hx_post=respond_url,
                   hx_include="#match-form-fields",
                   hx_vals='{"answer": "yes"}',
                   hx_target="#match-response-area",
                   hx_swap="innerHTML",
                   cls="px-6 py-3 bg-emerald-600 hover:bg-emerald-500 text-white font-semibold rounded-lg transition-colors min-h-[44px]"),
            Button("No, Different People",
                   hx_post=respond_url,
                   hx_include="#match-form-fields",
                   hx_vals='{"answer": "no"}',
                   hx_target="#match-response-area",
                   hx_swap="innerHTML",
                   cls="px-6 py-3 bg-rose-600 hover:bg-rose-500 text-white font-semibold rounded-lg transition-colors min-h-[44px]"),
            Button("Not Sure",
                   hx_post=respond_url,
                   hx_include="#match-form-fields",
                   hx_vals='{"answer": "unsure"}',
                   hx_target="#match-response-area",
                   hx_swap="innerHTML",
                   cls="px-6 py-3 bg-slate-700 hover:bg-slate-600 text-white font-semibold rounded-lg transition-colors min-h-[44px]"),
            cls="flex flex-wrap justify-center gap-3 mb-6",
        ),
        # Optional name/note fields
        Div(
            Div(
                Label("Your name (optional)", fr="responder_name", cls="text-xs text-slate-500 block mb-1"),
                Input(type="text", name="responder_name", id="responder_name",
                      placeholder="e.g. Cousin Sarah",
                      cls="w-full bg-slate-800 border border-slate-600 rounded-lg px-3 py-2 text-sm text-white placeholder-slate-500 focus:border-indigo-500 focus:outline-none"),
                cls="flex-1",
            ),
            Div(
                Label("How do you know? (optional)", fr="responder_note", cls="text-xs text-slate-500 block mb-1"),
                Input(type="text", name="responder_note", id="responder_note",
                      placeholder="e.g. That's my uncle Marco",
                      cls="w-full bg-slate-800 border border-slate-600 rounded-lg px-3 py-2 text-sm text-white placeholder-slate-500 focus:border-indigo-500 focus:outline-none"),
                cls="flex-1",
            ),
            id="match-form-fields",
            cls="flex flex-col sm:flex-row gap-3",
        ),
        response_summary,
        id="match-response-area",
        cls="bg-slate-800/50 rounded-xl p-6 border border-slate-700/50",
    )

    # Source photo cards
    source_photos = []
    src_photo_a = _match_source_photo_card(best_a, photo_id_a, f"Photo of {display_a}", registry=registry, crop_files=crop_files)
    src_photo_b = _match_source_photo_card(best_b, photo_id_b, f"Photo of {display_b}", registry=registry, crop_files=crop_files)
    if src_photo_a or src_photo_b:
        source_photos_content = []
        if src_photo_a:
            source_photos_content.append(Div(src_photo_a, cls="flex-1 min-w-0"))
        if src_photo_b:
            source_photos_content.append(Div(src_photo_b, cls="flex-1 min-w-0"))
        source_photos = [Div(
            H3("Source Photos", cls="text-sm font-semibold text-slate-300 uppercase tracking-wider mb-4"),
            Div(*source_photos_content, cls="grid grid-cols-1 sm:grid-cols-2 gap-6"),
            cls="mt-10 pt-6 border-t border-slate-700/30",
        )]

    # Share button
    share_url = f"{SITE_URL}/identify/{person_a}/match/{person_b}"
    share_btn = Button(
        "Share This Match",
        cls="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 text-white text-sm font-medium rounded-lg transition-colors",
        data_action="share-photo",
        data_share_url=share_url,
        data_share_title="Are these the same person?",
        data_share_text="Help us confirm if these two faces from the Rhodesli Heritage Archive are the same person.",
    )

    # OG tags
    og_image = crop_a or ""
    if og_image and not og_image.startswith("http"):
        og_image = f"{SITE_URL}{og_image}"
    og_meta = (
        Meta(property="og:title", content="Are these the same person? — Rhodesli"),
        Meta(property="og:description", content="Help us confirm if these two faces are the same person in the Rhodes Jewish Heritage Archive."),
        Meta(property="og:image", content=og_image),
        Meta(property="og:url", content=share_url),
        Meta(property="og:type", content="website"),
        Meta(property="og:site_name", content="Rhodesli — Heritage Photo Archive"),
        Meta(name="twitter:card", content="summary_large_image"),
    )

    nav_links = _public_nav_links(user=user)
    page_style = Style("html, body { margin: 0; } body { background-color: #0f172a; }")

    # Admin summary of community responses
    admin_summary = None
    if is_admin and resp_counts["total"] > 0:
        admin_summary = Div(
            P(f'Community: {resp_counts["yes"]} Yes, {resp_counts["no"]} No, {resp_counts["unsure"]} Unsure',
              cls="text-xs text-amber-400 text-center"),
            cls="bg-amber-900/20 border border-amber-800/30 rounded-lg px-3 py-2 mt-4",
        )

    # Build "Explore the Archive" section with contextual links
    explore_links = []
    # Link to the collection if we have one
    primary_collection = collection_a or collection_b
    if primary_collection:
        col_slug = _collection_slug(primary_collection)
        explore_links.append(
            A(f"See all photos in {primary_collection}",
              href=f"/collection/{col_slug}",
              cls="px-4 py-2.5 bg-slate-800 hover:bg-slate-700 text-slate-200 text-sm font-medium rounded-lg transition-colors border border-slate-700 min-h-[44px] flex items-center"),
        )
    explore_links.extend([
        A("Browse identified people",
          href="/people",
          cls="px-4 py-2.5 bg-slate-800 hover:bg-slate-700 text-slate-200 text-sm font-medium rounded-lg transition-colors border border-slate-700 min-h-[44px] flex items-center"),
        A("Help identify more faces",
          href="/",
          cls="px-4 py-2.5 bg-slate-800 hover:bg-slate-700 text-slate-200 text-sm font-medium rounded-lg transition-colors border border-slate-700 min-h-[44px] flex items-center"),
        A("View the timeline",
          href="/timeline",
          cls="px-4 py-2.5 bg-slate-800 hover:bg-slate-700 text-slate-200 text-sm font-medium rounded-lg transition-colors border border-slate-700 min-h-[44px] flex items-center"),
    ])
    explore_section = Div(
        H3("Explore the Archive", cls="text-lg font-serif font-semibold text-white text-center mb-4"),
        P("There are hundreds more photos and faces waiting to be identified.",
          cls="text-sm text-slate-400 text-center mb-5"),
        Div(*explore_links, cls="flex flex-wrap justify-center gap-3"),
        cls="mt-10 pt-6 border-t border-slate-700/30",
    )

    # Lightbox modal (hidden by default)
    lightbox = Div(
        Button(NotStr("&times;"), cls="absolute top-4 right-4 text-white text-3xl bg-transparent border-none cursor-pointer z-[1001] hover:text-slate-300 transition-colors leading-none", data_action="close-lightbox"),
        Div(
            # Photo container with face overlays
            Div(
                Img(id="match-lightbox-img", src="", alt="Full size photo",
                    cls="max-w-[90vw] max-h-[65vh] object-contain rounded-lg shadow-2xl"),
                Div(id="match-lightbox-overlays", cls="absolute inset-0"),
                cls="relative inline-block",
                id="match-lightbox-photo-wrap",
            ),
            # Metadata bar
            Div(id="match-lightbox-meta", cls="mt-3 text-center"),
            # Face chips
            Div(id="match-lightbox-faces", cls="mt-3"),
            cls="flex flex-col items-center max-w-[90vw]",
        ),
        id="match-lightbox",
        cls="fixed inset-0 bg-black/90 z-[1000] flex items-center justify-center hidden overflow-y-auto py-8",
        data_action="close-lightbox-bg",
    )

    return (
        Title("Are these the same person? — Rhodesli"),
        *og_meta,
        page_style,
        Main(
            Nav(
                Div(
                    A(Span("Rhodesli", cls="text-lg font-serif font-bold text-white"), href="/"),
                    Div(*nav_links, cls="hidden sm:flex items-center gap-6"),
                    cls="max-w-5xl mx-auto px-6 flex items-center justify-between h-16",
                ),
                cls="bg-slate-900/80 backdrop-blur-md border-b border-slate-800 sticky top-0 z-50",
            ),
            Section(
                Div(
                    H1("Are these the same person?",
                        cls="text-2xl sm:text-3xl font-serif font-bold text-white text-center mb-8"),
                    # Side-by-side faces with carousel if multi-face
                    Div(
                        _face_card(crop_a, display_a, collection_a, date_a, person_a, ident_a.get("state", "INBOX"),
                                   all_faces=faces_a, crop_files_ref=crop_files),
                        Div(
                            Span("vs", cls="text-slate-500 text-2xl font-bold"),
                            cls="flex items-center justify-center px-4 sm:px-8",
                        ),
                        _face_card(crop_b, display_b, collection_b, date_b, person_b, ident_b.get("state", "INBOX"),
                                   all_faces=faces_b, crop_files_ref=crop_files),
                        cls="flex flex-col sm:flex-row items-center justify-center gap-4 sm:gap-6 mb-10",
                    ),
                    # Voting area
                    response_area,
                    admin_summary,
                    # Source photos
                    *source_photos,
                    # Explore the archive
                    explore_section,
                    # Share
                    Div(
                        share_btn,
                        cls="flex items-center justify-center mt-8 mb-4",
                    ),
                    P("Help us identify people in the Rhodesli archive — your family knowledge matters.",
                      cls="text-xs text-slate-500 text-center mb-4"),
                    cls="max-w-3xl mx-auto pt-10 pb-16 px-6",
                ),
            ),
            lightbox,
            cls="min-h-screen bg-slate-900 text-white",
        ),
        _share_script(),
        _match_lightbox_script(),
        _face_carousel_script(),
    )


def _face_carousel_script():
    """JS for face carousel navigation on match pages and person pages."""
    return Script("""
    (function() {
        document.addEventListener('click', function(e) {
            var btn = e.target.closest('[data-action="face-carousel-prev"], [data-action="face-carousel-next"]');
            if (!btn) return;
            e.preventDefault();
            var targetId = btn.dataset.target;
            var carousel = document.getElementById('face-carousel-' + targetId);
            if (!carousel) return;
            var faces;
            try { faces = JSON.parse(carousel.dataset.faces); } catch(err) { return; }
            if (!faces || faces.length < 2) return;
            var idx = parseInt(carousel.dataset.idx || '0', 10);
            if (btn.dataset.action === 'face-carousel-next') {
                idx = (idx + 1) % faces.length;
            } else {
                idx = (idx - 1 + faces.length) % faces.length;
            }
            carousel.dataset.idx = idx;
            // Update face image
            var img = document.getElementById('face-img-' + targetId);
            if (img) img.src = faces[idx].crop_url;
            // Update counter
            var counter = document.getElementById('face-counter-' + targetId);
            if (counter) counter.textContent = (idx + 1) + ' of ' + faces.length;
        });
    })();
    """)


# Rate limit storage for match responses (IP -> list of timestamps)
_match_rate_limit: dict = {}


@rt("/api/identify/{person_a}/match/{person_b}/respond")
def post(person_a: str, person_b: str, answer: str = "",
         responder_name: str = "", responder_note: str = "", sess=None, request=None):
    """Save a match confirmation response. No login required. Rate limited."""
    if answer not in ("yes", "no", "unsure"):
        return Div(P("Invalid response.", cls="text-amber-400 text-sm"))

    # Rate limiting: max 10 responses per IP per hour
    import hashlib as _rl_hashlib
    client_ip = ""
    if request:
        client_ip = getattr(request.client, "host", "") if request.client else ""
    ip_hash = _rl_hashlib.sha256(client_ip.encode()).hexdigest()[:12] if client_ip else "unknown"
    now = datetime.now()
    cutoff = now - timedelta(hours=1)
    _match_rate_limit[ip_hash] = [t for t in _match_rate_limit.get(ip_hash, []) if t > cutoff]
    if len(_match_rate_limit.get(ip_hash, [])) >= 10:
        return Div(P("You've submitted many responses recently. Please try again later.",
                      cls="text-amber-400 text-sm text-center py-4"))
    _match_rate_limit.setdefault(ip_hash, []).append(now)

    responses = _load_identification_responses()
    responses["responses"].append({
        "type": "match_confirmation",
        "person_a": person_a,
        "person_b": person_b,
        "answer": answer,
        "responder_name": responder_name.strip()[:100] if responder_name else "",
        "responder_note": responder_note.strip()[:500] if responder_note else "",
        "timestamp": now.isoformat(),
        "ip_hash": ip_hash,
        "status": "pending",
    })
    _save_identification_responses(responses)

    messages = {
        "yes": "Thank you! You confirmed these are the same person. An admin will review.",
        "no": "Thank you! You indicated these are different people. An admin will review.",
        "unsure": "Thank you for looking! We'll ask others for confirmation.",
    }
    # Show updated response count
    counts = _get_match_response_counts(person_a, person_b)
    count_text = f'{counts["total"]} {"person has" if counts["total"] == 1 else "people have"} weighed in so far.'
    return Div(
        P(messages[answer], cls="text-emerald-400 text-sm text-center py-2"),
        P(count_text, cls="text-slate-400 text-xs text-center mt-1"),
    )


# --- Person Comments API ---

# Rate limit storage for person comments (IP -> list of timestamps)
_comment_rate_limit: dict = {}

@rt("/api/person/{person_id}/comment")
def post(person_id: str, author: str = "", text: str = "", sess=None, request=None):
    """Submit a comment on a person page. No login required. Rate limited."""
    if not text.strip():
        return Div(P("Please enter a comment.", cls="text-amber-400 text-sm py-2"))

    # Rate limiting: max 5 comments per IP per hour
    import hashlib as _rl_hashlib
    client_ip = ""
    if request:
        client_ip = getattr(request.client, "host", "") if request.client else ""
    ip_hash = _rl_hashlib.sha256(client_ip.encode()).hexdigest()[:12] if client_ip else "unknown"
    now = datetime.now()
    cutoff = now - timedelta(hours=1)
    _comment_rate_limit[ip_hash] = [t for t in _comment_rate_limit.get(ip_hash, []) if t > cutoff]
    if len(_comment_rate_limit.get(ip_hash, [])) >= 5:
        return Div(P("Please wait before submitting another comment.",
                      cls="text-amber-400 text-sm text-center py-4"))
    _comment_rate_limit.setdefault(ip_hash, []).append(now)

    import uuid
    comments_data = _load_person_comments()
    if person_id not in comments_data.get("comments", {}):
        comments_data.setdefault("comments", {})[person_id] = []

    comment = {
        "id": str(uuid.uuid4())[:8],
        "author": author.strip() or "Anonymous",
        "text": text.strip(),
        "timestamp": datetime.now().isoformat(),
        "status": "visible",
    }
    comments_data["comments"][person_id].append(comment)
    _save_person_comments(comments_data)

    # Re-render comments list
    visible = [c for c in comments_data["comments"][person_id] if c.get("status") == "visible"]
    items = []
    for c in visible:
        date_str = c.get("timestamp", "")[:10]
        items.append(
            Div(
                Div(
                    Span(c["author"], cls="text-sm font-medium text-slate-300"),
                    Span(f" · {date_str}", cls="text-xs text-slate-600") if date_str else None,
                    cls="flex items-center mb-1",
                ),
                P(c["text"], cls="text-sm text-slate-400 leading-relaxed"),
                cls="py-3 border-b border-slate-800/50 last:border-0",
                id=f"comment-{c['id']}",
            )
        )
    return Div(*items)


@rt("/api/person/{person_id}/comment/{comment_id}/hide")
def post(person_id: str, comment_id: str, sess=None):
    """Hide a comment (admin only)."""
    err = _check_admin(sess)
    if err:
        return err

    comments_data = _load_person_comments()
    person_comments = comments_data.get("comments", {}).get(person_id, [])
    for c in person_comments:
        if c.get("id") == comment_id:
            c["status"] = "hidden"
            break
    _save_person_comments(comments_data)
    return Div(P("Comment hidden.", cls="text-xs text-slate-500 italic py-2"))


@rt("/photos")
def get(filter_collection: str = "", sort_by: str = "newest",
        decade: int = None, search_q: str = "", tag: str = "", sess=None):
    """
    Public photos browsing page — grid of all archive photos.

    No authentication required. Each photo links to /photo/{id}.
    Supports decade filtering, keyword search, and tag filtering via query params.
    """
    user = get_current_user(sess or {}) if is_auth_enabled() else None

    _build_caches()
    registry = load_registry()

    # Get decade and tag counts for filter pills
    decade_counts = _get_decade_counts()
    tag_counts = _get_tag_counts()

    # Search-based filtering (uses search index for text, decade, tag)
    search_results = None
    search_photo_ids = None
    if search_q or decade or tag:
        search_results = _search_photos(query=search_q, decade=decade, tag=tag)
        search_photo_ids = {r.get("cache_photo_id", r["photo_id"]): r.get("match_reason") for r in search_results}

    # Gather photos with metadata
    photos = []
    collections_set = set()
    for photo_id_val, photo_data in (_photo_cache or {}).items():
        collection = photo_data.get("collection", "")
        if collection:
            collections_set.add(collection)
        # Apply collection filter
        if filter_collection and collection != filter_collection:
            continue
        # Apply search/decade/tag filter
        if search_photo_ids is not None and photo_id_val not in search_photo_ids:
            continue

        face_count = len(photo_data.get("faces", []))
        confirmed_count = 0
        for face in photo_data.get("faces", []):
            identity = get_identity_for_face(registry, face.get("face_id", ""))
            if identity and identity.get("state") == "CONFIRMED":
                confirmed_count += 1

        photos.append({
            "photo_id": photo_id_val,
            "filename": photo_data.get("filename", "unknown"),
            "collection": collection,
            "face_count": face_count,
            "confirmed_count": confirmed_count,
            "match_reason": search_photo_ids.get(photo_id_val) if search_photo_ids else None,
        })

    collections = sorted(collections_set)

    # Sort
    if sort_by == "oldest":
        photos.sort(key=lambda p: p["filename"])
    elif sort_by == "most_faces":
        photos.sort(key=lambda p: p["face_count"], reverse=True)
    else:  # newest
        photos.sort(key=lambda p: p["filename"], reverse=True)

    # Build photo cards
    photo_cards = []
    for photo in photos:
        badge_cls = "bg-emerald-600/80" if photo["confirmed_count"] == photo["face_count"] and photo["face_count"] > 0 else "bg-black/70"

        # Date badge (bottom-left, confidence-styled)
        date_text, date_conf, date_tooltip = _get_date_badge(photo["photo_id"])
        date_badge = None
        if date_text:
            if date_conf == "high":
                date_cls = "bg-amber-800/80 text-amber-100"
            elif date_conf == "medium":
                date_cls = "bg-amber-800/50 border border-amber-600/50 text-amber-200/90"
            else:
                date_cls = "border border-dashed border-amber-600/40 text-amber-400/60"
            date_badge = Span(
                date_text,
                cls=f"absolute bottom-2 left-2 text-[11px] font-serif px-1.5 py-0.5 rounded backdrop-blur-sm {date_cls}",
                title=date_tooltip,
                data_testid="date-badge",
                data_confidence=date_conf,
            )

        # Match reason label when search is active
        match_label = None
        if photo.get("match_reason"):
            match_label = Div(
                Span(f"Matched: {photo['match_reason']}", cls="text-[10px] text-indigo-300/70 italic"),
                cls="px-2 pb-1",
                data_testid="match-reason",
            )

        photo_cards.append(
            A(
                Div(
                    Img(
                        src=photo_url(photo["filename"]),
                        cls="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300",
                        loading="lazy",
                    ),
                    Div(
                        f"{photo['confirmed_count']}/{photo['face_count']}" if photo["confirmed_count"] > 0 else f"{photo['face_count']} face{'s' if photo['face_count'] != 1 else ''}",
                        cls=f"absolute top-2 right-2 text-white text-xs px-2 py-1 rounded-full backdrop-blur-sm {badge_cls}",
                    ) if photo["face_count"] > 0 else None,
                    date_badge,
                    cls="aspect-[4/3] overflow-hidden relative",
                ),
                Div(
                    P(photo["collection"] or "", cls="text-xs text-slate-500 truncate"),
                    cls="p-2",
                ) if photo["collection"] else None,
                match_label,
                href=f"/photo/{photo['photo_id']}",
                cls="bg-slate-800 rounded-lg border border-slate-700 overflow-hidden hover:border-slate-500 transition-colors group block",
            )
        )

    # Build filter URL helper
    from urllib.parse import quote as _url_quote, urlencode as _url_encode

    def _filter_url(**overrides):
        """Build /photos URL preserving current filters with overrides."""
        params = {"filter_collection": filter_collection, "sort_by": sort_by,
                  "search_q": search_q, "tag": tag}
        if decade:
            params["decade"] = str(decade)
        params.update({k: v for k, v in overrides.items() if v})
        # Remove empty/None params
        params = {k: v for k, v in params.items() if v}
        qs = _url_encode(params)
        return f"/photos?{qs}" if qs else "/photos"

    # Collection + sort dropdowns
    collection_options = [Option("All Collections", value="")]
    for c in collections:
        collection_options.append(Option(c, value=c, selected=(filter_collection == c)))

    sort_options = [
        Option("Newest First", value="newest", selected=(sort_by == "newest")),
        Option("Oldest First", value="oldest", selected=(sort_by == "oldest")),
        Option("Most Faces", value="most_faces", selected=(sort_by == "most_faces")),
    ]

    # Decade pills
    decade_pills = [
        A("All",
          href=_filter_url(decade=""),
          cls="px-3 py-1 text-xs rounded-full transition-colors font-serif "
              + ("bg-amber-700 text-white" if not decade else "bg-slate-800 text-slate-400 hover:text-white border border-slate-700"))
    ]
    for dec, count in decade_counts.items():
        is_active = decade == dec
        decade_pills.append(
            A(f"{dec}s ({count})",
              href=_filter_url(decade=str(dec)),
              cls="px-3 py-1 text-xs rounded-full transition-colors font-serif "
                  + ("bg-amber-700 text-white" if is_active else "bg-slate-800 text-slate-400 hover:text-white border border-slate-700"),
              data_testid="decade-pill")
        )

    # Tag pills (top 8)
    top_tags = list(tag_counts.items())[:8]
    tag_pills = []
    for tag_name, tag_count in top_tags:
        display_name = tag_name.replace("_", " ")
        is_active = tag == tag_name
        tag_pills.append(
            A(f"{display_name} ({tag_count})",
              href=_filter_url(tag=tag_name if not is_active else ""),
              cls="px-2.5 py-1 text-[11px] rounded-full transition-colors "
                  + ("bg-indigo-600 text-white" if is_active else "bg-slate-800/60 text-slate-400 hover:text-white border border-slate-700/50"),
              data_testid="tag-pill")
        )

    nav_links = _public_nav_links(active="photos", user=user)

    # Active filter summary
    active_filters = []
    if decade:
        active_filters.append(f"{decade}s")
    if tag:
        active_filters.append(tag.replace("_", " "))
    if search_q:
        active_filters.append(f'"{search_q}"')
    subtitle = f"Showing {len(photos)} photo{'s' if len(photos) != 1 else ''}"
    if active_filters:
        subtitle += f" matching {' + '.join(active_filters)}"

    page_style = Style("html, body { margin: 0; } body { background-color: #0f172a; }")

    return (
        Title("Photos — Rhodesli Heritage Archive"),
        *og_tags("Photos — Rhodesli Heritage Archive",
                 f"{len(photos)} historical photographs from the Jewish community of Rhodes.",
                 canonical_url="/photos"),
        page_style,
        Main(
            Nav(
                Div(
                    A(Span("Rhodesli", cls="text-xl font-bold text-white"), href="/", cls="hover:opacity-90"),
                    Div(*nav_links, cls="hidden sm:flex items-center gap-6"),
                    cls="max-w-6xl mx-auto px-6 flex items-center justify-between h-16",
                ),
                cls="bg-slate-900/80 backdrop-blur-md border-b border-slate-800 sticky top-0 z-50",
            ),
            Section(
                Div(
                    Div(
                        H1("Photos", cls="text-3xl font-serif font-bold text-white mb-2"),
                        share_button(url="/photos", style="link", label="Share",
                                     title="Photos — Rhodesli", text="Browse historical photos from the Jewish community of Rhodes"),
                        cls="flex items-center justify-between",
                    ),
                    P(subtitle, cls="text-slate-400 text-sm"),
                    cls="max-w-6xl mx-auto px-6 pt-10 pb-4",
                ),
            ),
            Section(
                Div(
                    # Decade timeline pills
                    Div(*decade_pills, cls="flex flex-wrap gap-2 mb-3") if decade_pills else None,
                    # Search + tag row
                    Div(
                        # Search input
                        Div(
                            Input(
                                type="text",
                                name="search_q",
                                value=search_q,
                                placeholder="Search scenes, text, people...",
                                cls="bg-slate-800 border border-slate-700 text-slate-200 text-sm rounded-lg px-3 py-1.5 w-full sm:w-64 focus:ring-1 focus:ring-amber-500/50 focus:border-amber-500/50 placeholder-slate-500",
                                data_testid="photo-search",
                                onkeydown=f"if(event.key==='Enter')window.location.href='/photos?search_q='+encodeURIComponent(this.value)+'&decade={decade or ''}&tag={_url_quote(tag)}&filter_collection={_url_quote(filter_collection)}&sort_by={sort_by}'",
                            ),
                            cls="flex-shrink-0",
                        ),
                        # Tag pills
                        Div(*tag_pills, cls="flex flex-wrap gap-1.5") if tag_pills else None,
                        cls="flex flex-wrap items-center gap-3 mb-3",
                    ),
                    # Collection/sort dropdowns
                    Div(
                        Select(
                            *collection_options,
                            cls="bg-slate-700 border border-slate-600 text-slate-200 text-sm rounded-lg px-3 py-1.5",
                            onchange=f"window.location.href='/photos?filter_collection=' + encodeURIComponent(this.value) + '&sort_by={sort_by}&decade={decade or ''}&search_q={_url_quote(search_q)}&tag={_url_quote(tag)}'",
                        ),
                        Select(
                            *sort_options,
                            cls="bg-slate-700 border border-slate-600 text-slate-200 text-sm rounded-lg px-3 py-1.5",
                            onchange=f"window.location.href='/photos?filter_collection={_url_quote(filter_collection)}&sort_by=' + this.value + '&decade={decade or ''}&search_q={_url_quote(search_q)}&tag={_url_quote(tag)}'",
                        ),
                        Span(f"{len(photos)} result{'s' if len(photos) != 1 else ''}", cls="text-xs text-slate-500 ml-auto"),
                        cls="flex flex-wrap items-center gap-3 mb-6",
                    ),
                    # Photo grid
                    Div(*photo_cards, id="photo-grid", cls="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4") if photo_cards else Div(
                        P("No photos match your filters.", cls="text-slate-500 text-center py-12"),
                        A("Clear filters", href="/photos", cls="text-indigo-400 hover:text-indigo-300 text-sm block text-center mt-2"),
                    ),
                    cls="max-w-6xl mx-auto px-6 pb-10",
                ),
            ),
            # Footer
            Div(
                Div(
                    P("Rhodesli Heritage Archive", cls="text-xs text-slate-500 mb-1 font-serif"),
                    P("Preserving the memory of the Jewish community of Rhodes", cls="text-[10px] text-slate-600 italic"),
                    cls="max-w-6xl mx-auto px-6 flex flex-col items-center",
                ),
                cls="py-8 border-t border-slate-800",
            ),
            cls="min-h-screen bg-slate-900",
        ),
    )


@rt("/people")
def get(sort_by: str = "name", sess=None):
    """
    Public people browsing page — grid of identified people.

    No authentication required. Each person links to /person/{id}.
    No admin actions visible.
    """
    user = get_current_user(sess or {}) if is_auth_enabled() else None

    registry = load_registry()
    crop_files = get_crop_files()

    # Get confirmed identities with real names
    confirmed = [
        i for i in registry.list_identities(state=IdentityState.CONFIRMED)
        if not i.get("name", "").startswith("Unidentified") and not i.get("merged_into")
    ]

    # Sort
    if sort_by == "photos":
        photo_reg = load_photo_registry()
        def photo_count(identity):
            face_ids = [f if isinstance(f, str) else f.get("face_id", "") for f in identity.get("anchor_ids", []) + identity.get("candidate_ids", [])]
            return len(photo_reg.get_photos_for_faces(face_ids))
        confirmed.sort(key=photo_count, reverse=True)
    elif sort_by == "newest":
        confirmed.sort(key=lambda x: x.get("updated_at", x.get("created_at", "")), reverse=True)
    else:  # name
        confirmed.sort(key=lambda x: (x.get("name") or "").lower())

    # Build person cards
    person_cards = []
    for identity in confirmed:
        identity_id = identity["identity_id"]
        name = ensure_utf8_display(identity.get("name", ""))
        all_faces = identity.get("anchor_ids", []) + identity.get("candidate_ids", [])
        best_face = get_best_face_id(all_faces)
        crop_url = resolve_face_image_url(best_face, crop_files) if best_face and crop_files else None
        face_count = len(all_faces)

        avatar = Img(
            src=crop_url,
            alt=name,
            cls="w-24 h-24 rounded-full object-cover border-3 border-emerald-500/30",
            onerror="this.style.display='none'",
        ) if crop_url else Div(
            Span(name[0].upper() if name else "?", cls="text-2xl font-serif text-slate-400"),
            cls="w-24 h-24 rounded-full bg-slate-800 border-3 border-slate-700 flex items-center justify-center",
        )

        person_cards.append(
            A(
                avatar,
                P(name, cls="text-sm font-medium text-white mt-3 text-center"),
                P(f"{face_count} {'photo' if face_count == 1 else 'photos'}", cls="text-[10px] text-slate-500 mt-1"),
                href=f"/person/{identity_id}",
                cls="flex flex-col items-center p-4 bg-slate-800/50 rounded-xl border border-slate-700 hover:border-emerald-500/30 transition-colors group block",
            )
        )

    sort_options = [
        Option("A-Z", value="name", selected=(sort_by == "name")),
        Option("Most Photos", value="photos", selected=(sort_by == "photos")),
        Option("Newest", value="newest", selected=(sort_by == "newest")),
    ]

    nav_links = _public_nav_links(active="people", user=user)

    page_style = Style("html, body { margin: 0; } body { background-color: #0f172a; }")

    return (
        Title("People — Rhodesli Heritage Archive"),
        *og_tags("People — Rhodesli Heritage Archive",
                 f"{len(confirmed)} identified people in the Rhodes heritage archive.",
                 canonical_url="/people"),
        page_style,
        Main(
            Nav(
                Div(
                    A(Span("Rhodesli", cls="text-xl font-bold text-white"), href="/", cls="hover:opacity-90"),
                    Div(*nav_links, cls="hidden sm:flex items-center gap-6"),
                    cls="max-w-6xl mx-auto px-6 flex items-center justify-between h-16",
                ),
                cls="bg-slate-900/80 backdrop-blur-md border-b border-slate-800 sticky top-0 z-50",
            ),
            Section(
                Div(
                    Div(
                        H1("People", cls="text-3xl font-serif font-bold text-white mb-2"),
                        share_button(url="/people", style="link", label="Share",
                                     title="People — Rhodesli", text="Browse identified people in the Rhodes heritage archive"),
                        cls="flex items-center justify-between",
                    ),
                    P(f"{len(confirmed)} identified {'person' if len(confirmed) == 1 else 'people'} in the archive", cls="text-slate-400 text-sm"),
                    cls="max-w-6xl mx-auto px-6 pt-10 pb-6",
                ),
            ),
            Section(
                Div(
                    Div(
                        Span("Sort:", cls="text-sm text-slate-400 mr-2"),
                        Select(
                            *sort_options,
                            cls="bg-slate-700 border border-slate-600 text-slate-200 text-sm rounded-lg px-3 py-1.5",
                            onchange="window.location.href='/people?sort_by=' + this.value",
                        ),
                        cls="flex items-center gap-2 mb-6",
                    ),
                    Div(
                        *person_cards,
                        cls="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4",
                    ) if person_cards else Div(
                        P("No identified people yet. Help us identify faces in the archive!", cls="text-slate-500 text-center py-12"),
                    ),
                    cls="max-w-6xl mx-auto px-6 pb-10",
                ),
            ),
            # CTA
            Section(
                Div(
                    H3("Can you help identify someone?", cls="text-lg font-serif text-white mb-2"),
                    P("Browse the photos and let us know if you recognize anyone.", cls="text-slate-400 text-sm mb-4"),
                    A("Browse Photos", href="/photos",
                      cls="inline-block px-5 py-2.5 bg-indigo-600 hover:bg-indigo-500 text-white text-sm font-medium rounded-lg transition-colors"),
                    cls="text-center",
                ),
                cls="py-12 border-t border-slate-800",
            ),
            # Footer
            Div(
                Div(
                    P("Rhodesli Heritage Archive", cls="text-xs text-slate-500 mb-1 font-serif"),
                    P("Preserving the memory of the Jewish community of Rhodes", cls="text-[10px] text-slate-600 italic"),
                    cls="max-w-6xl mx-auto px-6 flex flex-col items-center",
                ),
                cls="py-8 border-t border-slate-800",
            ),
            cls="min-h-screen bg-slate-900",
        ),
    )


# ---- Collection Pages ----


def _collection_slug(name: str) -> str:
    """Convert collection name to URL slug."""
    return re.sub(r'[^a-z0-9]+', '-', name.lower()).strip('-')


def _collection_from_slug(slug: str, collections: dict) -> str:
    """Find collection name from slug."""
    for name in collections:
        if _collection_slug(name) == slug:
            return name
    return ""


def _get_collections_data():
    """Build collection metadata from photo_index."""
    photo_reg = load_photo_registry()
    registry = load_registry()
    photos = photo_reg.list_photos() if hasattr(photo_reg, 'list_photos') else []

    # Fall back to raw photo_index if list_photos not available
    if not photos:
        pi_path = data_path / "photo_index.json"
        if pi_path.exists():
            pi = json.loads(pi_path.read_text(encoding="utf-8"))
            photos = list(pi.get("photos", {}).values())
            for p in photos:
                if "photo_id" not in p:
                    # Try to generate from path
                    path = p.get("path", "")
                    if path:
                        p["photo_id"] = hashlib.sha256(Path(path).name.encode()).hexdigest()[:16]

    collections = {}
    for photo in photos:
        col_name = photo.get("collection", "") or photo.get("source", "")
        if not col_name:
            continue
        if col_name not in collections:
            collections[col_name] = {
                "name": col_name,
                "slug": _collection_slug(col_name),
                "photos": [],
                "identified_count": 0,
                "unidentified_count": 0,
            }
        collections[col_name]["photos"].append(photo)

    # Count identified vs unidentified faces per collection
    for col_name, col_data in collections.items():
        identified = set()
        unidentified = 0
        for photo in col_data["photos"]:
            for fid in photo.get("face_ids", []):
                ident = get_identity_for_face(registry, fid)
                if ident and ident.get("state") == "CONFIRMED" and not ident.get("name", "").startswith("Unidentified"):
                    identified.add(ident.get("identity_id"))
                elif ident:
                    unidentified += 1
        col_data["identified_count"] = len(identified)
        col_data["unidentified_count"] = unidentified

    return collections


@rt("/collections")
def get(sess=None):
    """Collection directory — list all collections with preview thumbnails."""
    user = get_current_user(sess or {}) if is_auth_enabled() else None

    collections = _get_collections_data()

    # Build collection cards
    cards = []
    for col_name in sorted(collections.keys(), key=lambda n: -len(collections[n]["photos"])):
        col = collections[col_name]
        photo_count = len(col["photos"])
        slug = col["slug"]

        # Preview thumbnails (first 4 photos)
        previews = []
        for photo in col["photos"][:4]:
            photo_path = photo.get("path", "")
            if photo_path:
                url = storage.get_photo_url(photo_path)
                previews.append(
                    Img(src=url, alt="", cls="w-full h-24 object-cover rounded",
                        loading="lazy", onerror="this.style.display='none'")
                )

        preview_grid = Div(*previews, cls="grid grid-cols-2 gap-1 mb-3") if previews else ""

        # Face counts
        face_line = f"{col['identified_count']} identified"
        if col['unidentified_count'] > 0:
            face_line += f", {col['unidentified_count']} unknown"

        cards.append(
            A(
                preview_grid,
                H3(col_name, cls="text-white font-semibold text-sm mb-1 line-clamp-2"),
                P(f"{photo_count} photo{'s' if photo_count != 1 else ''}", cls="text-xs text-slate-400"),
                P(face_line, cls="text-xs text-slate-500 mt-0.5"),
                href=f"/collection/{slug}",
                cls="block bg-slate-800/50 rounded-xl p-4 border border-slate-700/50 hover:border-indigo-500/50 transition-colors",
                data_testid="collection-card",
            )
        )

    nav_links = _public_nav_links(active="collections", user=user)

    page_style = Style("html, body { margin: 0; } body { background-color: #0f172a; }")

    return (
        Title("Collections — Rhodesli"),
        *og_tags("Collections — Rhodesli Heritage Archive",
                 "Browse photo collections from the Rhodes-Capeluto family archive.",
                 canonical_url="/collections"),
        page_style,
        Div(
            Nav(
                Div(
                    A(Span("Rhodesli", cls="text-xl font-bold text-white"), href="/", cls="hover:opacity-90"),
                    Div(*nav_links, cls="hidden sm:flex items-center gap-6"),
                    cls="max-w-6xl mx-auto px-6 flex items-center justify-between",
                ),
                cls="fixed top-0 left-0 right-0 h-16 bg-slate-900/80 backdrop-blur-md border-b border-slate-800 z-50",
            ),
            Div(
                Div(
                    H1("Collections", cls="text-2xl md:text-3xl font-bold text-white mb-2"),
                    share_button(url="/collections", style="link", label="Share",
                                 title="Collections — Rhodesli", text="Browse photo collections from the Rhodes heritage archive"),
                    cls="flex items-center justify-between",
                ),
                P(f"{len(collections)} collection{'s' if len(collections) != 1 else ''} in the archive", cls="text-slate-400 mb-8"),
                Div(*cards, cls="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"),
                cls="max-w-6xl mx-auto px-6 pt-24 pb-16",
            ),
            cls="min-h-screen bg-slate-900",
        ),
    )


@rt("/collection/{slug}")
def get(slug: str, sess=None):
    """Collection detail page — shareable view of all photos in a collection."""
    user = get_current_user(sess or {}) if is_auth_enabled() else None

    collections = _get_collections_data()
    col_name = _collection_from_slug(slug, collections)

    if not col_name or col_name not in collections:
        page_style = Style("html, body { margin: 0; } body { background-color: #0f172a; }")
        return (
            Title("Collection Not Found — Rhodesli"),
            page_style,
            Div(
                Div(
                    H1("Collection Not Found", cls="text-2xl font-bold text-white mb-4"),
                    P("This collection doesn't exist.", cls="text-slate-400"),
                    A("Browse all collections →", href="/collections", cls="text-indigo-400 hover:text-indigo-300 mt-4 inline-block"),
                    cls="max-w-4xl mx-auto px-6 pt-24",
                ),
                cls="min-h-screen bg-slate-900",
            ),
        )

    col = collections[col_name]
    photos = col["photos"]
    registry = load_registry()

    # Build photo grid
    photo_cards = []
    for photo in photos:
        photo_path = photo.get("path", "")
        photo_id = photo.get("photo_id", "")
        if not photo_path:
            continue
        url = storage.get_photo_url(photo_path)

        # Count faces
        face_ids = photo.get("face_ids", [])
        identified = 0
        unknown = 0
        for fid in face_ids:
            ident = get_identity_for_face(registry, fid)
            if ident and ident.get("state") == "CONFIRMED" and not ident.get("name", "").startswith("Unidentified"):
                identified += 1
            elif ident:
                unknown += 1

        face_badge = ""
        if identified + unknown > 0:
            badge_text = f"{identified} named"
            if unknown > 0:
                badge_text += f", {unknown} unknown"
            face_badge = Div(
                badge_text,
                cls="absolute bottom-1 left-1 text-[10px] px-1.5 py-0.5 rounded bg-black/70 text-slate-300",
            )

        photo_cards.append(
            A(
                Div(
                    Img(src=url, alt="", cls="w-full h-40 md:h-48 object-cover",
                        loading="lazy", onerror="this.style.display='none'"),
                    face_badge if face_badge else None,
                    cls="relative rounded-lg overflow-hidden",
                ),
                href=f"/photo/{photo_id}" if photo_id else "#",
                cls="block hover:opacity-90 transition-opacity",
                data_testid="collection-photo",
            )
        )

    # People in this collection
    people_in_collection = set()
    for photo in photos:
        for fid in photo.get("face_ids", []):
            ident = get_identity_for_face(registry, fid)
            if ident and ident.get("state") == "CONFIRMED" and not ident.get("name", "").startswith("Unidentified"):
                people_in_collection.add(ident.get("identity_id"))

    people_section = ""
    if people_in_collection:
        people_items = []
        for pid in sorted(people_in_collection, key=lambda x: _safe_get_identity(registry, x).get("name", "").lower()):
            p_ident = _safe_get_identity(registry, pid)
            p_name = ensure_utf8_display(p_ident.get("name", "Unknown"))
            people_items.append(
                A(p_name, href=f"/person/{pid}",
                  cls="inline-block px-2.5 py-1 text-xs rounded-full bg-slate-800/60 text-slate-300 hover:text-white border border-slate-700/50 hover:border-indigo-500/50 transition-colors")
            )
        people_section = Div(
            H3(f"People in this Collection ({len(people_in_collection)})", cls="text-sm font-semibold text-slate-300 mb-3"),
            Div(*people_items, cls="flex flex-wrap gap-2"),
            cls="mt-8",
        )

    nav_links = _public_nav_links(active="collections", user=user)

    share_url = f"/collection/{slug}"

    page_style = Style("html, body { margin: 0; } body { background-color: #0f172a; }")

    return (
        Title(f"{col_name} — Rhodesli"),
        Meta(property="og:title", content=f"{col_name} — Rhodesli Heritage Archive"),
        Meta(property="og:description", content=f"Browse {len(photos)} photos from the {col_name}."),
        Meta(property="og:url", content=f"{SITE_URL}{share_url}"),
        page_style,
        Div(
            Nav(
                Div(
                    A(Span("Rhodesli", cls="text-xl font-bold text-white"), href="/", cls="hover:opacity-90"),
                    Div(*nav_links, cls="hidden sm:flex items-center gap-6"),
                    cls="max-w-6xl mx-auto px-6 flex items-center justify-between",
                ),
                cls="fixed top-0 left-0 right-0 h-16 bg-slate-900/80 backdrop-blur-md border-b border-slate-800 z-50",
            ),
            Div(
                # Breadcrumb
                Div(
                    A("Collections", href="/collections", cls="text-indigo-400 hover:text-indigo-300 text-sm"),
                    Span(" / ", cls="text-slate-600 mx-2"),
                    Span(col_name, cls="text-slate-300 text-sm"),
                    cls="mb-6",
                ),

                # Header
                Div(
                    H1(col_name, cls="text-2xl md:text-3xl font-bold text-white mb-2"),
                    Div(
                        Span(f"{len(photos)} photo{'s' if len(photos) != 1 else ''}", cls="text-slate-400"),
                        Span(" · ", cls="text-slate-600 mx-2"),
                        Span(f"{col['identified_count']} people identified", cls="text-emerald-400"),
                        cls="text-sm mb-4",
                    ),
                    # Action buttons
                    Div(
                        Button(
                            NotStr(_SHARE_ICON_SVG),
                            " Share Collection",
                            cls="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-500 text-white text-sm rounded-lg transition-colors inline-flex items-center gap-1",
                            type="button",
                            data_action="share-photo",
                            data_share_url=share_url,
                        ),
                        A("View on Timeline →", href=f"/timeline?collection={quote(col_name)}",
                          cls="text-sm text-indigo-400 hover:text-indigo-300 ml-4"),
                        A("+ Add Photos", href="/upload",
                          cls="px-3 py-1.5 bg-emerald-700 hover:bg-emerald-600 text-white text-sm rounded-lg transition-colors inline-flex items-center gap-1 ml-3") if (user and user.is_admin if is_auth_enabled() else False) else None,
                        cls="flex items-center flex-wrap gap-2 mb-6",
                    ),
                    cls="mb-6",
                ),

                # Help identify banner
                Div(
                    P(f"{col['unidentified_count']} face{'s' if col['unidentified_count'] != 1 else ''} waiting to be identified in this collection.",
                      cls="text-sm text-slate-300"),
                    A("Help Identify →", href="/compare", cls="text-sm text-indigo-400 hover:text-indigo-300 font-medium ml-4"),
                    cls="bg-blue-900/20 border border-blue-800/30 rounded-lg px-4 py-3 flex items-center justify-between mb-6",
                    data_testid="help-identify-banner",
                ) if col['unidentified_count'] > 0 else "",

                # Photo grid
                Div(*photo_cards, cls="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-3"),

                # People section
                people_section,

                cls="max-w-6xl mx-auto px-6 pt-24 pb-16",
            ),
            cls="min-h-screen bg-slate-900",
        ),
    )


_photo_locations_cache = None


def _load_photo_locations() -> dict:
    """Load geocoded photo locations (photo_id -> location info).

    Returns dict keyed by photo_id with lat, lng, location_name, etc.
    """
    global _photo_locations_cache
    if _photo_locations_cache is not None:
        return _photo_locations_cache

    _photo_locations_cache = {}
    locations_path = Path(DATA_DIR) / "photo_locations.json"
    if locations_path.exists():
        try:
            data = json.loads(locations_path.read_text())
            _photo_locations_cache = data.get("photos", {})
        except Exception:
            pass
    return _photo_locations_cache


@rt("/map")
def get(collection: str = "", person: str = "", decade: str = "", sess=None):
    """Interactive map view of photo locations across the Rhodes Jewish diaspora."""
    user = get_current_user(sess or {}) if is_auth_enabled() else None

    _build_caches()
    locations = _load_photo_locations()
    registry = load_registry()
    photo_reg = load_photo_registry()
    date_labels = _load_date_labels()

    # Build markers with photo data
    markers = []
    location_groups = {}  # group photos by location key for clustering

    for photo_id, loc in locations.items():
        # Apply filters
        if collection:
            photo_data = (_photo_cache or {}).get(photo_id, {})
            if not photo_data:
                # Try photo registry
                photo_data = photo_reg._photos.get(photo_id, {})
            photo_collection = photo_data.get("collection", "")
            if collection.lower() not in photo_collection.lower():
                continue

        if person:
            photo_data = (_photo_cache or {}).get(photo_id, {})
            if not photo_data:
                photo_data = photo_reg._photos.get(photo_id, {})
            face_ids = photo_data.get("face_ids", [])
            person_found = False
            for fid in face_ids:
                ident = get_identity_for_face(registry, fid)
                if ident and ident.get("identity_id") == person:
                    person_found = True
                    break
            if not person_found:
                continue

        if decade:
            label = date_labels.get(photo_id, {})
            photo_decade = label.get("estimated_decade", 0)
            try:
                if photo_decade != int(decade):
                    continue
            except (ValueError, TypeError):
                continue

        loc_key = loc.get("location_key", "unknown")
        if loc_key not in location_groups:
            location_groups[loc_key] = {
                "lat": loc["lat"],
                "lng": loc["lng"],
                "name": loc["location_name"],
                "region": loc.get("region", ""),
                "photos": [],
            }

        # Get photo metadata
        photo_data = (_photo_cache or {}).get(photo_id, {})
        if not photo_data:
            photo_data = photo_reg._photos.get(photo_id, {})
        photo_path = photo_data.get("path", photo_data.get("filename", ""))
        photo_url_val = storage.get_photo_url(photo_path) if photo_path else ""

        # Get date info
        label = date_labels.get(photo_id, {})
        est_decade = label.get("estimated_decade", 0)

        location_groups[loc_key]["photos"].append({
            "photo_id": photo_id,
            "url": photo_url_val,
            "decade": est_decade,
            "collection": photo_data.get("collection", ""),
        })

    # Convert to marker list for JSON
    for loc_key, group in location_groups.items():
        markers.append({
            "lat": group["lat"],
            "lng": group["lng"],
            "name": group["name"],
            "region": group["region"],
            "count": len(group["photos"]),
            "photos": group["photos"][:8],  # Limit preview photos
            "total": len(group["photos"]),
        })

    markers_json = json.dumps(markers)

    # Build filter options
    all_collections = set()
    all_decades = set()
    for pid, loc in locations.items():
        pd = (_photo_cache or {}).get(pid, {})
        if not pd:
            pd = photo_reg._photos.get(pid, {})
        c = pd.get("collection", "")
        if c:
            all_collections.add(c)
        lbl = date_labels.get(pid, {})
        d = lbl.get("estimated_decade", 0)
        if d:
            all_decades.add(d)

    # People options
    all_people = []
    for ident in registry.list_identities(state=IdentityState.CONFIRMED):
        if not ident.get("name", "").startswith("Unidentified"):
            all_people.append({"id": ident.get("identity_id", ""), "name": ensure_utf8_display(ident.get("name", ""))})
    all_people.sort(key=lambda x: x["name"].lower())

    collection_options = [Option("All collections", value="")] + [
        Option(c, value=c, selected=(c == collection)) for c in sorted(all_collections)
    ]
    decade_options = [Option("All decades", value="")] + [
        Option(f"{d}s", value=str(d), selected=(str(d) == decade)) for d in sorted(all_decades)
    ]
    person_options = [Option("All people", value="")] + [
        Option(p["name"], value=p["id"], selected=(p["id"] == person)) for p in all_people
    ]

    nav_links = _public_nav_links(active="map", user=user)

    # Share URL with current filters
    share_params = []
    if collection:
        share_params.append(f"collection={quote(collection)}")
    if person:
        share_params.append(f"person={person}")
    if decade:
        share_params.append(f"decade={decade}")
    share_url = "/map" + ("?" + "&".join(share_params) if share_params else "")

    # Summary text
    total_photos = sum(m["total"] for m in markers)
    total_locations = len(markers)
    summary = f"{total_photos} photo{'s' if total_photos != 1 else ''} across {total_locations} location{'s' if total_locations != 1 else ''}"

    page_style = Style("""
        html, body { margin: 0; }
        body { background-color: #0f172a; }
        #map-container { height: calc(100vh - 180px); min-height: 400px; border-radius: 12px; overflow: hidden; }
        .leaflet-popup-content { max-width: 280px; }
        .leaflet-popup-content-wrapper { background: #1e293b; color: #e2e8f0; border-radius: 8px; }
        .leaflet-popup-tip { background: #1e293b; }
        .leaflet-popup-close-button { color: #94a3b8 !important; }
        .photo-preview-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px; margin-top: 8px; }
        .photo-preview-grid img { width: 100%; height: 60px; object-fit: cover; border-radius: 4px; cursor: pointer; }
    """)

    leaflet_css = Link(rel="stylesheet", href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css")
    leaflet_js = Script(src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js")
    marker_cluster_css = Link(rel="stylesheet", href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css")
    marker_cluster_default_css = Link(rel="stylesheet", href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css")
    marker_cluster_js = Script(src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js")

    map_script = Script(f"""
    document.addEventListener('DOMContentLoaded', function() {{
        var markers = {markers_json};

        var map = L.map('map-container').setView([35.0, -20.0], 3);

        L.tileLayer('https://{{s}}.basemaps.cartocdn.com/dark_all/{{z}}/{{x}}/{{y}}{{r}}.png', {{
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> &copy; <a href="https://carto.com/">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 19
        }}).addTo(map);

        var cluster = L.markerClusterGroup({{
            maxClusterRadius: 50,
            iconCreateFunction: function(cluster) {{
                var count = 0;
                cluster.getAllChildMarkers().forEach(function(m) {{ count += m.options.photoCount || 1; }});
                var size = count > 50 ? 'large' : count > 20 ? 'medium' : 'small';
                return L.divIcon({{
                    html: '<div style="background:#6366f1;color:white;border-radius:50%;width:40px;height:40px;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:13px;border:2px solid #818cf8;">' + count + '</div>',
                    className: 'custom-cluster-icon',
                    iconSize: [40, 40]
                }});
            }}
        }});

        markers.forEach(function(m) {{
            var photosHtml = '';
            if (m.photos && m.photos.length > 0) {{
                photosHtml = '<div class="photo-preview-grid">';
                m.photos.forEach(function(p) {{
                    photosHtml += '<img src="' + p.url + '" alt="" onclick="window.location.href=\\'/photo/' + p.photo_id + '\\'" onerror="this.style.display=\\'none\\'">';
                }});
                photosHtml += '</div>';
            }}
            var moreText = m.total > 8 ? '<div style="text-align:center;margin-top:6px;"><a href="/photos?q=' + encodeURIComponent(m.name) + '" style="color:#818cf8;font-size:12px;">See all ' + m.total + ' photos &rarr;</a></div>' : '';

            var popupContent = '<div>' +
                '<strong style="font-size:14px;">' + m.name + '</strong>' +
                '<div style="color:#94a3b8;font-size:12px;margin-top:2px;">' + m.region + ' &middot; ' + m.count + ' photo' + (m.count !== 1 ? 's' : '') + '</div>' +
                photosHtml + moreText +
                '</div>';

            var icon = L.divIcon({{
                html: '<div style="background:#6366f1;color:white;border-radius:50%;width:32px;height:32px;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:12px;border:2px solid #818cf8;box-shadow:0 2px 8px rgba(0,0,0,0.3);">' + m.count + '</div>',
                className: 'custom-marker-icon',
                iconSize: [32, 32],
                iconAnchor: [16, 16],
                popupAnchor: [0, -16]
            }});

            var marker = L.marker([m.lat, m.lng], {{ icon: icon, photoCount: m.count }});
            marker.bindPopup(popupContent, {{ maxWidth: 300 }});
            cluster.addLayer(marker);
        }});

        map.addLayer(cluster);

        /* Fit bounds if markers exist */
        if (markers.length > 0) {{
            var bounds = L.latLngBounds(markers.map(function(m) {{ return [m.lat, m.lng]; }}));
            map.fitBounds(bounds, {{ padding: [50, 50], maxZoom: 6 }});
        }}
    }});
    """)

    return (
        Title("Map — Rhodesli"),
        Meta(property="og:title", content="Map — Rhodesli Heritage Archive"),
        Meta(property="og:description", content=f"Explore {total_photos} photos across {total_locations} locations in the Rhodes Jewish diaspora."),
        Meta(property="og:url", content=f"{SITE_URL}{share_url}"),
        leaflet_css,
        marker_cluster_css,
        marker_cluster_default_css,
        page_style,
        Div(
            Nav(
                Div(
                    A(Span("Rhodesli", cls="text-xl font-bold text-white"), href="/", cls="hover:opacity-90"),
                    Div(*nav_links, cls="hidden sm:flex items-center gap-6"),
                    cls="max-w-6xl mx-auto px-6 flex items-center justify-between",
                ),
                cls="fixed top-0 left-0 right-0 h-16 bg-slate-900/80 backdrop-blur-md border-b border-slate-800 z-50",
            ),
            Div(
                # Header
                Div(
                    H1("Map", cls="text-2xl md:text-3xl font-bold text-white mb-1"),
                    P(summary, cls="text-slate-400 text-sm mb-4"),
                    cls="mb-2",
                ),
                # Filters
                Div(
                    Form(
                        Select(*collection_options, name="collection", cls="bg-slate-800 text-slate-300 text-xs rounded-lg px-2 py-1.5 border border-slate-700",
                               onchange="this.form.submit()"),
                        Select(*person_options, name="person", cls="bg-slate-800 text-slate-300 text-xs rounded-lg px-2 py-1.5 border border-slate-700",
                               onchange="this.form.submit()"),
                        Select(*decade_options, name="decade", cls="bg-slate-800 text-slate-300 text-xs rounded-lg px-2 py-1.5 border border-slate-700",
                               onchange="this.form.submit()"),
                        Button(
                            NotStr(_SHARE_ICON_SVG),
                            " Share",
                            cls="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-500 text-white text-xs rounded-lg transition-colors inline-flex items-center gap-1",
                            type="button",
                            data_action="share-photo",
                            data_share_url=share_url,
                        ),
                        method="get",
                        action="/map",
                        cls="flex flex-wrap items-center gap-2",
                    ),
                    cls="mb-4",
                ),
                # Map container
                Div(id="map-container", data_testid="map-container"),
                # Legend
                Div(
                    Span("Locations sized by photo count", cls="text-xs text-slate-500"),
                    Span(" · ", cls="text-slate-700 mx-2"),
                    Span("Click markers to see photos", cls="text-xs text-slate-500"),
                    Span(" · ", cls="text-slate-700 mx-2"),
                    A("View Timeline →", href="/timeline", cls="text-xs text-indigo-400 hover:text-indigo-300"),
                    cls="mt-3 text-center",
                ),
                cls="max-w-6xl mx-auto px-6 pt-24 pb-8",
            ),
            cls="min-h-screen bg-slate-900",
        ),
        leaflet_js,
        marker_cluster_js,
        map_script,
    )


@rt("/timeline")
def get(person: str = "", people: str = "", start: int = None, end: int = None,
        context: str = "on", collection: str = "", sess=None):
    """
    Public timeline page — chronological story of the archive.

    Shows photos and historical context events on a vertical timeline,
    grouped by decade. Supports person/multi-person filter (with age overlay),
    year range filter, collection filter, and shareable URLs.

    Query params:
        person: single identity_id to filter by (backwards compat)
        people: comma-separated identity_ids for multi-person filter
        start: start year for range filter
        end: end year for range filter
        context: "on" (default) or "off" to toggle context events
        collection: collection name to filter by
    """
    user = get_current_user(sess or {}) if is_auth_enabled() else None

    _build_caches()
    registry = load_registry()
    photo_reg = load_photo_registry()
    crop_files = get_crop_files()

    # Load data sources
    search_docs = _load_search_index()
    date_labels = _load_date_labels()
    context_events = _load_context_events() if context != "off" else []

    # Build person lookup for filter
    confirmed = [
        i for i in registry.list_identities(state=IdentityState.CONFIRMED)
        if not i.get("name", "").startswith("Unidentified") and not i.get("merged_into")
    ]
    confirmed.sort(key=lambda x: (x.get("name") or "").lower())

    # Resolve person filter — support both single and multi-person
    person_ids = []
    if people:
        person_ids = [p.strip() for p in people.split(",") if p.strip()]
    elif person:
        person_ids = [person]

    person_identities = []
    person_photo_ids = None
    # Map photo_id -> set of person names appearing in it (for multi-person cards)
    photo_person_map = {}
    if person_ids:
        person_photo_ids = set()
        for pid in person_ids:
            try:
                ident = registry.get_identity(pid)
            except KeyError:
                continue
            if not ident:
                continue
            person_identities.append(ident)
            face_ids = [f if isinstance(f, str) else f.get("face_id", "")
                        for f in ident.get("anchor_ids", []) + ident.get("candidate_ids", [])]
            pname = ensure_utf8_display(ident.get("name", ""))
            for fid in face_ids:
                photo_id = get_photo_id_for_face(fid)
                if photo_id:
                    person_photo_ids.add(photo_id)
                    photo_person_map.setdefault(photo_id, set()).add(pname)

    # For backwards compat, keep person_identity for single-person features (age badge)
    person_identity = person_identities[0] if len(person_identities) == 1 else None

    # Build timeline entries from photos
    timeline_entries = []
    for doc in search_docs:
        photo_id = doc.get("cache_photo_id", doc.get("photo_id", ""))
        best_year = doc.get("best_year_estimate")
        decade = doc.get("estimated_decade")
        if not best_year and not decade:
            continue

        year = best_year or decade
        if not year:
            continue

        # Apply year range filter
        if start and year < start:
            continue
        if end and year > end:
            continue

        # Apply person filter
        if person_photo_ids is not None and photo_id not in person_photo_ids:
            continue

        # Get photo metadata
        photo_data = (_photo_cache or {}).get(photo_id, {})
        filename = photo_data.get("filename", "")

        # Get collection and apply collection filter
        photo_collection = photo_data.get("collection", "")
        if collection and photo_collection != collection:
            continue

        # Get date label details
        label = date_labels.get(photo_id, {})
        prob_range = label.get("probable_range", [])
        confidence = label.get("confidence", "medium")

        # Count identified people in photo
        faces = photo_data.get("faces", [])
        people_names = []
        for face in faces:
            fid = face.get("face_id", "")
            ident = get_identity_for_face(registry, fid)
            if ident and ident.get("state") == "CONFIRMED" and not ident.get("name", "").startswith("Unidentified"):
                people_names.append(ident["name"])

        # For multi-person, note which filtered people appear in this photo
        highlighted_people = []
        if photo_person_map and photo_id in photo_person_map:
            highlighted_people = sorted(photo_person_map[photo_id])

        timeline_entries.append({
            "type": "photo",
            "year": year,
            "decade": decade or (year // 10 * 10),
            "photo_id": photo_id,
            "filename": filename,
            "collection": photo_collection,
            "confidence": confidence,
            "prob_range": prob_range,
            "people": people_names,
            "highlighted_people": highlighted_people,
            "scene": label.get("scene_description", ""),
        })

    # When person filter active, compute photo date range for era filtering
    person_era_start = None
    person_era_end = None
    if person_photo_ids is not None and timeline_entries:
        photo_years = [e["year"] for e in timeline_entries if e["type"] == "photo"]
        if photo_years:
            person_era_start = min(photo_years) - 30  # 30 years before earliest photo
            person_era_end = max(photo_years) + 10    # 10 years after latest photo

    # Add context events
    for event in context_events:
        year = event.get("year", 0)
        if start and year < start:
            continue
        if end and year > end:
            continue

        # Filter context events to person's era when person filter is active
        if person_era_start is not None:
            if year < person_era_start or year > person_era_end:
                continue

        timeline_entries.append({
            "type": "context",
            "year": year,
            "decade": year // 10 * 10,
            "title": event.get("title", ""),
            "description": event.get("description", ""),
            "category": event.get("category", ""),
            "source": event.get("source", ""),
        })

    # Sort by year
    timeline_entries.sort(key=lambda e: e["year"])

    # Group by decade
    decades_order = []
    decades_map = {}
    for entry in timeline_entries:
        dec = entry["decade"]
        if dec not in decades_map:
            decades_map[dec] = []
            decades_order.append(dec)
        decades_map[dec].append(entry)

    # Compute age if person has confirmed birth_year (Gatekeeper: public sees confirmed only)
    person_birth_year = None
    birth_year_source = None
    birth_year_confidence = None
    if person_identity:
        iid = person_identity.get("identity_id", "")
        person_birth_year, birth_year_source, birth_year_confidence = _get_birth_year(iid, person_identity, include_unreviewed=False)

    # Build person filter options (checkboxes for multi-select)
    person_filter_items = []
    selected_person_ids = set(person_ids)
    for ident in confirmed:
        iid = ident["identity_id"]
        face_ids = [f if isinstance(f, str) else f.get("face_id", "")
                    for f in ident.get("anchor_ids", []) + ident.get("candidate_ids", [])]
        photo_count = len(photo_reg.get_photos_for_faces(face_ids))
        if photo_count >= 2:
            name = ensure_utf8_display(ident.get("name", ""))
            person_filter_items.append({
                "id": iid, "name": name, "count": photo_count,
                "selected": iid in selected_person_ids,
            })

    # Also build backwards-compatible <select> options for single-person
    person_options = [Option("All people", value="")]
    for item in person_filter_items:
        person_options.append(Option(
            f"{item['name']} ({item['count']} photos)",
            value=item["id"], selected=item["selected"],
        ))

    # Build collection list for filter dropdown
    all_collections = sorted(set(
        ((_photo_cache or {}).get(pid, {}).get("collection", "") or "")
        for pid in (_photo_cache or {})
    ))
    all_collections = [c for c in all_collections if c]

    # Story header
    if len(person_identities) > 1:
        names = [ensure_utf8_display(pi.get("name", "")) for pi in person_identities]
        story_title = " & ".join(names)
        photo_count = len([e for e in timeline_entries if e["type"] == "photo"])
        story_subtitle = f"{photo_count} photos across {len(person_identities)} people"
    elif person_identity:
        person_name = ensure_utf8_display(person_identity.get("name", ""))
        story_title = f"{person_name}\u2019s Life in Photos"
        story_subtitle = ""
        if person_birth_year:
            if birth_year_source == "ml_inferred":
                story_subtitle = f"Born ~{person_birth_year} (estimated)"
            else:
                story_subtitle = f"Born {person_birth_year}"
    elif collection:
        story_title = collection
        photo_count = len([e for e in timeline_entries if e["type"] == "photo"])
        story_subtitle = f"{photo_count} photos in this collection"
    elif start and end:
        story_title = f"Rhodes, {start}\u2013{end}"
        story_subtitle = f"{len([e for e in timeline_entries if e['type'] == 'photo'])} photos in this period"
    else:
        story_title = "A Century of Rhodes"
        photo_count = len([e for e in timeline_entries if e["type"] == "photo"])
        event_count = len([e for e in timeline_entries if e["type"] == "context"])
        story_subtitle = f"{photo_count} photos \u00b7 {event_count} historical events"

    # Category colors for context events
    category_colors = {
        "holocaust": "border-red-700/60 bg-red-950/30",
        "persecution": "border-red-800/50 bg-red-950/20",
        "liberation": "border-emerald-700/50 bg-emerald-950/20",
        "immigration": "border-blue-700/50 bg-blue-950/20",
        "community": "border-amber-700/50 bg-amber-950/20",
        "political": "border-slate-600/50 bg-slate-800/30",
    }

    # Build timeline UI
    from urllib.parse import quote as _url_quote, urlencode as _url_encode

    def _timeline_url(**overrides):
        params = {}
        if len(person_ids) > 1:
            params["people"] = ",".join(person_ids)
        elif len(person_ids) == 1:
            params["person"] = person_ids[0]
        if start:
            params["start"] = str(start)
        if end:
            params["end"] = str(end)
        if context != "on":
            params["context"] = context
        if collection:
            params["collection"] = collection
        params.update({k: str(v) for k, v in overrides.items() if v})
        qs = _url_encode(params)
        return f"/timeline?{qs}" if qs else "/timeline"

    # Render decade sections
    decade_sections = []
    for dec in decades_order:
        entries = decades_map[dec]

        # Decade marker
        marker = Div(
            Div(
                Span(f"{dec}s", cls="text-lg font-serif font-bold text-amber-400/80"),
                cls="bg-slate-900 px-3 py-1 relative z-10",
            ),
            cls="flex items-center justify-center my-6",
            data_testid="decade-marker",
        )

        # Entry cards
        cards = []
        for entry in entries:
            if entry["type"] == "photo":
                # Confidence bar
                prob = entry.get("prob_range", [])
                conf = entry.get("confidence", "medium")
                conf_bar = None
                if prob and len(prob) == 2:
                    # Bar width relative to range span
                    range_span = prob[1] - prob[0]
                    if conf == "high":
                        bar_cls = "bg-amber-500/60"
                    elif conf == "medium":
                        bar_cls = "bg-amber-500/35"
                    else:
                        bar_cls = "bg-amber-500/20"
                    conf_bar = Div(
                        Div(
                            cls=f"h-full rounded-full {bar_cls}",
                            style=f"width: 100%",
                        ),
                        Span(f"{prob[0]}\u2013{prob[1]}", cls="text-[9px] text-slate-500 ml-2 whitespace-nowrap"),
                        cls="flex items-center gap-1 mt-1.5",
                        data_testid="confidence-bar",
                        title=f"Estimated range: {prob[0]}\u2013{prob[1]} ({conf} confidence)",
                    )

                # Date badge
                badge_text = f"c. {entry['decade']}s"
                if conf == "high":
                    date_cls = "bg-amber-800/80 text-amber-100"
                elif conf == "medium":
                    date_cls = "bg-amber-800/50 border border-amber-600/50 text-amber-200/90"
                else:
                    date_cls = "border border-dashed border-amber-600/40 text-amber-400/60"

                # Age badge (when person filter active and birth year known)
                age_badge = None
                if person_birth_year and entry.get("year"):
                    age = entry["year"] - person_birth_year
                    if 0 <= age <= 120:
                        # Style by confidence: confirmed=solid, high=solid, medium=dashed, low=faded
                        if birth_year_source == "confirmed" or birth_year_confidence == "high":
                            age_cls = "bg-indigo-900/50 text-indigo-300 border border-indigo-700/30"
                            age_text = f"Age ~{age}"
                        elif birth_year_confidence == "medium":
                            age_cls = "bg-indigo-900/30 text-indigo-300/80 border border-dashed border-indigo-700/30"
                            age_text = f"Age ~{age}"
                        else:
                            age_cls = "bg-indigo-900/20 text-indigo-400/50 border border-dashed border-indigo-800/30"
                            age_text = f"~{age}?"
                        age_badge = Span(
                            age_text,
                            cls=f"text-[10px] px-1.5 py-0.5 rounded {age_cls}",
                            data_testid="age-badge",
                        )

                # People names (highlight filtered people in multi-person mode)
                people_line = None
                highlighted = entry.get("highlighted_people", [])
                if entry.get("people"):
                    if len(person_identities) > 1 and highlighted:
                        # Bold the filtered people, dim the others
                        parts = []
                        for name in entry["people"][:4]:
                            if name in highlighted:
                                parts.append(Span(name, cls="text-amber-300 font-medium"))
                            else:
                                parts.append(Span(name))
                            parts.append(", ")
                        if parts:
                            parts.pop()  # remove trailing comma
                        if len(entry["people"]) > 4:
                            parts.append(f" +{len(entry['people']) - 4} more")
                        people_line = P(*parts, cls="text-xs text-slate-400 mt-1 truncate")
                    else:
                        names = ", ".join(entry["people"][:4])
                        if len(entry["people"]) > 4:
                            names += f" +{len(entry['people']) - 4} more"
                        people_line = P(names, cls="text-xs text-slate-400 mt-1 truncate")

                card = A(
                    Div(
                        # Photo thumbnail
                        Div(
                            Img(
                                src=photo_url(entry["filename"]),
                                cls="w-full h-full object-cover",
                                loading="lazy",
                            ),
                            Span(
                                badge_text,
                                cls=f"absolute bottom-1.5 left-1.5 text-[10px] font-serif px-1.5 py-0.5 rounded backdrop-blur-sm {date_cls}",
                                data_testid="date-badge",
                                data_confidence=conf,
                            ),
                            cls="aspect-[4/3] overflow-hidden relative rounded-t-lg",
                        ),
                        # Card details
                        Div(
                            Div(
                                Span(f"c. {entry['year']}", cls="text-xs font-serif text-amber-400/80"),
                                age_badge,
                                cls="flex items-center gap-2",
                            ),
                            people_line,
                            P(entry.get("collection", ""), cls="text-[10px] text-slate-600 mt-0.5") if entry.get("collection") else None,
                            conf_bar,
                            cls="p-3",
                        ),
                        cls="bg-slate-800/70 rounded-lg border border-slate-700/50 hover:border-amber-700/30 transition-colors w-full",
                    ),
                    href=f"/photo/{entry['photo_id']}",
                    cls="block",
                    data_testid="timeline-photo-card",
                )
                cards.append(Div(card, cls="ml-8 sm:ml-12 mb-4"))

            else:  # context event
                cat = entry.get("category", "")
                color_cls = category_colors.get(cat, "border-slate-600/50 bg-slate-800/30")

                # Category icon
                cat_icons = {
                    "holocaust": "\U0001f56f\ufe0f",
                    "persecution": "\u26a0\ufe0f",
                    "liberation": "\u2728",
                    "immigration": "\U0001f6a2",
                    "community": "\U0001f3db\ufe0f",
                    "political": "\U0001f3db\ufe0f",
                }
                icon = cat_icons.get(cat, "\U0001f4cd")

                card = Div(
                    Div(
                        Div(
                            Span(icon, cls="text-base"),
                            Div(
                                Span(str(entry["year"]), cls="text-xs font-serif text-slate-300 font-medium"),
                                H3(entry["title"], cls="text-sm font-medium text-white leading-snug",
                                   data_testid="context-event-title"),
                                cls="flex-1",
                            ),
                            cls="flex items-start gap-2.5",
                        ),
                        P(entry["description"], cls="text-xs text-slate-400 leading-relaxed mt-2"),
                        P(entry.get("source", ""), cls="text-[9px] text-slate-600 mt-2 italic") if entry.get("source") else None,
                        cls=f"p-4 rounded-lg border-l-4 {color_cls}",
                    ),
                    cls="ml-8 sm:ml-12 mb-4",
                    data_testid="timeline-context-event",
                )
                cards.append(card)

        decade_sections.append(Div(marker, *cards))

    # Navigation links (matches /photos and /people pattern)
    nav_links = _public_nav_links(active="timeline", user=user)

    page_style = Style("""
        html, body { margin: 0; }
        body { background-color: #0f172a; }
        .timeline-line {
            position: absolute;
            left: 1rem;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(to bottom, transparent 0%, #D4A574 5%, #D4A574 95%, transparent 100%);
        }
        @media (min-width: 640px) {
            .timeline-line { left: 1.5rem; }
        }
    """)

    # Share button JS (clipboard copy)
    share_js = Script("""
        document.addEventListener('click', function(e) {
            var btn = e.target.closest('[data-action="share-story"]');
            if (!btn) return;
            navigator.clipboard.writeText(window.location.href).then(function() {
                var toast = document.getElementById('timeline-toast');
                if (toast) {
                    toast.textContent = 'Link copied!';
                    toast.classList.remove('opacity-0');
                    toast.classList.add('opacity-100');
                    setTimeout(function() {
                        toast.classList.remove('opacity-100');
                        toast.classList.add('opacity-0');
                    }, 2000);
                }
            });
        });
    """)

    return (
        Title(f"{story_title} — Rhodesli Heritage Archive"),
        Meta(property="og:title", content=f"{story_title} — Rhodesli Heritage Archive"),
        Meta(property="og:description", content=story_subtitle),
        Meta(name="description", content=f"Timeline of the Jewish community of Rhodes. {story_subtitle}"),
        page_style,
        share_js,
        Main(
            Nav(
                Div(
                    A(Span("Rhodesli", cls="text-xl font-bold text-white"), href="/", cls="hover:opacity-90"),
                    Div(*nav_links, cls="flex items-center gap-3 sm:gap-6"),
                    cls="max-w-6xl mx-auto px-6 flex items-center justify-between h-16",
                ),
                cls="bg-slate-900/80 backdrop-blur-md border-b border-slate-800 sticky top-0 z-50",
            ),
            # Header
            Section(
                Div(
                    H1(story_title, cls="text-3xl font-serif font-bold text-white mb-2"),
                    P(story_subtitle, cls="text-slate-400 text-sm"),
                    cls="max-w-4xl mx-auto px-6 pt-10 pb-4",
                ),
            ),
            # Controls (sticky below nav)
            Section(
                Div(
                    # Person filter
                    Div(
                        Span("Person:", cls="text-sm text-slate-400 mr-2"),
                        Select(
                            *person_options,
                            cls="bg-slate-700 border border-slate-600 text-slate-200 text-sm rounded-lg px-3 py-1.5",
                            data_testid="person-filter",
                            onchange=f"window.location.href='/timeline?person=' + encodeURIComponent(this.value) + '&start={start or ''}&end={end or ''}&context={context}&collection=' + encodeURIComponent('{collection or ''}')",
                        ),
                        cls="flex items-center gap-2",
                    ),
                    # Collection filter
                    Div(
                        Span("Collection:", cls="text-sm text-slate-400 mr-2"),
                        Select(
                            Option("All collections", value=""),
                            *[Option(c, value=c, selected=(collection == c)) for c in all_collections],
                            cls="bg-slate-700 border border-slate-600 text-slate-200 text-sm rounded-lg px-3 py-1.5",
                            data_testid="collection-filter",
                            onchange=f"window.location.href='/timeline?collection=' + encodeURIComponent(this.value) + '&person={person or ''}&people={people or ''}&start={start or ''}&end={end or ''}&context={context}'",
                        ),
                        cls="flex items-center gap-2",
                    ) if all_collections else None,
                    # Share button
                    Div(
                        Button(
                            "\U0001f517 Share This Story",
                            cls="px-3 py-1.5 text-sm bg-slate-800 text-slate-300 rounded-lg border border-slate-700 hover:border-amber-700/30 hover:text-white transition-colors",
                            data_action="share-story",
                            data_testid="share-story-btn",
                        ),
                        # Toast
                        Div(
                            "",
                            id="timeline-toast",
                            cls="opacity-0 transition-opacity duration-300 text-xs text-emerald-400 ml-3",
                        ),
                        cls="flex items-center",
                    ),
                    cls="max-w-4xl mx-auto px-6 flex flex-wrap items-center justify-between gap-4 py-3",
                ),
                cls="sticky top-16 z-40 bg-slate-900/95 backdrop-blur-sm border-b border-slate-800/50",
            ),
            # Timeline
            Section(
                Div(
                    # The vertical line
                    Div(cls="timeline-line", data_testid="timeline-line"),
                    # Decade sections
                    *decade_sections,
                    # Empty state
                    Div(
                        P("No photos match your filters.", cls="text-slate-500 text-center py-12"),
                        A("View full timeline", href="/timeline", cls="text-indigo-400 hover:text-indigo-300 text-sm block text-center mt-2"),
                    ) if not decade_sections else None,
                    cls="relative",
                    data_testid="timeline-container",
                    id="timeline",
                ),
                cls="max-w-4xl mx-auto px-6 pb-16",
            ),
            # Footer
            Div(
                Div(
                    P("Rhodesli Heritage Archive", cls="text-xs text-slate-500 mb-1 font-serif"),
                    P("Preserving the memory of the Jewish community of Rhodes", cls="text-[10px] text-slate-600 italic"),
                    cls="max-w-6xl mx-auto px-6 flex flex-col items-center",
                ),
                cls="py-8 border-t border-slate-800",
            ),
            cls="min-h-screen bg-slate-900",
        ),
    )


# ---- Face Comparison Tool ----


@rt("/compare")
def get(face_id: str = "", sess=None):
    """
    Face comparison page — find similar faces in the archive.

    Users can select an existing face from the archive to find matches,
    or upload a photo (local dev only, InsightFace required).

    Query params:
        face_id: optional face_id to pre-select for comparison
    """
    user = get_current_user(sess or {}) if is_auth_enabled() else None

    _build_caches()
    registry = load_registry()
    crop_files = get_crop_files()

    # If face_id provided, run comparison immediately
    results_html = None
    selected_face_url = None
    selected_identity_name = None
    if face_id:
        face_data = get_face_data()
        if face_id in face_data:
            from core.neighbors import find_similar_faces
            selected_face_url = resolve_face_image_url(face_id, crop_files)
            # Find the identity name for this face
            ident = get_identity_for_face(registry, face_id)
            if ident:
                selected_identity_name = ensure_utf8_display(ident.get("name", "Unknown"))
            results = find_similar_faces(
                face_data[face_id]["mu"], face_data, registry=registry,
                limit=20, exclude_face_ids={face_id},
            )
            # Save shareable result
            rid = _generate_result_id()
            _save_comparison_result({
                "result_id": rid,
                "created_at": datetime.now().isoformat(),
                "query_type": "archive",
                "query_face_id": face_id,
                "query_name": selected_identity_name or "Unknown",
                "matches": [{"face_id": r["face_id"], "identity_id": r.get("identity_id", ""),
                             "identity_name": r.get("identity_name", ""), "distance": r["distance"],
                             "confidence_pct": r.get("confidence_pct", 0), "tier": r.get("tier", "WEAK")}
                            for r in results[:10]],
                "responses": [],
            })
            results_html = _compare_results_grid(results, crop_files, result_id=rid)

    # Build face selector — confirmed identities with face crops
    confirmed = [
        i for i in registry.list_identities(state=IdentityState.CONFIRMED)
        if not i.get("name", "").startswith("Unidentified") and not i.get("merged_into")
    ]
    confirmed.sort(key=lambda x: (x.get("name") or "").lower())

    face_options = []
    for ident in confirmed:
        name = ensure_utf8_display(ident.get("name", ""))
        faces = ident.get("anchor_ids", []) + ident.get("candidate_ids", [])
        for entry in faces[:1]:  # Just first face per identity
            fid = entry if isinstance(entry, str) else entry.get("face_id", "")
            crop_url = resolve_face_image_url(fid, crop_files)
            if crop_url:
                face_options.append({"face_id": fid, "name": name, "crop_url": crop_url})

    # Navigation
    nav_links = _public_nav_links(active="compare", user=user)

    page_style = Style("html, body { margin: 0; } body { background-color: #0f172a; }")

    # Face selector grid
    face_grid = Div(
        *[
            A(
                Div(
                    Img(src=opt["crop_url"], cls="w-16 h-16 rounded-full object-cover"),
                    P(opt["name"], cls="text-[10px] text-slate-400 mt-1 text-center truncate w-20"),
                    cls="flex flex-col items-center",
                ),
                href=f"/compare?face_id={opt['face_id']}",
                cls=f"p-2 rounded-lg hover:bg-slate-700/50 transition-colors {'bg-amber-900/30 ring-1 ring-amber-500/50' if opt['face_id'] == face_id else ''}",
                data_testid="face-option",
            )
            for opt in face_options
        ],
        cls="flex flex-wrap gap-3 justify-center",
        data_testid="face-selector",
    )

    # Search/filter for face selector
    face_search = Div(
        Input(
            type="text",
            placeholder="Search by name...",
            cls="bg-slate-700 border border-slate-600 text-slate-200 text-sm rounded-lg px-3 py-2 w-full max-w-xs",
            data_testid="face-search",
            oninput="var q=this.value.toLowerCase();document.querySelectorAll('[data-testid=face-option]').forEach(function(el){el.style.display=el.textContent.toLowerCase().includes(q)?'':'none'})",
        ),
        cls="flex justify-center mb-4",
    )

    # Selected face display
    selected_section = None
    if selected_face_url:
        selected_section = Div(
            H3("Comparing", cls="text-sm text-slate-400 mb-2"),
            Div(
                Img(src=selected_face_url, cls="w-24 h-24 rounded-full object-cover ring-2 ring-amber-500"),
                P(selected_identity_name or "Unknown", cls="text-sm text-white mt-2 font-medium"),
                cls="flex flex-col items-center",
            ),
            cls="text-center mb-6",
        )

    # Upload section — above the fold, primary action (PRD-016)
    upload_section = Div(
        Div(
            H2("Upload a Photo", cls="text-xl font-serif text-white mb-1"),
            P("Upload a photo to find matching faces in our archive of "
              f"{len(face_options)} identified people.",
              cls="text-sm text-slate-400 mb-4"),
            cls="text-center",
        ),
        Form(
            Div(
                # Drag-and-drop zone
                Div(
                    NotStr('<svg xmlns="http://www.w3.org/2000/svg" class="w-10 h-10 text-slate-500 mb-3 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5"/></svg>'),
                    P("Drop a photo here or click to browse", cls="text-slate-400 text-sm mb-1"),
                    P("JPG, PNG up to 10 MB", cls="text-slate-600 text-xs"),
                    Input(type="file", name="photo", accept="image/*",
                          cls="absolute inset-0 w-full h-full opacity-0 cursor-pointer",
                          data_testid="upload-input"),
                    cls="relative border-2 border-dashed border-slate-600 hover:border-indigo-500 rounded-xl p-8 transition-colors cursor-pointer",
                ),
                cls="mb-4",
            ),
            Button(
                NotStr('<svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 mr-2 inline" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"/></svg>'),
                "Search Archive",
                type="submit",
                cls="px-6 py-2.5 bg-indigo-600 text-white font-medium rounded-xl hover:bg-indigo-500 transition-colors inline-flex items-center",
            ),
            action="/api/compare/upload",
            method="post",
            enctype="multipart/form-data",
            hx_post="/api/compare/upload",
            hx_target="#compare-results",
            hx_swap="innerHTML",
            hx_indicator="#upload-spinner",
            data_testid="upload-form",
        ),
        Div(id="upload-spinner", cls="htmx-indicator text-center py-4",
            children=[Span("Analyzing faces...", cls="text-slate-400 text-sm animate-pulse")]),
        P("Photos are saved to help grow the archive.", cls="text-xs text-slate-600 mt-3 text-center"),
        cls="bg-slate-800/50 rounded-2xl p-8 max-w-lg mx-auto",
        data_testid="upload-area",
    )

    # Archive search section — collapsed below upload
    archive_section = Div(
        # Expander header
        Div(
            Button(
                Span("Or search by person in the archive", cls="text-slate-300 text-sm font-medium"),
                NotStr('<svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4 text-slate-500 ml-2 transition-transform" id="archive-expand-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"/></svg>'),
                type="button",
                cls="flex items-center justify-center w-full py-3 hover:text-white transition-colors",
                onclick="var panel=document.getElementById('archive-panel');var icon=document.getElementById('archive-expand-icon');if(panel.classList.contains('hidden')){panel.classList.remove('hidden');icon.style.transform='rotate(180deg)'}else{panel.classList.add('hidden');icon.style.transform=''}",
            ),
            cls="border-t border-slate-800 mt-6",
        ),
        # Collapsible panel (hidden by default, open if face_id provided)
        Div(
            face_search,
            selected_section if selected_section else None,
            face_grid,
            cls="" if face_id else "hidden",
            id="archive-panel",
            data_testid="archive-panel",
        ),
    )

    compare_og = og_tags(
        "Compare Faces \u2014 Rhodesli Heritage Archive",
        "Find similar faces in the Rhodes Jewish heritage photo archive",
        canonical_url="/compare",
    )

    return (
        Title("Compare Faces \u2014 Rhodesli Heritage Archive"),
        *compare_og,
        page_style,
        Main(
            Nav(
                Div(
                    A(Span("Rhodesli", cls="text-xl font-bold text-white"), href="/", cls="hover:opacity-90"),
                    Div(*nav_links, cls="flex items-center gap-3 sm:gap-6"),
                    cls="max-w-6xl mx-auto px-6 flex items-center justify-between h-16",
                ),
                cls="bg-slate-900/80 backdrop-blur-md border-b border-slate-800 sticky top-0 z-50",
            ),
            # Tab navigation
            Section(
                Div(
                    Div(
                        A("Compare Faces", href="/compare",
                          cls="px-4 py-2 text-sm font-medium text-white border-b-2 border-indigo-400 transition-colors"),
                        A("Estimate Year", href="/estimate",
                          cls="px-4 py-2 text-sm font-medium text-slate-400 hover:text-white border-b-2 border-transparent hover:border-indigo-400 transition-colors"),
                        cls="flex items-center justify-center gap-6 border-b border-slate-700/50 pb-0",
                    ),
                    cls="max-w-4xl mx-auto px-6 pt-8",
                ),
            ),
            # Header
            Section(
                Div(
                    H1("Compare Faces", cls="text-3xl font-serif font-bold text-white mb-2"),
                    P("Upload a photo to search our archive, or compare people already in the collection.",
                      cls="text-slate-400 text-sm"),
                    cls="max-w-4xl mx-auto px-6 pt-6 pb-6",
                ),
            ),
            # Upload — above the fold, primary action
            Section(
                Div(upload_section, cls="max-w-4xl mx-auto px-6 pb-4"),
                data_testid="upload-section",
            ),
            # Archive search — collapsed below
            Section(
                Div(archive_section, cls="max-w-4xl mx-auto px-6 pb-6"),
            ),
            # Results
            Section(
                Div(
                    results_html if results_html else Div(
                        P("Upload a photo or select a person to find similar faces.",
                          cls="text-slate-500 text-center py-8"),
                        id="compare-results",
                    ),
                    cls="max-w-4xl mx-auto px-6 pb-8",
                ),
            ),
            # Footer
            Div(
                Div(
                    P("Rhodesli Heritage Archive", cls="text-xs text-slate-500 mb-1 font-serif"),
                    P("Preserving the memory of the Jewish community of Rhodes", cls="text-[10px] text-slate-600 italic"),
                    cls="max-w-6xl mx-auto px-6 flex flex-col items-center",
                ),
                cls="py-8 border-t border-slate-800",
            ),
            cls="min-h-screen bg-slate-900",
        ),
    )


def _compare_result_card(result: dict, crop_files: set, index: int) -> object | None:
    """Build a single compare result card."""
    fid = result["face_id"]
    dist = result["distance"]
    tier = result.get("tier", "WEAK")
    confidence_pct = result.get("confidence_pct", 50)
    name = ensure_utf8_display(result.get("identity_name", "Unknown"))
    state = result.get("state", "")
    identity_id = result.get("identity_id", "")

    crop_url = resolve_face_image_url(fid, crop_files)
    if not crop_url:
        return None

    photo_id = get_photo_id_for_face(fid)
    photo_link = f"/photo/{photo_id}" if photo_id else "#"

    # Tier-specific styling
    tier_styles = {
        "STRONG MATCH": {
            "border": "border-emerald-700/50 hover:border-emerald-500/50",
            "badge_cls": "text-emerald-400 bg-emerald-900/30 border-emerald-700/50",
            "ring": "ring-2 ring-emerald-500/30",
        },
        "POSSIBLE MATCH": {
            "border": "border-amber-700/50 hover:border-amber-500/50",
            "badge_cls": "text-amber-400 bg-amber-900/30 border-amber-700/50",
            "ring": "ring-1 ring-amber-500/20",
        },
        "SIMILAR": {
            "border": "border-blue-700/30 hover:border-blue-500/30",
            "badge_cls": "text-blue-400 bg-blue-900/30 border-blue-700/50",
            "ring": "",
        },
        "WEAK": {
            "border": "border-slate-700/30 hover:border-slate-600/30",
            "badge_cls": "text-slate-400 bg-slate-800/50 border-slate-700/50",
            "ring": "",
        },
    }
    style = tier_styles.get(tier, tier_styles["WEAK"])

    # State badge
    state_badge = None
    if state == "CONFIRMED":
        state_badge = Span("Identified", cls="text-[9px] px-1.5 py-0.5 rounded bg-emerald-900/50 text-emerald-400 border border-emerald-700/30")

    # Person page link (for confirmed identities)
    person_link = None
    if state == "CONFIRMED" and identity_id:
        person_link = A(
            f"View {name.split()[0]}'s page",
            href=f"/person/{identity_id}",
            cls="text-[10px] text-indigo-400 hover:text-indigo-300 block text-center mt-1",
        )

    # Timeline link (for confirmed identities with metadata)
    timeline_link = None
    if state == "CONFIRMED" and identity_id:
        timeline_link = A(
            "Timeline",
            href=f"/timeline?person={identity_id}",
            cls="text-[10px] text-slate-400 hover:text-indigo-300 block text-center",
        )

    display_name = name if state == "CONFIRMED" else f"Face #{index + 1}"

    # Calibrated confidence label based on percentage (AD-091)
    if confidence_pct >= 85:
        conf_label = "Very likely same person"
    elif confidence_pct >= 70:
        conf_label = "Strong match"
    elif confidence_pct >= 50:
        conf_label = "Possible match"
    else:
        conf_label = "Unlikely match"

    return Div(
        A(
            Img(src=crop_url, cls=f"w-20 h-20 rounded-full object-cover mx-auto {style['ring']}"),
            href=photo_link,
            cls="block",
        ),
        Div(
            P(display_name, cls="text-sm text-white font-medium mt-2 truncate text-center"),
            Div(
                Span(f"{confidence_pct}%", cls=f"text-xs font-medium px-2 py-0.5 rounded border {style['badge_cls']}"),
                state_badge,
                cls="flex items-center justify-center gap-2 mt-1",
            ),
            P(conf_label, cls="text-[10px] text-slate-500 text-center mt-0.5", data_testid="confidence-label"),
            A("View Photo", href=photo_link, cls="text-[10px] text-indigo-400 hover:text-indigo-300 block text-center mt-2") if photo_id else None,
            person_link,
            timeline_link,
            cls="px-2",
        ),
        cls=f"bg-slate-800/70 rounded-lg border {style['border']} p-4 transition-colors",
        data_testid="compare-result",
        data_tier=tier.lower().replace(" ", "-"),
    )


def _compare_results_grid(results: list, crop_files: set, result_id: str = "") -> object:
    """Build the tiered results grid for face comparison (AD-067/AD-068).
    If result_id is provided, includes a shareable permalink."""
    if not results:
        return Div(
            P("No similar faces found.", cls="text-slate-500 text-center py-8"),
            id="compare-results",
        )

    _build_caches()

    # Group results by tier
    tier_order = ["STRONG MATCH", "POSSIBLE MATCH", "SIMILAR", "WEAK"]
    tiered: dict[str, list] = {t: [] for t in tier_order}
    for i, result in enumerate(results):
        tier = result.get("tier", "WEAK")
        card = _compare_result_card(result, crop_files, i)
        if card:
            tiered[tier].append(card)

    # Build sections
    sections = []

    # Calibrated tier labels (AD-091): labels match what the confidence
    # percentages actually mean. "Very likely" reserved for 85%+ only.
    tier_config = {
        "STRONG MATCH": {
            "title": "Strong Matches",
            "subtitle": "High confidence — likely the same person",
            "icon": "text-emerald-400",
            "border": "border-emerald-800/30",
            "testid": "tier-strong-match",
        },
        "POSSIBLE MATCH": {
            "title": "Possible Matches",
            "subtitle": "Moderate confidence — worth investigating",
            "icon": "text-amber-400",
            "border": "border-amber-800/20",
            "testid": "tier-possible-match",
        },
        "SIMILAR": {
            "title": "Similar Faces",
            "subtitle": "Some resemblance — may be related",
            "icon": "text-blue-400",
            "border": "border-blue-800/20",
            "testid": "tier-similar",
        },
        "WEAK": {
            "title": "Other Faces",
            "subtitle": "Low similarity",
            "icon": "text-slate-500",
            "border": "border-slate-800/20",
            "testid": "tier-weak",
        },
    }

    total_shown = 0
    for tier in tier_order:
        cards = tiered[tier]
        if not cards:
            continue
        total_shown += len(cards)
        cfg = tier_config[tier]
        sections.append(
            Div(
                Div(
                    H3(cfg["title"], cls=f"text-base font-serif {cfg['icon']}"),
                    Span(f"{len(cards)} result{'s' if len(cards) != 1 else ''} — {cfg['subtitle']}",
                         cls="text-xs text-slate-500 ml-2"),
                    cls="flex items-baseline gap-1 mb-3",
                ),
                Div(*cards, cls="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4"),
                cls=f"mb-6 pb-4 border-b {cfg['border']}",
                data_testid=cfg["testid"],
            )
        )

    # Action CTAs below results
    share_url = f"/compare/result/{result_id}" if result_id else "/compare"
    cta_section = Div(
        share_button(url=share_url, style="button", label="Share Results",
                     title="Face Comparison Results", text="Check out these face comparison results from the Rhodes archive"),
        A("Try Another Photo",
          href="/compare",
          cls="px-4 py-2 bg-slate-700 hover:bg-slate-600 text-white text-sm font-medium rounded-lg transition-colors inline-flex items-center"),
        cls="flex flex-wrap items-center justify-center gap-3 mt-6 pt-4 border-t border-slate-800",
        data_testid="compare-ctas",
    )

    return Div(
        H2(f"{total_shown} Match{'es' if total_shown != 1 else ''}", cls="text-lg font-serif text-white mb-4"),
        *sections,
        cta_section,
        id="compare-results",
        data_testid="compare-results",
    )


@rt("/api/compare")
def get(face_id: str = "", limit: int = 20, sess=None):
    """API endpoint for face comparison — returns results HTML partial."""
    if not face_id:
        return Div(P("No face selected.", cls="text-slate-500 text-center py-4"))

    face_data = get_face_data()
    if face_id not in face_data:
        return Div(P("Face not found in archive.", cls="text-amber-500 text-center py-4"))

    from core.neighbors import find_similar_faces
    registry = load_registry()
    crop_files = get_crop_files()
    results = find_similar_faces(
        face_data[face_id]["mu"], face_data, registry=registry,
        limit=limit, exclude_face_ids={face_id},
    )
    # Save shareable result
    ident = get_identity_for_face(registry, face_id)
    query_name = ensure_utf8_display(ident.get("name", "Unknown")) if ident else "Unknown"
    rid = _generate_result_id()
    _save_comparison_result({
        "result_id": rid,
        "created_at": datetime.now().isoformat(),
        "query_type": "archive",
        "query_face_id": face_id,
        "query_name": query_name,
        "matches": [{"face_id": r["face_id"], "identity_id": r.get("identity_id", ""),
                     "identity_name": r.get("identity_name", ""), "distance": r["distance"],
                     "confidence_pct": r.get("confidence_pct", 0), "tier": r.get("tier", "WEAK")}
                    for r in results[:10]],
        "responses": [],
    })
    return _compare_results_grid(results, crop_files, result_id=rid)


def _save_compare_upload(content: bytes, filename: str, faces: list, results: list, status: str = "uploaded") -> str:
    """Persist a compare upload to R2 (preferred) or local filesystem.

    Returns the upload UUID.
    """
    import uuid as _uuid
    import mimetypes
    from pathlib import Path as _Path
    from core.storage import can_write_r2, upload_bytes_to_r2

    upload_id = str(_uuid.uuid4())[:12]
    suffix = _Path(filename).suffix or ".jpg"
    image_key = f"uploads/compare/{upload_id}{suffix}"

    # Save metadata
    meta = {
        "upload_id": upload_id,
        "uploaded_at": datetime.now().isoformat(),
        "original_filename": filename,
        "image_key": image_key,
        "faces_detected": len(faces) if faces else 0,
        "status": status,
        "top_match": {
            "identity_name": results[0].get("identity_name", "Unknown") if results else None,
            "confidence_pct": results[0].get("confidence_pct", 0) if results else 0,
            "tier": results[0].get("tier", "WEAK") if results else None,
        },
    }
    meta_key = f"uploads/compare/{upload_id}_meta.json"

    if can_write_r2():
        # Save to R2 for persistence across deploys
        content_type = mimetypes.guess_type(filename)[0] or "image/jpeg"
        upload_bytes_to_r2(image_key, content, content_type=content_type)
        upload_bytes_to_r2(meta_key, json.dumps(meta, indent=2).encode(), content_type="application/json")
    else:
        # Fall back to local filesystem (will not survive Railway restarts)
        upload_dir = _Path("uploads/compare")
        upload_dir.mkdir(parents=True, exist_ok=True)
        (_Path("uploads/compare") / f"{upload_id}{suffix}").write_bytes(content)
        (_Path("uploads/compare") / f"{upload_id}_meta.json").write_text(json.dumps(meta, indent=2))

    return upload_id


def _build_face_selector_for_upload(upload_id: str, faces: list, image_path: str) -> object:
    """Build a face selector UI for multi-face uploads."""
    face_buttons = []
    for i, face in enumerate(faces):
        bbox = face.get("bbox", [0, 0, 0, 0])
        if hasattr(bbox, 'tolist'):
            bbox = bbox.tolist()
        x1, y1, x2, y2 = [int(v) for v in bbox[:4]]
        w = x2 - x1
        h = y2 - y1

        face_buttons.append(
            Button(
                f"Face {i + 1}",
                hx_post=f"/api/compare/upload/select?upload_id={upload_id}&face_idx={i}",
                hx_target="#compare-results",
                hx_swap="innerHTML",
                cls=f"px-3 py-1.5 text-sm rounded-lg border transition-colors "
                    f"{'bg-amber-600 border-amber-500 text-white' if i == 0 else 'bg-slate-700 border-slate-600 text-slate-300 hover:bg-slate-600'}",
                data_testid=f"face-select-{i}",
            )
        )

    return Div(
        P(f"{len(faces)} face{'s' if len(faces) != 1 else ''} detected. Select which face to compare:",
          cls="text-sm text-slate-400 mb-3"),
        Div(*face_buttons, cls="flex flex-wrap gap-2 justify-center"),
        cls="text-center mb-4 p-4 bg-slate-800/50 rounded-lg border border-slate-700/50",
        data_testid="face-selector-upload",
    )


@rt("/api/compare/upload")
async def post(photo: UploadFile = None, sess=None):
    """Upload a photo for face comparison (local dev only — requires InsightFace).

    Persists uploads to uploads/compare/ for later retrieval.
    Supports multi-face detection with face selection.
    """
    if not photo:
        return Div(P("No photo uploaded.", cls="text-amber-500 text-center py-4"))

    from pathlib import Path as _Path
    import tempfile

    # Read upload content
    content = await photo.read()
    original_filename = photo.filename or "upload.jpg"
    suffix = _Path(original_filename).suffix or ".jpg"

    # Check if face detection is available (InsightFace — local dev only)
    # Must probe the actual deferred dependencies (cv2, insightface), not just
    # the function reference — core.ingest_inbox has only stdlib top-level imports
    # so importing it always succeeds even without ML deps installed.
    has_insightface = False
    try:
        import cv2  # noqa: F811
        from insightface.app import FaceAnalysis  # noqa: F401
        from core.ingest_inbox import extract_faces
        has_insightface = True
    except ImportError:
        pass

    if not has_insightface:
        # Production mode: save to R2 without face detection
        from core.storage import can_write_r2
        if can_write_r2():
            upload_id = _save_compare_upload(content, original_filename, faces=[], results=[], status="awaiting_analysis")
            return Div(
                Div(
                    Span("✓", cls="text-2xl text-green-400"),
                    cls="flex justify-center mb-3"
                ),
                P("Photo saved!", cls="text-lg font-semibold text-white text-center"),
                P("Face analysis will be processed shortly. Check back soon for comparison results.",
                  cls="text-sm text-slate-400 text-center mt-2"),
                P(f"Upload ID: {upload_id}", cls="text-xs text-slate-500 text-center mt-3 font-mono"),
                cls="py-8 px-4",
                id="compare-results",
                data_testid="upload-saved-pending",
            )
        else:
            return Div(
                P("Photo comparison uploads are not yet available in production.",
                  cls="text-amber-500 text-center py-4"),
                P("Browse the archive above to compare existing faces.", cls="text-slate-500 text-center text-sm mt-2"),
                id="compare-results",
            )

    # Local dev: full face detection + comparison
    with tempfile.NamedTemporaryFile(suffix=suffix, delete=False) as tmp:
        tmp.write(content)
        tmp_path = _Path(tmp.name)

    try:
        faces, _, _ = extract_faces(tmp_path)
        if not faces:
            return Div(
                P("No faces detected in the uploaded photo.", cls="text-amber-500 text-center py-4"),
                P("Try uploading a clearer photo with visible faces.", cls="text-slate-500 text-center text-sm mt-2"),
                id="compare-results",
            )

        # Compare first face by default
        query_embedding = faces[0]["mu"]
        face_data = get_face_data()
        registry = load_registry()
        crop_files = get_crop_files()

        from core.neighbors import find_similar_faces
        results = find_similar_faces(
            query_embedding, face_data, registry=registry,
            limit=20,
        )

        # Persist the upload
        upload_id = _save_compare_upload(content, original_filename, faces, results)

        # Save face embeddings for face selection (R2 or local)
        import pickle
        from core.storage import can_write_r2, upload_bytes_to_r2
        face_save_data = [{"mu": f["mu"].tolist(), "bbox": f.get("bbox", [0,0,0,0]) if not hasattr(f.get("bbox"), 'tolist') else f["bbox"].tolist()} for f in faces]
        faces_pkl = pickle.dumps(face_save_data)

        if can_write_r2():
            upload_bytes_to_r2(f"uploads/compare/{upload_id}_faces.pkl", faces_pkl)
        else:
            upload_dir = _Path("uploads/compare")
            upload_dir.mkdir(parents=True, exist_ok=True)
            (upload_dir / f"{upload_id}_faces.pkl").write_bytes(faces_pkl)

        # Build response
        parts = []

        # Multi-face selector (if more than one face)
        if len(faces) > 1:
            parts.append(_build_face_selector_for_upload(upload_id, faces, ""))

        # Results grid
        parts.append(_compare_results_grid(results, crop_files))

        # Contribute CTA
        user = get_current_user(sess or {}) if is_auth_enabled() else None
        if user:
            parts.append(
                Div(
                    P("Want to add this photo to the archive?", cls="text-sm text-slate-400 mb-2"),
                    Button(
                        "Contribute to Archive",
                        hx_post=f"/api/compare/contribute?upload_id={upload_id}",
                        hx_target="#contribute-cta-container",
                        hx_swap="innerHTML",
                        cls="px-4 py-2 bg-indigo-600 text-white text-sm font-medium rounded-lg hover:bg-indigo-700 transition-colors",
                    ),
                    cls="text-center mt-6 p-4 bg-slate-800/30 rounded-lg border border-dashed border-slate-700",
                    id="contribute-cta-container",
                    data_testid="contribute-cta",
                )
            )
        elif is_auth_enabled():
            parts.append(
                Div(
                    P("Sign in to contribute this photo to the archive", cls="text-sm text-slate-400 mb-2"),
                    A("Sign In", href="/login",
                      cls="px-4 py-2 bg-slate-700 text-slate-300 text-sm font-medium rounded-lg hover:bg-slate-600 transition-colors inline-block"),
                    cls="text-center mt-6 p-4 bg-slate-800/30 rounded-lg border border-dashed border-slate-700",
                    data_testid="contribute-cta",
                )
            )

        return Div(*parts, id="compare-results")
    except Exception as e:
        return Div(
            P(f"Error processing photo: {str(e)}", cls="text-red-500 text-center py-4"),
            id="compare-results",
        )
    finally:
        tmp_path.unlink(missing_ok=True)


@rt("/api/compare/upload/select")
def post(upload_id: str = "", face_idx: int = 0, sess=None):
    """Select a specific face from a multi-face upload for comparison."""
    from pathlib import Path as _Path
    import pickle
    from core.storage import can_write_r2, download_bytes_from_r2

    # Try R2 first, then local filesystem
    faces_data = None
    if can_write_r2():
        faces_data = download_bytes_from_r2(f"uploads/compare/{upload_id}_faces.pkl")

    if faces_data is None:
        embeddings_path = _Path("uploads/compare") / f"{upload_id}_faces.pkl"
        if embeddings_path.exists():
            faces_data = embeddings_path.read_bytes()

    if faces_data is None:
        return Div(P("Upload not found. Please re-upload the photo.", cls="text-amber-500 text-center py-4"))

    face_save_data = pickle.loads(faces_data)
    if face_idx < 0 or face_idx >= len(face_save_data):
        return Div(P("Invalid face selection.", cls="text-amber-500 text-center py-4"))

    query_embedding = np.array(face_save_data[face_idx]["mu"], dtype=np.float32)
    face_data = get_face_data()
    registry = load_registry()
    crop_files = get_crop_files()

    from core.neighbors import find_similar_faces
    results = find_similar_faces(
        query_embedding, face_data, registry=registry,
        limit=20,
    )

    parts = []

    # Face selector with updated active state
    if len(face_save_data) > 1:
        face_buttons = []
        for i in range(len(face_save_data)):
            is_active = i == face_idx
            face_buttons.append(
                Button(
                    f"Face {i + 1}",
                    hx_post=f"/api/compare/upload/select?upload_id={upload_id}&face_idx={i}",
                    hx_target="#compare-results",
                    hx_swap="innerHTML",
                    cls=f"px-3 py-1.5 text-sm rounded-lg border transition-colors "
                        f"{'bg-amber-600 border-amber-500 text-white' if is_active else 'bg-slate-700 border-slate-600 text-slate-300 hover:bg-slate-600'}",
                    data_testid=f"face-select-{i}",
                )
            )
        parts.append(
            Div(
                P(f"Comparing Face {face_idx + 1} of {len(face_save_data)}:",
                  cls="text-sm text-slate-400 mb-3"),
                Div(*face_buttons, cls="flex flex-wrap gap-2 justify-center"),
                cls="text-center mb-4 p-4 bg-slate-800/50 rounded-lg border border-slate-700/50",
                data_testid="face-selector-upload",
            )
        )

    parts.append(_compare_results_grid(results, crop_files))
    return Div(*parts, id="compare-results")


@rt("/api/compare/contribute")
def post(upload_id: str = "", sess=None):
    """Submit a compare upload to the admin moderation queue.

    Creates an entry in pending_uploads.json so the admin can approve/reject
    the photo for inclusion in the archive.
    """
    denied = _check_login(sess)
    if denied:
        return denied
    user = get_current_user(sess or {})

    if not upload_id:
        return Div(P("Missing upload ID.", cls="text-amber-500 text-sm"), id="contribute-cta-container")

    # Read the upload metadata
    from pathlib import Path as _Path
    from core.storage import can_write_r2, download_bytes_from_r2

    meta = None
    if can_write_r2():
        meta_bytes = download_bytes_from_r2(f"uploads/compare/{upload_id}_meta.json")
        if meta_bytes:
            meta = json.loads(meta_bytes)

    if meta is None:
        meta_path = _Path("uploads/compare") / f"{upload_id}_meta.json"
        if meta_path.exists():
            meta = json.loads(meta_path.read_text())

    if meta is None:
        return Div(P("Upload not found.", cls="text-amber-500 text-sm"), id="contribute-cta-container")

    # Create pending upload entry
    pending = _load_pending_uploads()
    job_id = f"compare_{upload_id}"
    if job_id not in pending["uploads"]:
        pending["uploads"][job_id] = {
            "job_id": job_id,
            "status": "pending",
            "submitted_at": datetime.now().isoformat(),
            "submitted_by": user.email if user else "anonymous",
            "source": "compare_upload",
            "collection": "",
            "file_count": 1,
            "files": [meta.get("original_filename", f"{upload_id}.jpg")],
            "compare_upload_id": upload_id,
            "image_key": meta.get("image_key", f"uploads/compare/{upload_id}.jpg"),
            "faces_detected": meta.get("faces_detected", 0),
            "top_match": meta.get("top_match"),
        }
        _save_pending_uploads(pending)

    return Div(
        Span("✓", cls="text-green-400 mr-2"),
        Span("Submitted for review!", cls="text-sm text-green-300"),
        P("An admin will review your photo for inclusion in the archive.", cls="text-xs text-slate-500 mt-1"),
        cls="text-center py-3",
        id="contribute-cta-container",
        data_testid="contribute-submitted",
    )


# ---- Shareable Comparison Results ----


_comparison_results_cache = None


def _load_comparison_results() -> dict:
    """Load comparison results from data file."""
    global _comparison_results_cache
    if _comparison_results_cache is not None:
        return _comparison_results_cache
    path = data_path / "comparison_results.json"
    default = {"schema_version": 1, "results": {}}
    if path.exists():
        try:
            with open(path, encoding="utf-8") as f:
                _comparison_results_cache = json.load(f)
        except (json.JSONDecodeError, OSError):
            _comparison_results_cache = default
    else:
        _comparison_results_cache = default
    return _comparison_results_cache


def _save_comparison_result(result_data: dict) -> str:
    """Save a comparison result and return its ID."""
    global _comparison_results_cache
    data = _load_comparison_results()
    result_id = result_data["result_id"]
    data["results"][result_id] = result_data
    path = data_path / "comparison_results.json"
    import portalocker
    with portalocker.Lock(str(path) + ".lock", timeout=5):
        with open(path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
    _comparison_results_cache = data
    return result_id


def _generate_result_id() -> str:
    """Generate a 12-character result ID."""
    return uuid.uuid4().hex[:12]


@rt("/compare/result/{result_id}")
def get(result_id: str, sess=None):
    """
    Shareable comparison result page — permalink for a specific comparison.
    No authentication required. Shows matches + response form.
    """
    user = get_current_user(sess or {}) if is_auth_enabled() else None

    data = _load_comparison_results()
    result = data.get("results", {}).get(result_id)
    if not result:
        return Title("Not Found"), Main(
            Div(
                H1("Comparison Not Found", cls="text-2xl font-serif text-white mb-4"),
                P("This comparison result doesn't exist or has been removed.", cls="text-slate-400"),
                A("Try Compare Faces", href="/compare", cls="text-indigo-400 hover:text-indigo-300 mt-4 inline-block"),
                cls="max-w-4xl mx-auto px-6 py-20 text-center",
            ),
            cls="min-h-screen bg-slate-900",
        )

    _build_caches()
    crop_files = get_crop_files()
    matches = result.get("matches", [])
    query_type = result.get("query_type", "archive")
    query_face_id = result.get("query_face_id", "")
    responses = result.get("responses", [])

    # Query face info
    query_face_url = None
    query_name = "Uploaded Photo"
    if query_face_id:
        query_face_url = resolve_face_image_url(query_face_id, crop_files)
    if result.get("query_name"):
        query_name = result["query_name"]

    # Top match info for OG tags
    top_match = matches[0] if matches else {}
    top_confidence = top_match.get("confidence_pct", 0)
    top_name = top_match.get("identity_name", "Unknown")

    og_title = f"{top_confidence}% Similar — {query_name} vs {top_name}" if matches else "Face Comparison — Rhodesli"
    og_desc = f"Compare faces in the Rhodes Jewish heritage photo archive. {len(matches)} match{'es' if len(matches) != 1 else ''} found."
    og_image = query_face_url or ""
    result_og = og_tags(og_title, og_desc, og_image, f"/compare/result/{result_id}")

    nav_links = _public_nav_links(active="compare", user=user)
    share_url = f"{SITE_URL}/compare/result/{result_id}"

    # Build match cards
    result_cards = []
    for i, match in enumerate(matches[:10]):
        fid = match.get("face_id", "")
        match_url = resolve_face_image_url(fid, crop_files)
        pct = match.get("confidence_pct", 0)
        name = match.get("identity_name", f"Face #{i+1}")
        identity_id = match.get("identity_id", "")

        if pct >= 85:
            label = "Very likely same person"
            color = "text-emerald-400"
        elif pct >= 70:
            label = "Strong match"
            color = "text-amber-400"
        elif pct >= 50:
            label = "Possible match"
            color = "text-blue-400"
        else:
            label = "Unlikely match"
            color = "text-slate-400"

        person_link = A(name, href=f"/person/{identity_id}", cls="text-indigo-400 hover:text-indigo-300 text-sm") if identity_id else Span(name, cls="text-sm text-white")

        result_cards.append(Div(
            Img(src=match_url, cls="w-16 h-16 rounded-full object-cover") if match_url else Div(cls="w-16 h-16 rounded-full bg-slate-700"),
            Div(
                person_link,
                P(f"{pct}% — {label}", cls=f"text-xs {color}"),
                cls="flex-1",
            ),
            cls="flex items-center gap-4 p-3 bg-slate-800/70 rounded-lg",
        ))

    # Response form (no login required)
    response_count = len(responses)
    response_form = Div(
        H3("Do you recognize anyone?", cls="text-base font-serif text-white mb-3"),
        P(f"{response_count} response{'s' if response_count != 1 else ''} so far" if response_count else "Be the first to respond!", cls="text-xs text-slate-500 mb-3"),
        Form(
            Div(
                Textarea(
                    name="note", placeholder="I think this is... / I recognize the person on the left...",
                    cls="w-full bg-slate-700 border border-slate-600 text-slate-200 text-sm rounded-lg px-3 py-2 resize-none",
                    rows="3",
                ),
                cls="mb-3",
            ),
            Input(type="hidden", name="result_id", value=result_id),
            Button("Submit Response", type="submit",
                   cls="px-4 py-2 bg-amber-600 hover:bg-amber-500 text-white text-sm font-medium rounded-lg transition-colors"),
            hx_post=f"/api/compare/result/{result_id}/respond",
            hx_target="#result-response-section",
            hx_swap="innerHTML",
            data_testid="result-response-form",
        ),
        id="result-response-section",
        cls="mt-8 pt-6 border-t border-slate-800",
        data_testid="response-section",
    )

    return (
        Title(og_title),
        *result_og,
        Style("html, body { margin: 0; } body { background-color: #0f172a; }"),
        Main(
            Nav(
                Div(
                    A(Span("Rhodesli", cls="text-xl font-bold text-white"), href="/", cls="hover:opacity-90"),
                    Div(*nav_links, cls="flex items-center gap-3 sm:gap-6"),
                    cls="max-w-6xl mx-auto px-6 flex items-center justify-between h-16",
                ),
                cls="bg-slate-900/80 backdrop-blur-md border-b border-slate-800 sticky top-0 z-50",
            ),
            Section(
                Div(
                    H1("Face Comparison Result", cls="text-2xl font-serif font-bold text-white mb-2"),
                    P(og_desc, cls="text-slate-400 text-sm mb-6"),

                    # Match list
                    Div(*result_cards, cls="space-y-3") if result_cards else P("No matches found.", cls="text-slate-500"),

                    # Share
                    Div(
                        share_button(url=f"/compare/result/{result_id}", style="prominent",
                                     label="Share with someone who might know",
                                     title=og_title, text=og_desc),
                        cls="mt-6 text-center",
                    ),

                    # Response form
                    response_form,

                    # Back link
                    Div(
                        A("Try Another Comparison", href="/compare",
                          cls="text-indigo-400 hover:text-indigo-300 text-sm"),
                        cls="mt-6 text-center",
                    ),
                    cls="max-w-2xl mx-auto px-6 py-10",
                ),
            ),
            _share_script(),
            cls="min-h-screen bg-slate-900",
        ),
    )


@rt("/api/compare/result/{result_id}/respond")
def post(result_id: str, note: str = "", sess=None):
    """Save a response to a comparison result. No login required."""
    data = _load_comparison_results()
    result = data.get("results", {}).get(result_id)
    if not result:
        return P("Result not found.", cls="text-amber-500 text-sm")

    user = get_current_user(sess or {}) if is_auth_enabled() else None
    response = {
        "note": note.strip(),
        "submitted_at": datetime.now().isoformat(),
        "submitted_by": user.email if user else "anonymous",
    }
    if "responses" not in result:
        result["responses"] = []
    result["responses"].append(response)
    _save_comparison_result(result)

    return Div(
        P("Thank you for your response!", cls="text-emerald-400 text-sm mb-2"),
        P(f"{len(result['responses'])} response{'s' if len(result['responses']) != 1 else ''} total.",
          cls="text-xs text-slate-500"),
        id="result-response-section",
    )


# ---- Connection Finder (Six Degrees) ----


def _load_social_graph():
    """Load and cache the unified social graph."""
    from rhodesli_ml.graph.social_graph import build_social_graph
    rel_graph = _load_relationship_graph()
    cooccur_path = data_path / "co_occurrence_graph.json"
    cooccur = {"edges": []}
    if cooccur_path.exists():
        try:
            cooccur = json.loads(cooccur_path.read_text(encoding="utf-8"))
        except (json.JSONDecodeError, ValueError):
            pass
    return build_social_graph(rel_graph, cooccur)


def _connection_path_html(path_steps, registry):
    """Render a connection path as styled HTML steps."""
    if path_steps is None:
        return Div(
            P("No known connection found.", cls="text-slate-400 text-center py-8"),
            cls="mt-4",
        )
    if len(path_steps) == 0:
        return Div(
            P("Same person!", cls="text-emerald-400 text-center py-4"),
            cls="mt-4",
        )

    steps = []
    for i, step in enumerate(path_steps):
        from_id = step["from"]
        to_id = step["to"]
        edge = step["edge"]
        from_ident = _safe_get_identity(registry, from_id)
        to_ident = _safe_get_identity(registry, to_id)
        from_name = ensure_utf8_display(from_ident.get("name", "Unknown"))
        to_name = ensure_utf8_display(to_ident.get("name", "Unknown"))

        # Edge styling by category
        if edge.get("category") == "family":
            edge_color = "text-amber-400 bg-amber-900/30 border-amber-700/50"
            edge_icon = '<svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4 inline mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"/></svg>'
        else:
            edge_color = "text-blue-400 bg-blue-900/30 border-blue-700/50"
            edge_icon = '<svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4 inline mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"/><path stroke-linecap="round" stroke-linejoin="round" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z"/></svg>'

        label = edge.get("label", edge.get("type", "connected"))

        if i == 0:
            steps.append(
                Div(
                    A(from_name, href=f"/person/{from_id}", cls="text-white font-semibold hover:text-indigo-300 transition-colors"),
                    cls="px-4 py-2 bg-slate-800 rounded-lg border border-slate-700",
                )
            )

        # Arrow + relationship label
        steps.append(
            Div(
                Div(
                    NotStr(edge_icon),
                    Span(label, cls="text-xs"),
                    cls=f"inline-flex items-center px-3 py-1 rounded-full border text-xs {edge_color}",
                ),
                Div("", cls="w-px h-3 bg-slate-700 mx-auto"),
                cls="flex flex-col items-center my-1",
            )
        )

        # Target person
        steps.append(
            Div(
                A(to_name, href=f"/person/{to_id}", cls="text-white font-semibold hover:text-indigo-300 transition-colors"),
                cls="px-4 py-2 bg-slate-800 rounded-lg border border-slate-700",
            )
        )

    return Div(*steps, cls="flex flex-col items-center mt-6", data_testid="connection-path")


# =============================================================================
# ROUTES - YEAR ESTIMATION TOOL
# =============================================================================


@rt("/estimate")
def get(photo: str = "", sess=None):
    """
    Year Estimation Tool — estimate when a photo was taken.

    Uses apparent ages + known birth years + scene analysis.
    Public page, no auth required.
    """
    user = get_current_user(sess or {}) if is_auth_enabled() else None
    is_admin = (user.is_admin if user else False) if is_auth_enabled() else True

    _build_caches()
    registry = load_registry()
    crop_files = get_crop_files()

    # Build photo selector from archive
    photo_options = []
    photo_reg = load_photo_registry()
    labels = _load_date_labels()

    # Get all photos, sorted by those with most identified faces first
    all_photo_ids = list(_photo_cache.keys()) if _photo_cache else []

    # Estimation results
    estimate_result = None
    selected_photo = None
    if photo and photo in (_photo_cache or {}):
        from core.year_estimation import estimate_photo_year
        selected_photo = _photo_cache[photo]
        estimate_result = estimate_photo_year(
            photo_id=photo,
            date_labels=labels,
            photo_cache=_photo_cache,
            identity_registry=registry,
            birth_year_fn=_get_birth_year,
            face_to_identity_fn=get_identity_for_face,
        )

    # Build the page
    nav_links = _public_nav_links(active="compare", user=user)

    # Photo grid selector
    photo_grid_items = []
    for pid in all_photo_ids[:60]:
        pm = _photo_cache.get(pid, {})
        if not pm:
            continue
        photo_path = pm.get("path") or pm.get("filename", "")
        if not photo_path:
            continue
        purl = storage.get_photo_url(photo_path)
        face_count = len(pm.get("face_ids", []))
        is_selected = pid == photo

        photo_grid_items.append(
            A(
                Img(src=purl, alt="Archive photo",
                    cls=f"w-full h-20 object-cover rounded-lg {'ring-2 ring-amber-400' if is_selected else 'hover:ring-2 hover:ring-indigo-400'} transition-all"),
                Span(f"{face_count} face{'s' if face_count != 1 else ''}", cls="text-[10px] text-slate-500 block text-center mt-0.5"),
                href=f"/estimate?photo={pid}",
                cls="block",
            )
        )

    # Result display
    result_section = None
    if estimate_result and selected_photo:
        photo_path = selected_photo.get("path") or selected_photo.get("filename", "")
        photo_url_val = storage.get_photo_url(photo_path)

        # Per-face evidence cards
        face_cards = []
        for ev in estimate_result.get("face_evidence", []):
            if not ev.get("apparent_age"):
                continue
            person_name = ev.get("person_name") or "Unknown person"
            birth_text = f"born ~{ev['birth_year']}" if ev.get("birth_year") else "birth year unknown"
            year_text = f"c. {ev['estimated_year']}" if ev.get("estimated_year") else "—"
            source_badge = ""
            if ev.get("birth_year_source") == "confirmed":
                source_badge = Span("verified", cls="text-[10px] bg-emerald-900/50 text-emerald-300 px-1.5 py-0.5 rounded-full ml-2")
            elif ev.get("birth_year_source") == "ml_inferred":
                source_badge = Span("estimated", cls="text-[10px] bg-indigo-900/50 text-indigo-300 px-1.5 py-0.5 rounded-full ml-2")

            face_cards.append(
                Div(
                    Div(
                        Span(person_name, cls="text-sm font-semibold text-white"),
                        source_badge,
                        cls="flex items-center",
                    ),
                    P(f"Appears ~{ev['apparent_age']} years old ({birth_text})", cls="text-xs text-slate-400 mt-0.5"),
                    P(year_text, cls="text-lg font-bold text-amber-400 mt-1") if ev.get("estimated_year") else None,
                    cls="bg-slate-800/50 rounded-lg p-3 border border-slate-700/50",
                )
            )

        # Scene evidence
        scene_card = None
        scene = estimate_result.get("scene_evidence")
        if scene and scene.get("clues"):
            scene_card = Div(
                Div(
                    Span("Scene Analysis", cls="text-sm font-semibold text-white"),
                    cls="flex items-center",
                ),
                P(", ".join(scene["clues"][:4]), cls="text-xs text-slate-400 mt-0.5"),
                P(f"Suggests: {scene['scene_estimate']}", cls="text-sm text-slate-300 mt-1") if scene.get("scene_estimate") else None,
                cls="bg-slate-800/50 rounded-lg p-3 border border-slate-700/50",
            )

        # Confidence styling
        conf = estimate_result.get("confidence", "low")
        conf_color = {"high": "text-emerald-400", "medium": "text-amber-400", "low": "text-slate-400"}.get(conf, "text-slate-400")
        conf_label = {"high": "High confidence", "medium": "Moderate confidence", "low": "Low confidence"}.get(conf, "")
        margin = estimate_result.get("margin", 10)
        method_label = "Based on facial age analysis" if estimate_result.get("method") == "facial_age_aggregation" else "Based on scene analysis"

        result_section = Div(
            # Photo with estimate badge
            Div(
                Img(src=photo_url_val, alt="Selected photo",
                    cls="w-full max-w-lg mx-auto rounded-xl shadow-lg"),
                cls="mb-6",
            ),
            # Main estimate
            Div(
                H2(f"Estimated: c. {estimate_result['year']}", cls="text-3xl font-serif font-bold text-white text-center"),
                P(f"+/- {margin} years", cls="text-lg text-slate-400 text-center"),
                Div(
                    Span(conf_label, cls=f"text-sm font-medium {conf_color}"),
                    Span(" · ", cls="text-slate-600"),
                    Span(method_label, cls="text-xs text-slate-500"),
                    cls="flex items-center justify-center gap-1 mt-2",
                ),
                cls="text-center mb-8",
            ),
            # How we estimated this
            H3("How we estimated this", cls="text-lg font-serif font-semibold text-white mb-4"),
            Div(*face_cards, scene_card, cls="flex flex-col gap-3 mb-6") if face_cards or scene_card else
            P("No detailed evidence available for this photo.", cls="text-sm text-slate-500 italic"),
            # CTAs
            Div(
                share_button(url=f"/estimate?photo={photo}", style="button", label="Share Estimate",
                             title=f"This photo was taken c. {estimate_result['year']}",
                             text="Year estimation from the Rhodesli Heritage Archive"),
                A("View Photo Page", href=f"/photo/{photo}", cls="px-4 py-2 bg-slate-700 hover:bg-slate-600 text-white text-sm font-medium rounded-lg transition-colors"),
                A("Try Another", href="/estimate", cls="px-4 py-2 bg-slate-800 hover:bg-slate-700 text-slate-300 text-sm font-medium rounded-lg transition-colors border border-slate-700"),
                cls="flex flex-wrap justify-center gap-3 mt-6",
            ),
            cls="bg-slate-800/30 rounded-xl p-6 border border-slate-700/30 mt-8",
        )
    elif photo and not estimate_result:
        # Photo selected but no estimate possible
        photo_path = (selected_photo or {}).get("path") or (selected_photo or {}).get("filename", "")
        photo_url_val = storage.get_photo_url(photo_path) if photo_path else ""
        result_section = Div(
            Img(src=photo_url_val, alt="Selected photo",
                cls="w-full max-w-lg mx-auto rounded-xl shadow-lg mb-4") if photo_url_val else None,
            P("Not enough data to estimate the year for this photo.", cls="text-slate-400 text-center"),
            P("Photos with identified people and known birth years produce the best estimates.",
              cls="text-xs text-slate-500 text-center mt-2"),
            A("Try another photo", href="/estimate",
              cls="text-indigo-400 hover:text-indigo-300 text-sm text-center block mt-4"),
            cls="bg-slate-800/30 rounded-xl p-6 border border-slate-700/30 mt-8 text-center",
        )

    # Tab links: Compare Faces | Estimate Year
    tab_links = Div(
        A("Compare Faces", href="/compare",
          cls="px-4 py-2 text-sm font-medium text-slate-400 hover:text-white border-b-2 border-transparent hover:border-indigo-400 transition-colors"),
        A("Estimate Year", href="/estimate",
          cls="px-4 py-2 text-sm font-medium text-white border-b-2 border-indigo-400 transition-colors"),
        cls="flex items-center justify-center gap-6 mb-8 border-b border-slate-700/50 pb-0",
    )

    og = og_tags(
        title="When Was This Photo Taken? — Rhodesli",
        description="Our AI estimates the year a photo was taken using facial age analysis and historical clues.",
        canonical_url=f"{SITE_URL}/estimate",
    )

    page_style = Style("html, body { margin: 0; } body { background-color: #0f172a; }")

    return (
        Title("When Was This Photo Taken? — Rhodesli"),
        *og,
        page_style,
        Main(
            Nav(
                Div(
                    A(Span("Rhodesli", cls="text-lg font-serif font-bold text-white"), href="/"),
                    Div(*nav_links, cls="hidden sm:flex items-center gap-6"),
                    cls="max-w-5xl mx-auto px-6 flex items-center justify-between h-16",
                ),
                cls="bg-slate-900/80 backdrop-blur-md border-b border-slate-800 sticky top-0 z-50",
            ),
            Section(
                Div(
                    tab_links,
                    H1("When Was This Photo Taken?",
                        cls="text-2xl sm:text-3xl font-serif font-bold text-white text-center mb-2"),
                    P("Select a photo from the archive. Our AI estimates the year using facial age analysis and historical clues.",
                      cls="text-slate-400 text-sm text-center mb-8 max-w-lg mx-auto"),
                    # Results (if photo selected)
                    result_section,
                    # Photo selector
                    Div(
                        H3("Select a Photo" if not photo else "Try Another Photo",
                           cls="text-sm font-semibold text-slate-400 uppercase tracking-wider mb-3"),
                        Div(*photo_grid_items, cls="grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 gap-2"),
                        cls="mt-8",
                    ) if photo_grid_items else None,
                    P("The more people you identify, the better the estimate.",
                      cls="text-xs text-slate-500 text-center mt-6"),
                    cls="max-w-4xl mx-auto pt-8 pb-16 px-6",
                ),
            ),
            cls="min-h-screen bg-slate-900 text-white",
        ),
        _share_script(),
    )


@rt("/tree")
def get(person: str = "", show_theory: str = "true", sess=None):
    """Family Tree — hierarchical visualization of family relationships."""
    user = get_current_user(sess or {}) if is_auth_enabled() else None

    registry = load_registry()
    rel_graph = _load_relationship_graph()

    # Filter out theory relationships if requested
    if show_theory == "false":
        filtered_rels = [
            r for r in rel_graph.get("relationships", [])
            if r.get("confidence", "confirmed") != "theory"
        ]
        rel_graph = {**rel_graph, "relationships": filtered_rels}

    # Build person selector options (confirmed identities with real names)
    confirmed = [
        i for i in registry.list_identities(state=IdentityState.CONFIRMED)
        if not i.get("name", "").startswith("Unidentified") and not i.get("merged_into")
    ]
    confirmed.sort(key=lambda x: (x.get("name") or "").lower())

    person_options = [Option("Everyone", value="")]
    for ident in confirmed:
        name = ensure_utf8_display(ident.get("name", ""))
        iid = ident.get("identity_id", "")
        person_options.append(Option(name, value=iid, selected=(iid == person)))

    # Build tree data
    from rhodesli_ml.graph.relationship_graph import build_family_tree
    identities_dict = {}
    for ident in registry.list_identities(state=IdentityState.CONFIRMED):
        if not ident.get("merged_into"):
            identities_dict[ident["identity_id"]] = ident

    tree_data = build_family_tree(
        rel_graph, identities_dict,
        root_person=person if person else None,
    )

    # Enrich tree nodes with avatar URLs
    crop_files = get_crop_files()

    def _enrich_with_avatars(nodes):
        for node in nodes:
            if node.get("type") == "couple":
                for member in node.get("members", []):
                    member["avatar_url"] = _get_person_avatar(member["id"], registry, crop_files)
                _enrich_with_avatars(node.get("children", []))
            else:
                node["avatar_url"] = _get_person_avatar(node.get("id", ""), registry, crop_files)
                _enrich_with_avatars(node.get("children", []))

    def _get_person_avatar(person_id, reg, crops):
        try:
            ident = reg.get_identity(person_id)
            if not ident:
                return None
            anchor_ids = ident.get("anchor_ids", [])
            if anchor_ids:
                url = resolve_face_image_url(anchor_ids[0], crops)
                if url:
                    return url
        except (KeyError, IndexError):
            pass
        return None

    _enrich_with_avatars(tree_data)

    tree_json = json.dumps(tree_data)

    # Person name for title/OG
    person_name = ""
    if person:
        try:
            p_ident = registry.get_identity(person)
            if p_ident:
                person_name = ensure_utf8_display(p_ident.get("name", ""))
        except KeyError:
            pass

    title_text = f"{person_name}'s Family Tree" if person_name else "Family Tree"
    share_url = f"/tree?person={person}" if person else "/tree"

    nav_links = _public_nav_links(active="tree", user=user)

    page_style = Style("""
        html, body { margin: 0; }
        body { background-color: #0f172a; }
        #tree-container { width: 100%; min-height: 600px; border-radius: 0.75rem; overflow: hidden; }
        @media (min-width: 768px) { #tree-container { min-height: 700px; } }
        .tree-node rect { cursor: pointer; transition: filter 0.2s ease; }
        .tree-node rect:hover { filter: brightness(1.2); }
        .tree-node text { pointer-events: none; }
        .tree-link { fill: none; stroke: #d97706; stroke-width: 2; stroke-opacity: 0.6; }
        .spouse-link { stroke: #ec4899; stroke-dasharray: 5,3; stroke-opacity: 0.6; }
        .highlight-glow { filter: drop-shadow(0 0 8px rgba(99, 102, 241, 0.6)); }
    """)

    empty_state = ""
    if not tree_data:
        empty_state = Div(
            Div(
                Span("No family relationships found yet.", cls="text-slate-400 text-lg"),
                P("Import a GEDCOM file to build the family tree.", cls="text-slate-500 mt-2"),
                cls="text-center py-16",
            ),
            id="tree-container",
        )

    return (
        Title(f"{title_text} — Rhodesli"),
        Meta(property="og:title", content=f"{title_text} — Rhodesli"),
        Meta(property="og:description", content="Explore the Rhodes-Capeluto family tree — generations of a Sephardic Jewish family from Rhodes."),
        Meta(property="og:url", content=f"{SITE_URL}{share_url}"),
        page_style,
        Div(
            Nav(
                Div(
                    A(Span("Rhodesli", cls="text-xl font-bold text-white"), href="/", cls="hover:opacity-90"),
                    Div(*nav_links, cls="hidden sm:flex items-center gap-6"),
                    cls="max-w-6xl mx-auto px-6 flex items-center justify-between",
                ),
                cls="fixed top-0 left-0 right-0 h-16 bg-slate-900/80 backdrop-blur-md border-b border-slate-800 z-50",
            ),
            Div(
                # Header
                Div(
                    H1(title_text, cls="text-2xl md:text-3xl font-bold text-white mb-2"),
                    P("Explore family relationships across generations.", cls="text-slate-400 mb-6"),
                    cls="mb-6",
                ),

                # Controls row
                Div(
                    Form(
                        Div(
                            Label("Focus on", cls="text-xs text-slate-400 mb-1 block"),
                            Select(*person_options, name="person",
                                   cls="px-3 py-2 bg-slate-800 text-white rounded-lg border border-slate-700 focus:border-indigo-500 outline-none text-sm",
                                   onchange="this.form.submit()"),
                        ),
                        Div(
                            Label(
                                Input(type="checkbox", name="show_theory", value="true",
                                      checked=(show_theory != "false"),
                                      cls="mr-2 rounded",
                                      onchange="this.form.submit()"),
                                "Show speculative",
                                cls="text-sm text-slate-400 flex items-center",
                            ),
                            cls="flex items-end pb-2",
                        ),
                        # Hidden field to handle unchecked checkbox
                        Input(type="hidden", name="show_theory", value="false") if show_theory == "false" else "",
                        method="get",
                        action="/tree",
                        cls="flex flex-wrap gap-4 items-end",
                    ),
                    # Share button
                    Button(
                        NotStr(_SHARE_ICON_SVG),
                        " Share",
                        cls="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-500 text-white text-sm rounded-lg transition-colors inline-flex items-center gap-1",
                        type="button",
                        data_action="share-photo",
                        data_share_url=share_url,
                    ),
                    cls="flex flex-wrap items-end justify-between gap-4 bg-slate-800/50 rounded-xl p-4 border border-slate-700/50 mb-6",
                ),

                # Tree visualization
                empty_state if not tree_data else Div(
                    Div(
                        Div(
                            Div(Div(cls="w-2.5 h-2.5 rounded-full", style="background:#d97706"), Span("Parent-Child", cls="text-xs text-slate-500"), cls="flex items-center gap-1.5"),
                            Div(Div(cls="w-2.5 h-2.5 rounded-full", style="background:#ec4899"), Span("Spouse", cls="text-xs text-slate-500"), cls="flex items-center gap-1.5"),
                            cls="flex gap-4",
                        ),
                        cls="flex justify-end mb-2",
                    ),
                    Div(id="tree-container", cls="bg-slate-800/50 rounded-xl border border-slate-700/50"),
                ),

                cls="max-w-6xl mx-auto px-6 pt-24 pb-16",
            ),
            # D3.js
            Script(src="https://d3js.org/d3.v7.min.js"),
            Script(f"""
(function() {{
    var treeData = {tree_json};
    var container = document.getElementById('tree-container');
    if (!container || !treeData.length) return;

    var focusPerson = '{person}';
    var nodeW = 140, nodeH = 70, coupleGap = 10;

    // Flatten the tree into a d3-hierarchy-compatible format
    // Each couple becomes a single node in the hierarchy with children
    function flatten(nodes) {{
        if (!nodes || !nodes.length) return null;
        // If multiple roots, create a virtual root
        if (nodes.length === 1) return convertNode(nodes[0]);
        return {{
            id: '_root',
            type: 'virtual',
            children: nodes.map(convertNode)
        }};
    }}

    function convertNode(n) {{
        var result = {{
            id: n.id || (n.members ? n.members.map(function(m){{ return m.id; }}).join('+') : 'unknown'),
            type: n.type,
            members: n.members || null,
            name: n.name || '',
            avatar_url: n.avatar_url || null,
            birth_year: n.birth_year || null,
            death_year: n.death_year || null,
        }};
        if (n.children && n.children.length) {{
            result.children = n.children.map(convertNode);
        }}
        return result;
    }}

    var root = d3.hierarchy(flatten(treeData));

    var treeLayout = d3.tree().nodeSize([nodeW * 2 + coupleGap + 40, 140]);
    treeLayout(root);

    // Compute bounds
    var x0 = Infinity, x1 = -Infinity, y0 = Infinity, y1 = -Infinity;
    root.each(function(d) {{
        if (d.x < x0) x0 = d.x;
        if (d.x > x1) x1 = d.x;
        if (d.y < y0) y0 = d.y;
        if (d.y > y1) y1 = d.y;
    }});

    var treeW = x1 - x0 + nodeW * 4;
    var treeH = y1 - y0 + nodeH * 4;
    var svgW = container.clientWidth || 900;
    var svgH = Math.max(600, treeH + 100);
    container.style.height = svgH + 'px';

    var svg = d3.select('#tree-container')
        .append('svg')
        .attr('width', svgW)
        .attr('height', svgH);

    var g = svg.append('g');

    // Zoom
    svg.call(d3.zoom().scaleExtent([0.3, 4]).on('zoom', function(event) {{
        g.attr('transform', event.transform);
    }}));

    // Center the tree
    var initialX = svgW / 2 - (x0 + x1) / 2;
    var initialY = 60 - y0;
    g.attr('transform', 'translate(' + initialX + ',' + initialY + ')');

    // Draw links (parent-child)
    g.selectAll('.tree-link')
        .data(root.links().filter(function(d) {{ return d.source.data.type !== 'virtual'; }}))
        .join('path')
        .attr('class', 'tree-link')
        .attr('d', function(d) {{
            var sy = d.source.y + nodeH;
            var ty = d.target.y;
            var mx = d.target.x;
            return 'M' + d.source.x + ',' + sy +
                   ' V' + ((sy + ty) / 2) +
                   ' H' + mx +
                   ' V' + ty;
        }});

    // Draw nodes
    var nodes = g.selectAll('.tree-node')
        .data(root.descendants().filter(function(d) {{ return d.data.type !== 'virtual'; }}))
        .join('g')
        .attr('class', 'tree-node')
        .attr('transform', function(d) {{ return 'translate(' + d.x + ',' + d.y + ')'; }});

    // For couple nodes, draw two side-by-side cards
    nodes.each(function(d) {{
        var el = d3.select(this);
        if (d.data.type === 'couple' && d.data.members) {{
            var m = d.data.members;
            var halfW = nodeW / 2 + coupleGap / 2;

            // Spouse connector (dashed pink line)
            el.append('line')
                .attr('x1', -coupleGap / 2)
                .attr('y1', nodeH / 2)
                .attr('x2', coupleGap / 2)
                .attr('y2', nodeH / 2)
                .attr('class', 'spouse-link')
                .attr('stroke', '#ec4899')
                .attr('stroke-width', 2);

            for (var i = 0; i < m.length; i++) {{
                var offsetX = i === 0 ? -halfW : coupleGap / 2;
                var person = m[i];
                var isHighlighted = person.id === focusPerson;
                var cardG = el.append('g')
                    .attr('transform', 'translate(' + offsetX + ',0)')
                    .style('cursor', 'pointer')
                    .on('click', (function(pid) {{ return function() {{ window.location.href = '/person/' + pid; }}; }})(person.id));

                cardG.append('rect')
                    .attr('width', nodeW)
                    .attr('height', nodeH)
                    .attr('rx', 8)
                    .attr('fill', '#1e293b')
                    .attr('stroke', isHighlighted ? '#818cf8' : '#334155')
                    .attr('stroke-width', isHighlighted ? 2.5 : 1)
                    .attr('class', isHighlighted ? 'highlight-glow' : '');

                // Avatar circle
                if (person.avatar_url) {{
                    var clipId = 'clip-' + person.id.replace(/[^a-zA-Z0-9]/g, '');
                    el.append('defs').append('clipPath').attr('id', clipId)
                        .append('circle').attr('cx', offsetX + 25).attr('cy', 25).attr('r', 16);
                    cardG.append('image')
                        .attr('href', person.avatar_url)
                        .attr('x', 9)
                        .attr('y', 9)
                        .attr('width', 32)
                        .attr('height', 32)
                        .attr('clip-path', 'url(#' + clipId + ')');
                }} else {{
                    // Letter initial
                    cardG.append('circle')
                        .attr('cx', 25).attr('cy', 25).attr('r', 16)
                        .attr('fill', '#374151');
                    cardG.append('text')
                        .attr('x', 25).attr('y', 30)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#9ca3af')
                        .attr('font-size', '14px')
                        .text((person.name || '?')[0]);
                }}

                // Name
                var displayName = person.name || 'Unknown';
                if (displayName.length > 14) displayName = displayName.substring(0, 13) + '\u2026';
                cardG.append('text')
                    .attr('x', 48).attr('y', 22)
                    .attr('fill', '#e2e8f0')
                    .attr('font-size', '12px')
                    .attr('font-weight', '600')
                    .text(displayName);

                // Dates
                var dates = '';
                if (person.birth_year) dates += person.birth_year;
                if (person.birth_year && person.death_year) dates += '\u2013' + person.death_year;
                if (dates) {{
                    cardG.append('text')
                        .attr('x', 48).attr('y', 38)
                        .attr('fill', '#64748b')
                        .attr('font-size', '10px')
                        .text(dates);
                }}
            }}
        }} else {{
            // Single person node
            var person = d.data;
            var isHighlighted = person.id === focusPerson;
            var cardG = el.append('g')
                .style('cursor', 'pointer')
                .on('click', function() {{ window.location.href = '/person/' + person.id; }});

            cardG.append('rect')
                .attr('x', -nodeW / 2)
                .attr('width', nodeW)
                .attr('height', nodeH)
                .attr('rx', 8)
                .attr('fill', '#1e293b')
                .attr('stroke', isHighlighted ? '#818cf8' : '#334155')
                .attr('stroke-width', isHighlighted ? 2.5 : 1)
                .attr('class', isHighlighted ? 'highlight-glow' : '');

            // Avatar
            if (person.avatar_url) {{
                var clipId = 'clip-' + (person.id || 'x').replace(/[^a-zA-Z0-9]/g, '');
                el.append('defs').append('clipPath').attr('id', clipId)
                    .append('circle').attr('cx', -nodeW / 2 + 25).attr('cy', 25).attr('r', 16);
                cardG.append('image')
                    .attr('href', person.avatar_url)
                    .attr('x', -nodeW / 2 + 9)
                    .attr('y', 9)
                    .attr('width', 32)
                    .attr('height', 32)
                    .attr('clip-path', 'url(#' + clipId + ')');
            }} else {{
                cardG.append('circle')
                    .attr('cx', -nodeW / 2 + 25).attr('cy', 25).attr('r', 16)
                    .attr('fill', '#374151');
                cardG.append('text')
                    .attr('x', -nodeW / 2 + 25).attr('y', 30)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#9ca3af')
                    .attr('font-size', '14px')
                    .text((person.name || '?')[0]);
            }}

            var displayName = person.name || 'Unknown';
            if (displayName.length > 14) displayName = displayName.substring(0, 13) + '\u2026';
            cardG.append('text')
                .attr('x', -nodeW / 2 + 48).attr('y', 22)
                .attr('fill', '#e2e8f0')
                .attr('font-size', '12px')
                .attr('font-weight', '600')
                .text(displayName);

            var dates = '';
            if (person.birth_year) dates += person.birth_year;
            if (person.birth_year && person.death_year) dates += '\u2013' + person.death_year;
            if (dates) {{
                cardG.append('text')
                    .attr('x', -nodeW / 2 + 48).attr('y', 38)
                    .attr('fill', '#64748b')
                    .attr('font-size', '10px')
                    .text(dates);
            }}
        }}
    }});

    // Auto-zoom to focus person if specified
    if (focusPerson) {{
        root.each(function(d) {{
            var nodeIds = [];
            if (d.data.members) {{
                nodeIds = d.data.members.map(function(m) {{ return m.id; }});
            }} else if (d.data.id) {{
                nodeIds = [d.data.id];
            }}
            if (nodeIds.indexOf(focusPerson) >= 0) {{
                var tx = svgW / 2 - d.x;
                var ty = svgH / 3 - d.y;
                svg.transition().duration(750).call(
                    d3.zoom().transform,
                    d3.zoomIdentity.translate(tx, ty).scale(1.2)
                );
            }}
        }});
    }}
}})();
"""),
            cls="min-h-screen bg-slate-900",
        ),
    )


@rt("/connect")
def get(person_a: str = "", person_b: str = "", sess=None):
    """Six Degrees Connection Finder — find how two people are connected."""
    user = get_current_user(sess or {}) if is_auth_enabled() else None

    registry = load_registry()

    # Build person selector options (confirmed identities with real names)
    confirmed = [
        i for i in registry.list_identities(state=IdentityState.CONFIRMED)
        if not i.get("name", "").startswith("Unidentified") and not i.get("merged_into")
    ]
    confirmed.sort(key=lambda x: (x.get("name") or "").lower())

    # Person selector options
    person_options = [Option("Select a person...", value="", disabled=True, selected=not person_a)]
    for ident in confirmed:
        name = ensure_utf8_display(ident.get("name", ""))
        iid = ident.get("identity_id", "")
        person_options.append(Option(name, value=iid, selected=(iid == person_a)))

    person_b_options = [Option("Select a person...", value="", disabled=True, selected=not person_b)]
    for ident in confirmed:
        name = ensure_utf8_display(ident.get("name", ""))
        iid = ident.get("identity_id", "")
        person_b_options.append(Option(name, value=iid, selected=(iid == person_b)))

    # Build connection results if both people selected
    results_html = ""
    if person_a and person_b:
        from rhodesli_ml.graph.social_graph import find_all_paths, export_for_d3
        social = _load_social_graph()
        paths = find_all_paths(social, person_a, person_b)

        name_a = ensure_utf8_display(_safe_get_identity(registry, person_a).get("name", "Unknown"))
        name_b = ensure_utf8_display(_safe_get_identity(registry, person_b).get("name", "Unknown"))

        # Compute degrees of separation
        any_path = paths.get("any")
        if any_path is not None:
            degrees = len(any_path)
            degrees_text = f"{degrees} degree{'s' if degrees != 1 else ''} of separation"
        else:
            degrees_text = "No known connection"

        path_sections = []

        # Main path (any edges)
        path_sections.append(
            Div(
                H3(f"{name_a} & {name_b}", cls="text-lg font-bold text-white mb-1"),
                P(degrees_text, cls="text-sm text-indigo-400 mb-4"),
                _connection_path_html(paths["any"], registry),
                cls="bg-slate-800/50 rounded-xl p-6 border border-slate-700/50",
                data_testid="connection-result",
            )
        )

        # Family-only path
        if paths.get("family") is not None and paths["family"] != paths["any"]:
            path_sections.append(
                Div(
                    H4("Family path", cls="text-sm font-semibold text-amber-400 mb-2"),
                    P(f"{len(paths['family'])} step{'s' if len(paths['family']) != 1 else ''} through family", cls="text-xs text-slate-500 mb-2"),
                    _connection_path_html(paths["family"], registry),
                    cls="bg-slate-800/30 rounded-lg p-4 border border-amber-900/30",
                )
            )

        # Photo-only path
        if paths.get("photo") is not None and paths["photo"] != paths["any"]:
            path_sections.append(
                Div(
                    H4("Photo path", cls="text-sm font-semibold text-blue-400 mb-2"),
                    P(f"{len(paths['photo'])} step{'s' if len(paths['photo']) != 1 else ''} through photos", cls="text-xs text-slate-500 mb-2"),
                    _connection_path_html(paths["photo"], registry),
                    cls="bg-slate-800/30 rounded-lg p-4 border border-blue-900/30",
                )
            )

        # Add "View in Family Tree" link if family path exists
        if paths.get("family") is not None:
            path_sections.append(
                Div(
                    A("View in Family Tree →", href=f"/tree?person={person_a}",
                      cls="text-sm text-indigo-400 hover:text-indigo-300",
                      data_testid="tree-link"),
                    cls="text-center mt-2",
                )
            )

        results_html = Div(*path_sections, cls="space-y-6 mt-8", id="connection-results")

    # Build D3 graph data for visualization
    from rhodesli_ml.graph.social_graph import export_for_d3
    social = _load_social_graph()

    # Count photos per person
    _build_caches()
    photo_reg = load_photo_registry()
    photo_counts = {}
    for ident in confirmed:
        iid = ident.get("identity_id", "")
        faces = ident.get("anchor_ids", []) + ident.get("candidate_ids", [])
        photos = set()
        for fid in faces:
            pid = photo_reg.get_photo_for_face(fid)
            if pid:
                photos.add(pid)
        photo_counts[iid] = len(photos)

    identities_dict = {i["identity_id"]: i for i in confirmed}
    d3_data = export_for_d3(social, identities_dict, photo_counts)
    d3_json = json.dumps(d3_data)

    # Navigation
    nav_links = _public_nav_links(active="connect", user=user)

    share_url = f"/connect?person_a={person_a}&person_b={person_b}" if person_a and person_b else "/connect"

    page_style = Style("""
        html, body { margin: 0; }
        body { background-color: #0f172a; }
        #graph-container { width: 100%; height: 500px; border-radius: 0.75rem; overflow: hidden; }
        @media (min-width: 768px) { #graph-container { height: 600px; } }
        .node-label { font-size: 11px; fill: #e2e8f0; pointer-events: none; text-anchor: middle; }
        .link-family { stroke: #d97706; stroke-opacity: 0.6; }
        .link-photo { stroke: #3b82f6; stroke-opacity: 0.4; }
        .node-circle { cursor: pointer; transition: r 0.2s ease; }
        .node-circle:hover { filter: brightness(1.3); }
        .graph-legend { display: flex; gap: 1rem; align-items: center; }
        .legend-item { display: flex; align-items: center; gap: 0.25rem; font-size: 0.75rem; color: #94a3b8; }
        .legend-dot { width: 10px; height: 10px; border-radius: 50%; }
    """)

    return (
        Title("Connect People — Rhodesli"),
        Meta(property="og:title", content="Connect People — Rhodesli"),
        Meta(property="og:description", content="Find how two people in the Rhodes-Capeluto family are connected through family and photos."),
        Meta(property="og:url", content=f"{SITE_URL}{share_url}"),
        page_style,
        Div(
            Nav(
                Div(
                    A(Span("Rhodesli", cls="text-xl font-bold text-white"), href="/", cls="hover:opacity-90"),
                    Div(*nav_links, cls="hidden sm:flex items-center gap-6"),
                    cls="max-w-6xl mx-auto px-6 flex items-center justify-between",
                ),
                cls="fixed top-0 left-0 right-0 h-16 bg-slate-900/80 backdrop-blur-md border-b border-slate-800 z-50",
            ),
            Div(
                # Header
                Div(
                    H1("Connect People", cls="text-2xl md:text-3xl font-bold text-white mb-2"),
                    P("Discover how two people are connected through family ties and shared photographs.", cls="text-slate-400 mb-6"),
                    cls="mb-6",
                ),

                # Person selectors
                Form(
                    Div(
                        Div(
                            Label("Person A", cls="text-xs text-slate-400 mb-1 block"),
                            Select(*person_options, name="person_a", cls="w-full px-3 py-2 bg-slate-800 text-white rounded-lg border border-slate-700 focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 outline-none"),
                            cls="flex-1",
                        ),
                        Div(
                            NotStr('<span class="text-2xl text-slate-600">&#x2194;</span>'),
                            cls="flex items-end pb-2",
                        ),
                        Div(
                            Label("Person B", cls="text-xs text-slate-400 mb-1 block"),
                            Select(*person_b_options, name="person_b", cls="w-full px-3 py-2 bg-slate-800 text-white rounded-lg border border-slate-700 focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 outline-none"),
                            cls="flex-1",
                        ),
                        Button(
                            "Find Connection",
                            cls="px-6 py-2 bg-indigo-600 hover:bg-indigo-500 text-white font-medium rounded-lg transition-colors self-end",
                            type="submit",
                        ),
                        cls="flex flex-col sm:flex-row gap-4 items-end",
                    ),
                    method="get",
                    action="/connect",
                    cls="bg-slate-800/50 rounded-xl p-6 border border-slate-700/50",
                    data_testid="connection-form",
                ),

                # Share button
                Div(
                    Button(
                        NotStr(_SHARE_ICON_SVG),
                        " Share",
                        cls="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-500 text-white text-sm rounded-lg transition-colors inline-flex items-center gap-1",
                        type="button",
                        data_action="share-photo",
                        data_share_url=share_url,
                    ),
                    cls="flex justify-end mt-4",
                ) if person_a and person_b else "",

                # Connection results
                results_html if results_html else "",

                # Graph visualization
                Div(
                    Div(
                        H3("Community Network", cls="text-lg font-semibold text-white"),
                        Div(
                            Div(Div(cls="legend-dot", style="background:#d97706"), Span("Family"), cls="legend-item"),
                            Div(Div(cls="legend-dot", style="background:#3b82f6"), Span("Photo"), cls="legend-item"),
                            cls="graph-legend",
                        ),
                        cls="flex items-center justify-between mb-4",
                    ),
                    Div(id="graph-container", cls="bg-slate-800/50 rounded-xl border border-slate-700/50"),
                    cls="mt-8",
                    data_testid="network-graph",
                ),

                cls="max-w-4xl mx-auto px-6 pt-24 pb-16",
            ),
            # D3.js script
            Script(src="https://d3js.org/d3.v7.min.js"),
            Script(f"""
(function() {{
    var data = {d3_json};
    var container = document.getElementById('graph-container');
    if (!container || !data.nodes.length) return;
    var width = container.clientWidth;
    var height = container.clientHeight || 500;

    var svg = d3.select('#graph-container')
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', [0, 0, width, height]);

    // Zoom behavior
    var g = svg.append('g');
    svg.call(d3.zoom().scaleExtent([0.3, 4]).on('zoom', function(event) {{
        g.attr('transform', event.transform);
    }}));

    // Force simulation
    var simulation = d3.forceSimulation(data.nodes)
        .force('link', d3.forceLink(data.links).id(function(d) {{ return d.id; }}).distance(function(d) {{
            return d.category === 'family' ? 80 : 120;
        }}))
        .force('charge', d3.forceManyBody().strength(-300))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collision', d3.forceCollide().radius(30));

    // Links
    var link = g.append('g')
        .selectAll('line')
        .data(data.links)
        .join('line')
        .attr('class', function(d) {{ return 'link-' + d.category; }})
        .attr('stroke-width', function(d) {{
            if (d.type === 'photographed_with') return Math.min(d.photo_count || 1, 5);
            return 2;
        }});

    // Nodes
    var node = g.append('g')
        .selectAll('g')
        .data(data.nodes)
        .join('g')
        .call(d3.drag()
            .on('start', function(event, d) {{
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x; d.fy = d.y;
            }})
            .on('drag', function(event, d) {{
                d.fx = event.x; d.fy = event.y;
            }})
            .on('end', function(event, d) {{
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null; d.fy = null;
            }})
        );

    node.append('circle')
        .attr('r', function(d) {{ return Math.max(8, Math.min(20, 5 + (d.photo_count || 0))); }})
        .attr('fill', function(d) {{
            // Highlight selected people
            if (d.id === '{person_a}') return '#818cf8';
            if (d.id === '{person_b}') return '#818cf8';
            return '#64748b';
        }})
        .attr('stroke', function(d) {{
            if (d.id === '{person_a}' || d.id === '{person_b}') return '#c7d2fe';
            return '#475569';
        }})
        .attr('stroke-width', function(d) {{
            if (d.id === '{person_a}' || d.id === '{person_b}') return 3;
            return 1.5;
        }})
        .attr('class', 'node-circle')
        .on('click', function(event, d) {{
            // Navigate to person on click
            window.location.href = '/person/' + d.id;
        }});

    node.append('text')
        .text(function(d) {{ return d.name; }})
        .attr('dy', function(d) {{ return Math.max(8, Math.min(20, 5 + (d.photo_count || 0))) + 14; }})
        .attr('class', 'node-label');

    /* Highlight path if both selected */
    var pathNodes = new Set();
    var pathLinks = new Set();
    var selectedA = '{person_a}';
    var selectedB = '{person_b}';

    simulation.on('tick', function() {{
        link
            .attr('x1', function(d) {{ return d.source.x; }})
            .attr('y1', function(d) {{ return d.source.y; }})
            .attr('x2', function(d) {{ return d.target.x; }})
            .attr('y2', function(d) {{ return d.target.y; }});
        node.attr('transform', function(d) {{ return 'translate(' + d.x + ',' + d.y + ')'; }});
    }});

    // Tooltip
    node.append('title')
        .text(function(d) {{ return d.name + ' (' + (d.photo_count || 0) + ' photos)'; }});
}})();
"""),
            cls="min-h-screen bg-slate-900",
        ),
    )


def public_photo_page(
    photo_id: str,
    selected_face_id: str = None,
    user=None,
    is_admin: bool = False,
) -> tuple:
    """
    Build the public shareable photo page.

    This is the beautiful, museum-like page that gets shared on social media.
    Shows the photo with face overlays, person cards, and a call to action.
    No authentication required.
    """
    photo = get_photo_metadata(photo_id)
    if not photo:
        # Gentle 404 page
        style_404 = Style("html, body { margin: 0; } body { background-color: #0f172a; }")
        return (
            Title("Photo Not Found - Rhodesli"),
            style_404,
            Main(
                Nav(
                    Div(
                        A(Span("Rhodesli", cls="text-xl font-bold text-white"), href="/", cls="hover:opacity-90"),
                        cls="max-w-5xl mx-auto px-6 flex items-center justify-between h-16"
                    ),
                    cls="bg-slate-900/80 backdrop-blur-md border-b border-slate-800"
                ),
                Div(
                    Div(
                        Span("404", cls="text-6xl font-bold text-slate-700 block mb-4"),
                        H1("Photo not found", cls="text-2xl font-serif font-bold text-white mb-3"),
                        P("This photo hasn't been added to the archive yet.", cls="text-slate-400 mb-8"),
                        A("Explore the Archive", href="/?section=photos",
                          cls="inline-block px-6 py-3 bg-indigo-600 text-white font-medium rounded-lg hover:bg-indigo-500 transition-colors"),
                        cls="text-center"
                    ),
                    cls="flex items-center justify-center min-h-[60vh]"
                ),
                cls="min-h-screen bg-slate-900"
            ),
        )

    filename = photo["filename"]
    width, height = get_photo_dimensions(filename)
    has_dimensions = width > 0 and height > 0
    registry = load_registry()
    from urllib.parse import quote as _url_quote

    # --- Photo carousel: prev/next within same collection ---
    collection_name = photo.get("collection", "")
    prev_photo_id = None
    next_photo_id = None
    nav_position = 0
    nav_total = 0
    if collection_name and _photo_cache:
        collection_photos = sorted(
            [pid for pid, pdata in _photo_cache.items()
             if pdata.get("collection", "") == collection_name],
            key=lambda pid: _photo_cache[pid].get("filename", "")
        )
        nav_total = len(collection_photos)
        if photo_id in collection_photos:
            idx = collection_photos.index(photo_id)
            nav_position = idx + 1
            if idx > 0:
                prev_photo_id = collection_photos[idx - 1]
            if idx < len(collection_photos) - 1:
                next_photo_id = collection_photos[idx + 1]

    # Check for back image (front/back flip feature)
    back_image = photo.get("back_image", "")
    back_transcription = photo.get("back_transcription", "")
    has_back = bool(back_image)

    # Non-destructive transforms (CSS-based, never modifies original)
    front_transform = photo.get("transform", "")
    back_transform_str = photo.get("back_transform", "")
    front_css_transform = parse_transform_to_css(front_transform)
    front_css_filter = parse_transform_to_filter(front_transform)
    back_css_transform = parse_transform_to_css(back_transform_str)
    back_css_filter = parse_transform_to_filter(back_transform_str)

    # Collect face info for overlays and person cards
    face_info_list = []
    identified_names = []
    unidentified_count = 0
    crop_files = get_crop_files()

    for face_data in photo.get("faces", []):
        face_id = face_data["face_id"]
        bbox = face_data.get("bbox", [])
        identity = get_identity_for_face(registry, face_id)
        raw_name = identity.get("name", "Unidentified") if identity else "Unidentified"
        display_name = ensure_utf8_display(raw_name)
        identity_id = identity["identity_id"] if identity else None
        state = identity.get("state", "INBOX") if identity else None
        is_identified = state == "CONFIRMED" and not display_name.startswith("Unidentified")

        # Get crop URL for person card
        crop_url = resolve_face_image_url(face_id, crop_files) if crop_files else None

        if is_identified:
            identified_names.append(display_name)
        else:
            unidentified_count += 1

        face_info_list.append({
            "face_id": face_id,
            "bbox": bbox,
            "display_name": display_name,
            "identity_id": identity_id,
            "state": state,
            "is_identified": is_identified,
            "crop_url": crop_url,
        })

    # First unidentified face from this photo — for contextual "Help Identify" CTA
    first_unidentified_id = next(
        (fi["identity_id"] for fi in face_info_list if not fi["is_identified"] and fi["identity_id"]),
        None)

    # --- Build face overlays (simplified for public view — no admin actions) ---
    face_overlays = []
    if has_dimensions:
        for fi in face_info_list:
            bbox = fi["bbox"]
            if not bbox or len(bbox) < 4:
                continue
            x1, y1, x2, y2 = bbox
            left_pct = (x1 / width) * 100
            top_pct = (y1 / height) * 100
            width_pct = ((x2 - x1) / width) * 100
            height_pct = ((y2 - y1) / height) * 100

            # Name label positioning: below box if face is near top (avoids clipping),
            # above box if face is lower (more natural reading position)
            name_above = top_pct > 15  # Face is below top 15% — put name above
            name_pos_cls = "-top-6" if name_above else "-bottom-6"

            if fi["is_identified"]:
                overlay_cls = "face-overlay-box absolute border-2 border-emerald-400/70 bg-emerald-400/5 hover:bg-emerald-400/15 transition-all cursor-pointer group"
                name_el = Span(
                    fi["display_name"],
                    cls=f"absolute {name_pos_cls} left-1/2 -translate-x-1/2 bg-black/80 text-emerald-300 text-[11px] px-2 py-0.5 rounded whitespace-nowrap pointer-events-none max-w-[200%] truncate"
                )
            else:
                overlay_cls = "face-overlay-box absolute border-2 border-dashed border-amber-400/50 bg-amber-400/5 hover:bg-amber-400/15 transition-all cursor-pointer group"
                name_el = Span(
                    "Unidentified",
                    cls=f"absolute {name_pos_cls} left-1/2 -translate-x-1/2 bg-black/80 text-amber-300/70 text-[11px] px-2 py-0.5 rounded whitespace-nowrap pointer-events-none opacity-0 group-hover:opacity-100 transition-opacity"
                )

            # Click navigates to person page (identified) or identify page (unidentified)
            if fi["is_identified"] and fi["identity_id"]:
                click_href = f"/person/{fi['identity_id']}"
            elif fi["identity_id"]:
                click_href = f"/identify/{fi['identity_id']}"
            else:
                click_href = None

            overlay_inner = A(
                name_el,
                href=click_href,
                cls=overlay_cls,
                style=f"left: {left_pct:.2f}%; top: {top_pct:.2f}%; width: {width_pct:.2f}%; height: {height_pct:.2f}%; display: block;",
                title=fi["display_name"],
                id=f"overlay-{fi['identity_id']}" if fi["identity_id"] else None,
            ) if click_href else Div(
                name_el,
                cls=overlay_cls,
                style=f"left: {left_pct:.2f}%; top: {top_pct:.2f}%; width: {width_pct:.2f}%; height: {height_pct:.2f}%;",
                title=fi["display_name"],
            )
            overlay = overlay_inner
            face_overlays.append(overlay)

    # --- Build person cards strip ---
    person_cards = []
    for fi in face_info_list:
        card_border = "border-emerald-500/30" if fi["is_identified"] else "border-slate-600/50"
        badge = Span("Identified", cls="text-[10px] text-emerald-400 bg-emerald-500/10 px-1.5 py-0.5 rounded-full") if fi["is_identified"] else Span("Unidentified", cls="text-[10px] text-amber-400/70 bg-amber-500/10 px-1.5 py-0.5 rounded-full")

        crop_el = Img(
            src=fi["crop_url"],
            alt=fi["display_name"],
            cls="w-20 h-20 rounded-full object-cover border-2 " + ("border-emerald-500/50" if fi["is_identified"] else "border-slate-600"),
            onerror="this.style.display='none'"
        ) if fi["crop_url"] else Div(
            Span("?", cls="text-2xl text-slate-500"),
            cls="w-20 h-20 rounded-full bg-slate-800 border-2 border-slate-600 flex items-center justify-center"
        )

        # Link to person page for identified people
        name_el = fi["display_name"]
        see_all_link = None
        if fi["is_identified"] and fi["identity_id"]:
            name_el = A(
                fi["display_name"],
                href=f"/person/{fi['identity_id']}",
                cls="text-white hover:text-emerald-300 transition-colors"
            )
            see_all_link = A(
                "See all photos \u2192",
                href=f"/person/{fi['identity_id']}",
                cls="text-[10px] text-indigo-400 hover:text-indigo-300 mt-1 transition-colors",
            )

        # Card links to person page (identified) or identify page (unidentified)
        if fi["is_identified"] and fi["identity_id"]:
            card_href = f"/person/{fi['identity_id']}"
            card_title = f"View {fi['display_name']}'s page"
        elif fi["identity_id"]:
            card_href = f"/identify/{fi['identity_id']}"
            card_title = "Help identify this person"
        else:
            card_href = None
            card_title = None

        card_inner = Div(
            crop_el,
            Div(
                P(name_el, cls="text-sm font-medium text-white mt-2 text-center") if isinstance(name_el, str) else Div(name_el, cls="text-sm font-medium mt-2 text-center"),
                badge,
                see_all_link,
                cls="flex flex-col items-center"
            ),
            id=f"person-{fi['identity_id']}" if fi["identity_id"] else None,
            cls=f"flex flex-col items-center p-4 bg-slate-800/50 rounded-xl border {card_border} min-w-[140px] flex-shrink-0 hover:bg-slate-700/50 transition-colors",
        )

        if card_href:
            person_cards.append(
                A(
                    card_inner,
                    href=card_href,
                    cls="no-underline cursor-pointer",
                    title=card_title,
                )
            )
        else:
            person_cards.append(card_inner)

    # --- Photo metadata line (with clickable collection link) ---
    meta_elements = []
    if photo.get("collection"):
        collection_name = photo["collection"]
        collection_slug = _collection_slug(collection_name)
        meta_elements.append(
            A(collection_name, href=f"/collection/{collection_slug}",
              cls="text-indigo-400 hover:text-indigo-300 transition-colors")
        )
    if photo.get("source") and photo.get("source") != photo.get("collection"):
        if meta_elements:
            meta_elements.append(Span(" · ", cls="text-slate-600"))
        meta_elements.append(Span(photo["source"]))
    meta_line = Span(*meta_elements) if meta_elements else None

    # --- Uploader attribution ---
    # TODO: When uploaded_by field is added to photo_index.json, show "Uploaded by [Name] on [Date]"
    # For now, fall back to source field as provenance indicator
    uploader_line = None
    if photo.get("source"):
        uploader_line = Span(f"Source: {photo['source']}", cls="text-xs text-slate-500")

    # --- Open Graph meta tag data ---
    total_faces = len(face_info_list)
    identified_count = len(identified_names)

    # Build OG title and description
    page_title = photo.get("collection") or "Historical Photo"
    og_title = f"{page_title} — Rhodesli Heritage Archive"

    if identified_count > 0:
        names_preview = ", ".join(identified_names[:3])
        if len(identified_names) > 3:
            names_preview += f", and {len(identified_names) - 3} more"
        if unidentified_count > 0:
            og_description = f"{identified_count} {'person' if identified_count == 1 else 'people'} identified: {names_preview}. Help identify the remaining {unidentified_count}."
        else:
            og_description = f"All {identified_count} {'person' if identified_count == 1 else 'people'} identified: {names_preview}."
    elif total_faces > 0:
        og_description = f"{total_faces} {'face' if total_faces == 1 else 'faces'} detected. Can you help identify anyone in this historical photo?"
    else:
        og_description = "A photograph from the Jewish heritage of Rhodes. Explore the archive."

    # Photo URL for og:image (must be publicly accessible)
    og_image_url = photo_url(filename)
    if not og_image_url.startswith("http"):
        og_image_url = f"{SITE_URL}{og_image_url}"
    og_page_url = f"{SITE_URL}/photo/{photo_id}"

    og_meta_tags = (
        Meta(property="og:title", content=og_title),
        Meta(property="og:description", content=og_description),
        Meta(property="og:image", content=og_image_url),
        Meta(property="og:url", content=og_page_url),
        Meta(property="og:type", content="article"),
        Meta(property="og:site_name", content="Rhodesli — Heritage Photo Archive"),
        Meta(name="twitter:card", content="summary_large_image"),
        Meta(name="twitter:title", content=og_title),
        Meta(name="twitter:description", content=og_description),
        Meta(name="twitter:image", content=og_image_url),
        Meta(name="description", content=og_description),
    )
    if has_dimensions:
        og_meta_tags = og_meta_tags + (
            Meta(property="og:image:width", content=str(width)),
            Meta(property="og:image:height", content=str(height)),
        )

    # Navigation
    nav_links = _public_nav_links(active="", user=user)

    page_style = Style("""
        html, body { margin: 0; }
        body { background-color: #0f172a; }
        .photo-hero-container {
            position: relative;
            display: inline-block;
            max-width: 100%;
            /* Padding for face overlay name labels that extend beyond photo edges */
            padding-top: 1.5rem;
            overflow: visible;
        }
        .photo-hero-container img.photo-hero {
            max-width: 100%;
            height: auto;
            display: block;
            border-radius: 0.5rem;
        }
        .photo-hero-container .face-overlay-public {
            box-sizing: border-box;
        }
        .photo-hero-container .face-overlay-public:hover {
            z-index: 10;
        }
        .person-strip {
            display: flex;
            gap: 1rem;
            overflow-x: auto;
            padding: 0.5rem 0;
            scrollbar-width: thin;
            scrollbar-color: #475569 transparent;
        }
        .person-strip::-webkit-scrollbar {
            height: 6px;
        }
        .person-strip::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 3px;
        }
        /* CSS 3D Flip Animation — Premium "turning over a real photo" feel */
        .photo-flip-container {
            perspective: 1200px;
            perspective-origin: center center;
        }
        .photo-flip-inner {
            position: relative;
            transition: transform 0.9s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                        box-shadow 0.9s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            transform-style: preserve-3d;
            /* Resting shadow — subtle, like a photo lying on a surface */
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            border-radius: 2px;
        }
        .photo-flip-inner.is-flipped {
            transform: rotateY(180deg) scale(1.02);
            /* Lifted shadow — photo appears to hover while flipping */
            box-shadow: 0 15px 40px rgba(0,0,0,0.35);
        }
        .photo-flip-front {
            backface-visibility: hidden;
            position: relative;
        }
        .photo-flip-back {
            backface-visibility: hidden;
            transform: rotateY(180deg);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Back of a real photo — warm, slightly textured */
            background-color: #f5f0e8;
            background-image:
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(0,0,0,0.008) 2px,
                    rgba(0,0,0,0.008) 3px
                );
            /* Edge shadow suggesting photo thickness */
            box-shadow: inset 0 0 30px rgba(0,0,0,0.06);
            border-radius: 2px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
        }
        .photo-flip-back img {
            border-radius: 2px;
        }
        .photo-flip-inner:not(.is-flipped) .photo-flip-back {
            pointer-events: none;
        }
        .photo-flip-inner.is-flipped .photo-flip-front {
            pointer-events: none;
        }
        /* Face overlays fade out during flip */
        .photo-flip-inner .face-overlay-box {
            transition: opacity 0.3s ease;
        }
        .photo-flip-inner.is-flipped .face-overlay-box {
            opacity: 0;
            pointer-events: none;
        }
    """)

    # Keyboard navigation script for carousel
    keyboard_nav_script = None
    if prev_photo_id or next_photo_id:
        prev_url = f"/photo/{prev_photo_id}" if prev_photo_id else ""
        next_url = f"/photo/{next_photo_id}" if next_photo_id else ""
        keyboard_nav_script = Script(f"""
            document.addEventListener('keydown', function(e) {{
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                if (e.key === 'ArrowLeft' && '{prev_url}') window.location.href = '{prev_url}';
                if (e.key === 'ArrowRight' && '{next_url}') window.location.href = '{next_url}';
            }});
        """)

    return (
        Title(f"{page_title} — Rhodesli Heritage Archive"),
        *og_meta_tags,
        page_style,
        Main(
            # Top navigation bar
            Nav(
                Div(
                    A(Span("Rhodesli", cls="text-xl font-bold text-white"), href="/", cls="hover:opacity-90"),
                    Div(
                        *nav_links,
                        A("Explore More Photos", href="/photos",
                          cls="text-indigo-400 hover:text-indigo-300 text-sm font-medium transition-colors ml-4"),
                        cls="hidden sm:flex items-center gap-6"
                    ),
                    cls="max-w-5xl mx-auto px-6 flex items-center justify-between h-16"
                ),
                cls="bg-slate-900/80 backdrop-blur-md border-b border-slate-800 sticky top-0 z-50"
            ),

            # Hero photo section
            Section(
                Div(
                    # Photo with overlays (with optional flip animation)
                    Div(
                        Div(
                            # Front side
                            Div(
                                Img(
                                    src=photo_url(filename),
                                    alt=f"Historical photograph from {photo.get('collection', 'the Rhodes diaspora')}",
                                    cls="photo-hero max-w-full h-auto rounded-lg",
                                    style=f"transform: {front_css_transform}; filter: {front_css_filter};" if (front_css_transform or front_css_filter) else None,
                                ),
                                *face_overlays,
                                # Overlay legend
                                Div(
                                    Span(cls="inline-block w-2.5 h-2.5 rounded-sm border-2 border-emerald-400 mr-1"),
                                    Span("Identified", cls="text-slate-300 mr-3"),
                                    Span(cls="inline-block w-2.5 h-2.5 rounded-sm border-2 border-dashed border-amber-400 mr-1"),
                                    Span("Unidentified", cls="text-slate-300"),
                                    cls="absolute bottom-3 right-3 bg-black/70 rounded-lg px-3 py-1.5 flex items-center gap-1 text-xs backdrop-blur-sm",
                                ) if face_overlays else None,
                                cls="photo-flip-front relative" if has_back else "relative",
                            ),
                            # Back side (only rendered if back image exists)
                            Div(
                                Img(
                                    src=photo_url(back_image),
                                    alt="Back of photograph",
                                    cls="max-w-full h-auto rounded-lg",
                                    style=f"transform: {back_css_transform}; filter: {back_css_filter};" if (back_css_transform or back_css_filter) else None,
                                ),
                                P("Back of photograph", cls="text-amber-700/60 text-xs text-center mt-2 italic font-serif"),
                                P(
                                    back_transcription,
                                    cls="text-amber-900/80 text-sm mt-3 bg-amber-50/50 rounded-lg p-3 border border-amber-200/30 italic font-serif leading-relaxed"
                                ) if back_transcription else None,
                                cls="photo-flip-back",
                            ) if has_back else None,
                            id="photo-flip-inner",
                            cls="photo-flip-inner" if has_back else "",
                        ),
                        cls="photo-flip-container photo-hero-container relative mx-auto" if has_back else "photo-hero-container relative mx-auto",
                    ),
                    # Photo carousel navigation
                    Div(
                        A(
                            NotStr('<svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7"/></svg>'),
                            href=f"/photo/{prev_photo_id}",
                            cls="p-2 bg-black/60 hover:bg-black/80 text-white rounded-full backdrop-blur-sm transition-colors",
                            title="Previous photo",
                        ) if prev_photo_id else Span(cls="w-9"),
                        Span(
                            f"Photo {nav_position} of {nav_total}",
                            cls="text-xs text-slate-400",
                        ) if nav_total > 1 else None,
                        A(
                            NotStr('<svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"/></svg>'),
                            href=f"/photo/{next_photo_id}",
                            cls="p-2 bg-black/60 hover:bg-black/80 text-white rounded-full backdrop-blur-sm transition-colors",
                            title="Next photo",
                        ) if next_photo_id else Span(cls="w-9"),
                        cls="flex items-center justify-center gap-4 mt-3",
                    ) if nav_total > 1 else None,
                    # Action bar: Share, Download, Flip (if back image)
                    Div(
                        Button(
                            NotStr('<svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4 mr-1.5 inline" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"/></svg>'),
                            "Share This Photo",
                            cls="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 text-white text-sm rounded-lg transition-colors",
                            type="button",
                            data_action="share-photo",
                            id="share-photo-btn",
                            data_share_title=og_title,
                            data_share_text=og_description,
                            data_share_url=og_page_url,
                        ),
                        A(
                            NotStr('<svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4 mr-1.5 inline" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/></svg>'),
                            "Download",
                            href=f"/photo/{photo_id}/download",
                            cls="px-4 py-2 bg-slate-700 hover:bg-slate-600 text-slate-200 text-sm rounded-lg transition-colors inline-flex items-center",
                            download=True,
                        ),
                        # Flip button (only when back image exists)
                        Button(
                            NotStr('<svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4 mr-1.5 inline" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/></svg>'),
                            Span("Turn Over", id="flip-btn-text"),
                            cls="px-4 py-2 bg-slate-700 hover:bg-slate-600 text-slate-200 text-sm rounded-lg transition-colors",
                            type="button",
                            data_action="flip-photo",
                            id="flip-photo-btn",
                        ) if has_back else None,
                        cls="flex flex-wrap items-center justify-center gap-3 mt-4"
                    ),
                    Span(
                        "This photograph has writing on the back" if back_transcription else "Turn over to see the back of this photograph",
                        cls="text-slate-500 text-xs text-center block mt-2"
                    ) if has_back else None,
                    # Admin: Upload back image (only shown to admin when no back image)
                    Div(
                        Div(
                            P("Admin: Add a back image", cls="text-slate-400 text-xs font-medium mb-2"),
                            Form(
                                Input(type="file", name="file", accept=".jpg,.jpeg,.png,.webp",
                                      cls="text-xs text-slate-300 file:mr-2 file:py-1 file:px-3 file:rounded-lg file:border-0 file:text-sm file:bg-slate-600 file:text-white hover:file:bg-slate-500"),
                                Div(
                                    Input(type="text", name="back_transcription", placeholder="Transcribe writing on back (optional)...",
                                          cls="flex-1 bg-slate-800 border border-slate-600 rounded-lg px-3 py-1.5 text-sm text-white placeholder-slate-500"),
                                    Button("Upload", type="submit",
                                           cls="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-500 text-white text-sm rounded-lg"),
                                    cls="flex gap-2 mt-2",
                                ),
                                hx_post=f"/api/photo/{photo_id}/back-image",
                                hx_target="#back-upload-result",
                                hx_swap="innerHTML",
                                hx_encoding="multipart/form-data",
                            ),
                            Div(id="back-upload-result", cls="mt-2"),
                        ),
                        cls="mt-4 bg-slate-800/50 rounded-lg p-3 border border-slate-700/50"
                    ) if is_admin and not has_back else None,
                    # Admin: Update transcription (when back exists but no transcription)
                    Div(
                        Form(
                            Input(type="text", name="back_transcription",
                                  placeholder="Transcribe writing on back...",
                                  value=back_transcription or "",
                                  cls="flex-1 bg-slate-800 border border-slate-600 rounded-lg px-3 py-1.5 text-sm text-white placeholder-slate-500"),
                            Button("Save", type="submit",
                                   cls="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-500 text-white text-sm rounded-lg"),
                            hx_post=f"/api/photo/{photo_id}/back-transcription",
                            hx_target="#transcription-result",
                            hx_swap="innerHTML",
                            cls="flex gap-2",
                        ),
                        Div(id="transcription-result", cls="mt-1"),
                        cls="mt-3 bg-slate-800/50 rounded-lg p-3 border border-slate-700/50"
                    ) if is_admin and has_back else None,
                    # Admin: Image orientation toolbar
                    Div(
                        image_transform_toolbar(photo_id, target="front"),
                        image_transform_toolbar(photo_id, target="back") if has_back else None,
                        Div(id="transform-result", cls="mt-1"),
                        P(f"Current: {front_transform}", cls="text-xs text-slate-500 mt-1") if front_transform else None,
                        cls="mt-3 bg-slate-800/50 rounded-lg p-3 border border-slate-700/50"
                    ) if is_admin else None,
                    # Photo metadata (with inline admin editing)
                    Div(
                        P(meta_line, cls="text-slate-400 text-sm") if meta_line else None,
                        P(uploader_line, cls="mt-1") if uploader_line and not meta_line else None,
                        P(
                            f"{total_faces} {'person' if total_faces == 1 else 'people'} detected · "
                            f"{identified_count} identified",
                            cls="text-slate-500 text-xs mt-1"
                        ),
                        P(
                            A(photo.get("source_url", ""), href=photo.get("source_url", ""),
                              target="_blank", rel="noopener",
                              cls="text-indigo-400/70 hover:text-indigo-300 text-xs underline"),
                            cls="mt-1"
                        ) if photo.get("source_url") else None,
                        # Admin inline edit for collection/source
                        Div(
                            Form(
                                Label("Collection:", cls="text-xs text-slate-500 mr-1"),
                                Input(type="text", name="collection",
                                      value=photo.get("collection", ""),
                                      cls="bg-slate-800 border border-slate-600 rounded px-2 py-0.5 text-xs text-white w-48",
                                      list="photo-collections"),
                                Button("Save", type="submit",
                                       cls="px-2 py-0.5 bg-indigo-600 hover:bg-indigo-500 text-white text-xs rounded ml-1"),
                                Div(id=f"collection-status-{photo_id}", cls="inline ml-1"),
                                hx_post=f"/api/photo/{photo_id}/collection",
                                hx_target=f"#collection-status-{photo_id}",
                                hx_swap="innerHTML",
                                cls="flex items-center gap-1 mb-1",
                            ),
                            Form(
                                Label("Source:", cls="text-xs text-slate-500 mr-1"),
                                Input(type="text", name="source",
                                      value=photo.get("source", ""),
                                      cls="bg-slate-800 border border-slate-600 rounded px-2 py-0.5 text-xs text-white w-48"),
                                Button("Save", type="submit",
                                       cls="px-2 py-0.5 bg-indigo-600 hover:bg-indigo-500 text-white text-xs rounded ml-1"),
                                Div(id=f"source-status-{photo_id}", cls="inline ml-1"),
                                hx_post=f"/api/photo/{photo_id}/source",
                                hx_target=f"#source-status-{photo_id}",
                                hx_swap="innerHTML",
                                cls="flex items-center gap-1 mb-1",
                            ),
                            Form(
                                Label("Source URL:", cls="text-xs text-slate-500 mr-1"),
                                Input(type="text", name="source_url",
                                      value=photo.get("source_url", ""),
                                      cls="bg-slate-800 border border-slate-600 rounded px-2 py-0.5 text-xs text-white w-56"),
                                Button("Save", type="submit",
                                       cls="px-2 py-0.5 bg-indigo-600 hover:bg-indigo-500 text-white text-xs rounded ml-1"),
                                Div(id=f"source-url-status-{photo_id}", cls="inline ml-1"),
                                hx_post=f"/api/photo/{photo_id}/source-url",
                                hx_target=f"#source-url-status-{photo_id}",
                                hx_swap="innerHTML",
                                cls="flex items-center gap-1",
                            ),
                            _photo_collection_datalist(),
                            cls="mt-3 bg-slate-800/50 rounded-lg p-3 border border-slate-700/50",
                            data_testid="photo-inline-edit",
                        ) if is_admin else None,
                        cls="mt-4 text-center"
                    ),
                    cls="max-w-[900px] mx-auto"
                ),
                cls="px-4 sm:px-6 pt-8 pb-6"
            ),

            # People in this photo
            Section(
                Div(
                    H2(
                        f"{'People' if total_faces != 1 else 'Person'} in this photo",
                        cls="text-lg font-serif font-semibold text-white mb-4"
                    ),
                    Div(
                        *person_cards,
                        cls="person-strip"
                    ) if person_cards else P("No faces detected in this photo.", cls="text-slate-500 text-sm"),
                    cls="max-w-[900px] mx-auto"
                ),
                cls="px-4 sm:px-6 py-6 border-t border-slate-800/50"
            ) if face_info_list else None,

            # AI Analysis panel (from date labels + search index)
            _build_ai_analysis_section(photo_id, is_admin),

            # Call to action — link to first unidentified face from this photo
            Section(
                Div(
                    H2(
                        "Do you recognize someone?",
                        cls="text-xl font-serif font-bold text-white mb-3"
                    ),
                    P(
                        "Help us identify the people in this photograph. Your family knowledge could be the key to preserving our shared history.",
                        cls="text-slate-400 leading-relaxed mb-6 max-w-lg mx-auto"
                    ),
                    Div(
                        A(
                            "I Can Help Identify",
                            href=(f"/?section=skipped&current={first_unidentified_id}"
                                  if first_unidentified_id else "/?section=skipped"),
                            cls="inline-block px-6 py-3 bg-indigo-600 text-white font-medium rounded-lg hover:bg-indigo-500 transition-colors"
                        ),
                        A(
                            "Browse All Photos",
                            href="/photos",
                            cls="inline-block px-6 py-3 border border-slate-600 text-slate-300 font-medium rounded-lg hover:border-slate-400 hover:text-white transition-colors"
                        ),
                        cls="flex flex-wrap justify-center gap-4"
                    ),
                    cls="text-center max-w-2xl mx-auto"
                ),
                cls="px-4 sm:px-6 py-12 border-t border-slate-800/50"
            ) if unidentified_count > 0 else None,

            # Footer
            Footer(
                Div(
                    P(
                        Span("Rhodesli", cls="font-bold text-white"),
                        " — Preserving the visual heritage of the Jews of Rhodes",
                        cls="text-slate-500 text-sm"
                    ),
                    Div(
                        A("Home", href="/", cls="text-xs text-slate-500 hover:text-slate-300"),
                        Span("·", cls="text-slate-700"),
                        A("Photos", href="/photos", cls="text-xs text-slate-500 hover:text-slate-300"),
                        Span("·", cls="text-slate-700"),
                        A("People", href="/people", cls="text-xs text-slate-500 hover:text-slate-300"),
                        cls="flex items-center gap-2"
                    ),
                    cls="max-w-5xl mx-auto px-6 flex flex-col sm:flex-row items-center justify-between gap-3"
                ),
                cls="py-8 border-t border-slate-800"
            ),
            # Action button event handlers (standalone page — uses reusable _share_script + flip JS)
            _share_script(),
            Script("""
                document.addEventListener('click', function(e) {
                    var flipBtn = e.target.closest('[data-action="flip-photo"]');
                    if (flipBtn) {
                        var inner = document.getElementById('photo-flip-inner');
                        if (!inner) return;
                        inner.classList.toggle('is-flipped');
                        var textEl = document.getElementById('flip-btn-text');
                        if (textEl) {
                            textEl.textContent = inner.classList.contains('is-flipped') ? 'View Front' : 'Turn Over';
                        }
                        return;
                    }
                });
            """),
            cls="min-h-screen bg-slate-900"
        ),
        keyboard_nav_script,
    )


@rt("/photo/{photo_id}")
def get(photo_id: str, face: str = None, sess=None):
    """
    Public shareable photo page with face overlays and person cards.

    This is the page people share on Facebook, WhatsApp, email, etc.
    No authentication required — anyone can view.

    Query params:
    - face: Optional face_id to highlight
    """
    user = get_current_user(sess or {}) if is_auth_enabled() else None
    user_is_admin = (user.is_admin if user else False) if is_auth_enabled() else True
    return public_photo_page(photo_id, selected_face_id=face, user=user, is_admin=user_is_admin)


@rt("/photo/{photo_id}/partial")
def get(photo_id: str, face: str = None, prev_id: str = None, next_id: str = None,
        nav_idx: int = -1, nav_total: int = 0, identity_id: str = None,
        from_compare: bool = False, sess=None):
    """
    Render photo view partial for HTMX modal injection.

    Optional navigation context:
    - prev_id/next_id: Adjacent photo IDs for prev/next buttons
    - nav_idx/nav_total: Current position for "X of Y" display
    - identity_id: Identity context for computing prev/next from identity's photos
    - from_compare: If True, show "Back to Compare" button (opened via compare modal)
    """
    user_is_admin = (get_current_user(sess or {}).is_admin if get_current_user(sess or {}) else False) if is_auth_enabled() else True
    return photo_view_content(
        photo_id, selected_face_id=face, is_partial=True,
        prev_id=prev_id, next_id=next_id,
        nav_idx=nav_idx, nav_total=nav_total,
        identity_id=identity_id,
        is_admin=user_is_admin,
        from_compare=from_compare,
    )


@rt("/photo/{photo_id}/download")
def get(photo_id: str):
    """
    Download the original full-resolution photo.

    Public endpoint — no auth required.
    Returns the photo file with Content-Disposition: attachment header.
    """
    photo = get_photo_metadata(photo_id)
    if not photo:
        return Response("Photo not found", status_code=404)

    filename = photo["filename"]
    basename = Path(filename).name

    # In R2 mode, redirect to the R2 URL (can't serve local file)
    if storage.is_r2_mode():
        download_url = photo_url(filename)
        return Response(
            status_code=302,
            headers={"Location": download_url}
        )

    # Local mode: serve from filesystem
    photo_path = photos_path / basename
    if not photo_path.exists():
        return Response("Photo file not found", status_code=404)

    return FileResponse(
        str(photo_path),
        filename=basename,
        headers={"Content-Disposition": f'attachment; filename="{basename}"'},
    )


# =============================================================================
# ROUTES - PHASE 3: DISCOVERY & ACTION
# =============================================================================

@rt("/api/identity/{identity_id}/neighbors")
def get(identity_id: str, limit: int = 5, offset: int = 0, from_focus: bool = False, focus_section: str = "", sess=None):
    """
    Get nearest neighbor identities for potential merge.

    Args:
        identity_id: Identity to find neighbors for
        limit: Number of neighbors per page (default 5)
        offset: Number of neighbors already shown (for Load More)

    Returns HTML partial with neighbor cards and merge buttons.
    Implements D3 (Load More pagination).
    """
    try:
        registry = load_registry()
        registry.get_identity(identity_id)
    except KeyError:
        return Div(
            P("Identity not found.", cls="text-red-600 text-center py-4"),
            cls="neighbors-sidebar"
        )

    # Load required data
    face_data = get_face_data()
    photo_registry = load_photo_registry()

    # Request one extra to determine if more exist (B3: pagination)
    try:
        from core.neighbors import find_nearest_neighbors
        total_to_fetch = offset + limit + 1
        all_neighbors = find_nearest_neighbors(
            identity_id, registry, photo_registry, face_data, limit=total_to_fetch
        )
    except ImportError as e:
        print(f"[neighbors] Missing dependency: {e}")
        return Div(
            P("Find Similar requires scipy. Check server dependencies.", cls="text-amber-500 text-center py-4"),
            cls="neighbors-sidebar"
        )
    except Exception as e:
        print(f"[neighbors] Error computing neighbors: {e}")
        return Div(
            P("Could not compute similar identities.", cls="text-red-500 text-center py-4"),
            cls="neighbors-sidebar"
        )

    # Determine if more neighbors exist beyond current page
    has_more = len(all_neighbors) > offset + limit

    # Return only neighbors up to current offset + limit
    neighbors = all_neighbors[:offset + limit]

    # Enhance neighbor data with additional info for UI
    crop_files = get_crop_files()
    for n in neighbors:
        # Add face IDs for thumbnail resolution (B2-REPAIR)
        # First try anchors, then fallback to candidates for PROPOSED identities
        n["anchor_face_ids"] = registry.get_anchor_face_ids(n["identity_id"])
        n["candidate_face_ids"] = registry.get_candidate_face_ids(n["identity_id"])
        # Add state for correct section routing in neighbor_card links
        try:
            n_identity = registry.get_identity(n["identity_id"])
            n["state"] = n_identity.get("state", "INBOX")
        except KeyError:
            n["state"] = "INBOX"

        # Compute co-occurrence: how many photos these two identities share
        n["co_occurrence"] = _compute_co_occurrence(
            identity_id, n["identity_id"], registry, photo_registry
        )

        # Enhance blocked merge reason with photo filename
        if not n["can_merge"] and n["merge_blocked_reason"] == "co_occurrence":
            filename = find_shared_photo_filename(
                identity_id, n["identity_id"], registry, photo_registry
            )
            if filename:
                n["merge_blocked_reason_display"] = f"Appear together in {filename}"
            else:
                n["merge_blocked_reason_display"] = "Appear together in a photo"

    # Count rejected identities for contextual recovery indicator
    identity = registry.get_identity(identity_id)
    rejected_count = sum(
        1 for neg in identity.get("negative_ids", [])
        if neg.startswith("identity:")
    )

    return neighbors_sidebar(
        identity_id, neighbors, crop_files,
        offset=offset + limit,  # Next offset for Load More
        has_more=has_more,
        rejected_count=rejected_count,
        user_role=_get_user_role(sess),
        from_focus=from_focus,
        focus_section=focus_section,
    )


@rt("/api/identity/{identity_id}/neighbors/close")
def get(identity_id: str):
    """
    Close the neighbors sidebar (B1: explicit exit from Find Similar mode).

    Returns empty content to clear the sidebar.
    """
    return Div(
        # Return just the loading indicator (hidden by default)
        Span(
            "Loading...",
            id=f"neighbors-loading-{identity_id}",
            cls="htmx-indicator text-slate-400 text-sm",
        ),
    )


@rt("/api/identity/{identity_id}/skip-hints")
def get(identity_id: str):
    """
    Lazy-loaded ML hints for skipped identities.

    Shows top 3 similar confirmed/named identities to help re-evaluate.
    """
    try:
        registry = load_registry()
        registry.get_identity(identity_id)
    except KeyError:
        return Span()

    face_data = get_face_data()
    photo_registry = load_photo_registry()

    try:
        from core.neighbors import find_nearest_neighbors
        # Fetch up to 5 candidates, then trim based on confidence
        neighbors = find_nearest_neighbors(
            identity_id, registry, photo_registry, face_data, limit=5
        )
    except Exception:
        return Span()

    if not neighbors:
        return Span("No similar identities found.", cls="text-xs text-slate-500 italic")

    # Variable suggestion count: show more when top match is confident,
    # fewer when uncertain. If best match is strong, show up to 3;
    # if weak, show only 1 to avoid decision fatigue.
    best_dist = neighbors[0]["distance"] if neighbors else float("inf")
    if best_dist < MATCH_THRESHOLD_HIGH:
        max_show = 3  # Strong match — show alternatives for comparison
    elif best_dist < MATCH_THRESHOLD_LOW:
        max_show = 2  # Moderate — show a couple
    else:
        max_show = 1  # Weak — just show the best guess
    neighbors = neighbors[:max_show]

    # Enrich neighbor data with face IDs for thumbnail resolution
    # (find_nearest_neighbors returns raw results without face IDs)
    for n in neighbors:
        n["anchor_face_ids"] = registry.get_anchor_face_ids(n["identity_id"])
        n["candidate_face_ids"] = registry.get_candidate_face_ids(n["identity_id"])

    # Map distance to confidence tier for visual display
    # Uses config constants for consistency with neighbor_card (AD-013)
    def _confidence_tier(dist):
        if dist < MATCH_THRESHOLD_VERY_HIGH:
            return ("Very High", "bg-emerald-500", 5)
        elif dist < MATCH_THRESHOLD_HIGH:
            return ("High", "bg-green-500", 4)
        elif dist < MATCH_THRESHOLD_MODERATE:
            return ("Moderate", "bg-amber-500", 3)
        elif dist < MATCH_THRESHOLD_LOW:
            return ("Low", "bg-orange-500", 2)
        else:
            return ("Very Low", "bg-red-500", 1)

    # Build suggestion cards with visual confidence and action buttons
    crop_files = get_crop_files()
    suggestion_items = []
    for n in neighbors:
        name = ensure_utf8_display(n.get("name", "Unknown"))
        dist = n.get("distance", 0)
        neighbor_id = n.get("identity_id", "")
        tier_label, tier_color, tier_dots = _confidence_tier(dist)

        # Face thumbnail — use enriched anchor/candidate face IDs (same pattern as neighbor_card)
        thumb = Div(cls="w-10 h-10 rounded-full bg-slate-600 flex-shrink-0")
        all_face_ids = n.get("anchor_face_ids", []) + n.get("candidate_face_ids", [])
        for fid in all_face_ids:
            face_url = resolve_face_image_url(fid, crop_files)
            if face_url:
                thumb = Img(src=face_url, cls="w-10 h-10 rounded-full object-cover flex-shrink-0 border border-slate-600")
                break

        # Confidence dots (filled vs empty)
        dots = Span(
            *[Span(cls=f"inline-block w-1.5 h-1.5 rounded-full {'bg-current' if i < tier_dots else 'bg-slate-600'}")
              for i in range(5)],
            cls=f"flex gap-0.5 items-center {tier_color.replace('bg-', 'text-')}",
        )

        # State badge for named vs unidentified
        is_named = not name.startswith("Unidentified Person")
        name_cls = "text-sm text-white font-medium truncate" if is_named else "text-sm text-slate-300 truncate"

        # Action buttons
        compare_btn = Button(
            "Compare",
            cls="text-[10px] px-2 py-0.5 bg-slate-600 hover:bg-slate-500 text-slate-300 rounded transition-colors",
            hx_get=f"/api/identity/{identity_id}/compare/{neighbor_id}",
            hx_target="#compare-modal-content",
            hx_swap="innerHTML",
            type="button",
            **{"_": "on click remove .hidden from #compare-modal"},
        )
        merge_btn = Button(
            "Merge",
            cls="text-[10px] px-2 py-0.5 bg-indigo-600 hover:bg-indigo-500 text-white rounded transition-colors",
            hx_post=f"/api/identity/{neighbor_id}/merge/{identity_id}",
            hx_target="#focus-container",
            hx_swap="outerHTML",
            type="button",
        ) if tier_dots >= 3 else None  # Only show merge for Moderate+ confidence

        suggestion_items.append(Div(
            thumb,
            Div(
                Span(name, cls=name_cls),
                Div(dots, Span(tier_label, cls=f"text-[10px] {tier_color.replace('bg-', 'text-')}"), cls="flex items-center gap-1.5"),
                cls="flex-1 min-w-0 flex flex-col",
            ),
            Div(compare_btn, merge_btn, cls="flex gap-1 flex-shrink-0"),
            cls="flex items-center gap-2 p-2 rounded hover:bg-slate-700/50 transition-colors",
        ))

    return Div(
        Div(
            Span("AI suggestions", cls="text-xs text-slate-400 font-medium"),
            cls="mb-1",
        ),
        *suggestion_items,
        cls="mt-2 bg-slate-800/50 rounded-lg border border-slate-700/50 p-1",
    )


@rt("/api/identity/{identity_id}/search")
def get(identity_id: str, q: str = "", sess=None):
    """
    Search for identities by name for manual merge.

    Phase 3B: Manual Search & Human-Authorized Merge Tools

    Args:
        identity_id: Current identity (excluded from results)
        q: Search query (minimum 2 characters)

    Returns HTMX partial with search result cards.
    """
    # Minimum query length
    if len(q.strip()) < 2:
        return Div(id=f"search-results-{identity_id}")

    try:
        registry = load_registry()
    except Exception:
        return Div(
            P("Search unavailable.", cls="text-slate-400 italic text-sm"),
            id=f"search-results-{identity_id}"
        )

    # Search for matching identities
    results = registry.search_identities(q, exclude_id=identity_id)

    crop_files = get_crop_files()
    return search_results_panel(results, identity_id, crop_files, user_role=_get_user_role(sess))


@rt("/api/search")
def get(q: str = ""):
    """
    Global search for identities by name. Used by the sidebar search input.

    Args:
        q: Search query (minimum 2 characters, case-insensitive partial match)

    Returns HTMX partial with matching identity results (limit 10).
    Each result links to the correct section based on identity state.
    """
    if len(q.strip()) < 2:
        return ""

    try:
        registry = load_registry()
    except Exception:
        return Div(
            P("Search unavailable.", cls="text-slate-400 italic text-sm p-2"),
        )

    # Search all non-merged identities by name
    results = registry.search_identities(q)
    if not results:
        return Div(
            P("No matches found.", cls="text-slate-400 italic text-sm p-3"),
        )

    crop_files = get_crop_files()
    items = []
    query_stripped = q.strip()
    for r in results[:10]:
        face_url = resolve_face_image_url(r["preview_face_id"], crop_files) if r.get("preview_face_id") else None
        thumb = Img(src=face_url, cls="w-8 h-8 rounded-full object-cover flex-shrink-0") if face_url else Div(cls="w-8 h-8 rounded-full bg-slate-600 flex-shrink-0")
        name = ensure_utf8_display(r["name"]) or "Unnamed"

        # Highlight matched portion in name (case-insensitive)
        name_display = _highlight_match(name, query_stripped)

        # Route to correct section based on identity state
        section = _section_for_state(r.get("state", "INBOX"))

        # State badge for non-confirmed results
        state = r.get("state", "INBOX")
        state_indicator = None
        if state != "CONFIRMED":
            state_colors = {
                "PROPOSED": "bg-indigo-500/20 text-indigo-300",
                "INBOX": "bg-slate-500/20 text-slate-300",
                "SKIPPED": "bg-amber-500/20 text-amber-300",
            }
            badge_cls = state_colors.get(state, "bg-slate-500/20 text-slate-300")
            state_label = "Help Identify" if state == "SKIPPED" else state.title()
            state_indicator = Span(state_label, cls=f"text-[10px] px-1.5 py-0.5 rounded {badge_cls}")

        # Navigate to the right page based on state
        if state == "CONFIRMED" and not name.startswith("Unidentified"):
            result_href = f"/person/{r['identity_id']}"
        else:
            result_href = f"/identify/{r['identity_id']}"

        items.append(
            A(
                thumb,
                Div(
                    Div(
                        Span(name_display, cls="text-sm text-slate-200 truncate"),
                        state_indicator,
                        cls="flex items-center gap-1.5"
                    ),
                    Span(f"{r['face_count']} {'face' if r['face_count'] == 1 else 'faces'}", cls="text-xs text-slate-500"),
                    cls="flex flex-col min-w-0"
                ),
                href=result_href,
                cls="flex items-center gap-2 px-3 py-2 hover:bg-slate-700 transition-colors cursor-pointer"
            )
        )
    return Div(*items)


@rt("/api/face/tag-search")
def get(face_id: str, q: str = "", sess=None):
    """
    Search for identities to tag a face with (Instagram-style tagging).

    Admin: returns merge buttons (direct action).
    Non-admin: returns suggestion buttons (creates annotation for review).
    """
    import json as _json
    from urllib.parse import quote as _url_quote
    safe_face_id = face_id.replace(":", "-").replace(" ", "_")
    face_id_encoded = _url_quote(face_id, safe="")
    results_id = f"tag-results-{safe_face_id}"

    if len(q.strip()) < 2:
        return Div(id=results_id)

    try:
        registry = load_registry()
    except Exception:
        return Div(
            P("Search unavailable.", cls="text-slate-400 italic text-xs"),
            id=results_id
        )

    # Determine user role for rendering appropriate action buttons
    user_is_admin = False
    if not is_auth_enabled():
        user_is_admin = True
    else:
        user = get_current_user(sess or {})
        if user and user.is_admin:
            user_is_admin = True

    # Find the identity this face belongs to (to exclude from results)
    source_identity = get_identity_for_face(registry, face_id)
    exclude_id = source_identity["identity_id"] if source_identity else None
    source_identity_id = source_identity["identity_id"] if source_identity else ""

    # Search all identities (confirmed get priority in search_identities)
    results = registry.search_identities(q, exclude_id=exclude_id)

    crop_files = get_crop_files()
    items = []
    for r in results[:8]:
        face_url = resolve_face_image_url(r["preview_face_id"], crop_files) if r.get("preview_face_id") else None
        thumb = Img(src=face_url, cls="w-8 h-8 rounded-full object-cover flex-shrink-0") if face_url else Div(cls="w-8 h-8 rounded-full bg-slate-600 flex-shrink-0")
        name = ensure_utf8_display(r["name"]) or "Unnamed"

        if user_is_admin:
            # Admin: direct merge
            btn = Button(
                thumb,
                Div(
                    Span(name, cls="text-sm text-slate-200 truncate"),
                    Span(f"{r['face_count']} faces", cls="text-xs text-slate-500"),
                    cls="flex flex-col min-w-0 text-left"
                ),
                cls="flex items-center gap-2 w-full px-2 py-1.5 hover:bg-slate-700 rounded transition-colors cursor-pointer",
                hx_post=f"/api/face/tag?face_id={face_id_encoded}&target_id={r['identity_id']}",
                hx_target="#photo-modal-content",
                hx_swap="innerHTML",
                type="button",
            )
        else:
            # Non-admin: submit name suggestion annotation
            btn = Button(
                thumb,
                Div(
                    Span(name, cls="text-sm text-slate-200 truncate"),
                    Span("Suggest match", cls="text-xs text-indigo-400"),
                    cls="flex flex-col min-w-0 text-left"
                ),
                cls="flex items-center gap-2 w-full px-2 py-1.5 hover:bg-slate-700 rounded transition-colors cursor-pointer",
                hx_post="/api/annotations/submit",
                hx_vals=_json.dumps({
                    "target_type": "identity",
                    "target_id": source_identity_id,
                    "annotation_type": "name_suggestion",
                    "value": name,
                    "confidence": "likely",
                    "reason": f"face_tag:{face_id}:matched_to:{r['identity_id']}",
                }),
                hx_target="#toast-container",
                hx_swap="beforeend",
                type="button",
            )
        items.append(btn)

    # Bottom option: create new identity (admin) or suggest new name (non-admin)
    from urllib.parse import quote as _url_quote
    if user_is_admin:
        create_btn = Button(
            Div("+", cls="w-8 h-8 rounded-full bg-indigo-600 flex-shrink-0 flex items-center justify-center text-white font-bold text-lg"),
            Div(
                Span(f'Create "{q.strip()}"', cls="text-sm text-indigo-300 truncate"),
                Span("New identity", cls="text-xs text-slate-500"),
                cls="flex flex-col min-w-0 text-left"
            ),
            cls="flex items-center gap-2 w-full px-2 py-1.5 hover:bg-slate-700 rounded transition-colors cursor-pointer "
                "border-t border-slate-700 mt-1 pt-1",
            hx_post=f"/api/face/create-identity?face_id={face_id_encoded}&name={_url_quote(q.strip())}",
            hx_target="#photo-modal-content",
            hx_swap="innerHTML",
            type="button",
        )
    else:
        create_btn = Button(
            Div("+", cls="w-8 h-8 rounded-full bg-indigo-600 flex-shrink-0 flex items-center justify-center text-white font-bold text-lg"),
            Div(
                Span(f'Suggest "{q.strip()}"', cls="text-sm text-indigo-300 truncate"),
                Span("Submit for review", cls="text-xs text-slate-500"),
                cls="flex flex-col min-w-0 text-left"
            ),
            cls="flex items-center gap-2 w-full px-2 py-1.5 hover:bg-slate-700 rounded transition-colors cursor-pointer "
                "border-t border-slate-700 mt-1 pt-1",
            hx_post="/api/annotations/submit",
            hx_vals=_json.dumps({
                "target_type": "identity",
                "target_id": source_identity_id,
                "annotation_type": "name_suggestion",
                "value": q.strip(),
                "confidence": "likely",
                "reason": f"face_tag:{face_id}:new_name",
            }),
            hx_target=f"#tag-results-{safe_face_id}",
            hx_swap="innerHTML",
            type="button",
        )
    items.append(create_btn)

    if not results:
        # Show only the create/suggest button with a "no matches" message
        return Div(
            P("No existing matches.", cls="text-slate-500 italic text-xs p-1"),
            create_btn,
            id=results_id,
        )

    return Div(*items, id=results_id)


@rt("/api/face/tag")
def post(face_id: str, target_id: str, sess=None):
    """
    Tag a face with an identity by merging the face's current identity into target.

    This is the one-click merge for Instagram-style face tagging.
    Returns the updated photo view with a success toast.
    """
    denied = _check_admin(sess)
    if denied:
        return denied

    try:
        registry = load_registry()
        photo_registry = load_photo_registry()
    except Exception:
        return Response(
            to_xml(toast("System busy. Please try again.", "warning")),
            status_code=423,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # Find the source identity (the one the face currently belongs to)
    source_identity = get_identity_for_face(registry, face_id)
    if not source_identity:
        return Response(
            to_xml(toast("Face not found in any identity.", "error")),
            status_code=404,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    source_id = source_identity["identity_id"]
    if source_id == target_id:
        return Response(
            to_xml(toast("Face already belongs to this identity.", "info")),
            status_code=200,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # Get target name for toast
    try:
        target = registry.get_identity(target_id)
        target_name = ensure_utf8_display(target.get("name")) or f"Identity {target_id[:8]}..."
    except KeyError:
        target_name = f"Identity {target_id[:8]}..."

    # Merge
    result = registry.merge_identities(
        source_id=source_id,
        target_id=target_id,
        user_source="face_tag",
        photo_registry=photo_registry,
    )

    if result["success"]:
        save_registry(registry)

        # Find the photo this face is in to re-render the photo view
        photo_id = get_photo_id_for_face(face_id)
        if photo_id:
            # Re-render the photo view to reflect the merge
            photo_content = photo_view_content(photo_id, selected_face_id=face_id, is_partial=True, is_admin=True)
            oob_toast = Div(
                toast(f"Tagged as {target_name}!", "success"),
                hx_swap_oob="beforeend:#toast-container",
            )
            return (*photo_content, oob_toast)
        else:
            return toast(f"Tagged as {target_name}!", "success")
    else:
        return Response(
            to_xml(toast(f"Cannot tag: {result['reason']}", "warning")),
            status_code=200,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )


@rt("/api/face/quick-action")
def post(identity_id: str, action: str, photo_id: str, sess=None):
    """
    Quick inline action on a face overlay: confirm, skip, or reject.

    Returns a refreshed photo view with updated overlay colors.
    Admin-only.
    """
    denied = _check_admin(sess)
    if denied:
        return denied

    if action not in ("confirm", "skip", "reject"):
        return Response("Invalid action. Must be confirm, skip, or reject.", status_code=400)

    try:
        registry = load_registry()
    except Exception:
        return Response(
            to_xml(toast("System busy. Please try again.", "warning")),
            status_code=423,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    try:
        identity = registry.get_identity(identity_id)
    except KeyError:
        return Response(
            to_xml(toast("Identity not found.", "error")),
            status_code=404,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    state = identity.get("state", "INBOX")
    action_name = action.capitalize()

    try:
        if action == "confirm":
            registry.confirm_identity(identity_id, user_source="quick_action")
        elif action == "skip":
            registry.skip_identity(identity_id, user_source="quick_action")
        elif action == "reject":
            registry.contest_identity(identity_id, user_source="quick_action", reason="Rejected via quick action")
        save_registry(registry)
    except (ValueError, Exception) as e:
        return Response(
            to_xml(toast(f"Cannot {action}: {str(e)}", "error")),
            status_code=409,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # Re-render the photo view with updated overlay colors
    photo_content = photo_view_content(photo_id, is_partial=True, is_admin=True)
    oob_toast = Div(
        toast(f"{action_name}ed identity!", "success"),
        hx_swap_oob="beforeend:#toast-container",
    )
    return (*photo_content, oob_toast)


@rt("/api/face/create-identity")
def post(face_id: str, name: str, sess=None):
    """
    Create a named identity for a face by renaming its current identity.

    Used from the tag dropdown "+ Create" button. Renames the face's current
    identity (typically an INBOX singleton) to the user-provided name.
    """
    denied = _check_admin(sess)
    if denied:
        return denied

    name = name.strip()
    if not name:
        return Response(
            to_xml(toast("Name cannot be empty.", "warning")),
            status_code=400,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    try:
        registry = load_registry()
    except Exception:
        return Response(
            to_xml(toast("System busy. Please try again.", "warning")),
            status_code=423,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    source_identity = get_identity_for_face(registry, face_id)
    if not source_identity:
        return Response(
            to_xml(toast("Face not found in any identity.", "error")),
            status_code=404,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    identity_id = source_identity["identity_id"]
    registry.rename_identity(identity_id, name)
    # Auto-confirm when naming from tag dropdown (tagging = "this IS that person")
    current_state = source_identity.get("state", "INBOX")
    if current_state in ("INBOX", "PROPOSED", "SKIPPED"):
        try:
            registry.confirm_identity(identity_id, user_source="face_tag")
        except Exception:
            pass  # Already confirmed, or other benign error
    save_registry(registry)

    # Re-render the photo view to show the new name
    photo_id = get_photo_id_for_face(face_id)
    if photo_id:
        photo_content = photo_view_content(photo_id, selected_face_id=face_id, is_partial=True, is_admin=True)
        oob_toast = Div(
            toast(f'Named as "{name}"!', "success"),
            hx_swap_oob="beforeend:#toast-container",
        )
        return (*photo_content, oob_toast)
    else:
        return toast(f'Named as "{name}"!', "success")


@rt("/api/identity/{identity_id}/rejected")
def get(identity_id: str):
    """
    Get list of rejected identities for contextual recovery.

    Returns a lightweight list within the sidebar showing blocked identities
    with thumbnail, name, and Unblock button.
    """
    try:
        registry = load_registry()
        identity = registry.get_identity(identity_id)
    except KeyError:
        return Div(
            P("Identity not found.", cls="text-red-600 text-sm"),
        )

    # Extract rejected identity IDs
    rejected_ids = [
        neg.replace("identity:", "")
        for neg in identity.get("negative_ids", [])
        if neg.startswith("identity:")
    ]

    if not rejected_ids:
        return Div(
            P("No hidden matches.", cls="text-slate-400 text-xs italic"),
        )

    crop_files = get_crop_files()
    items = []

    for rejected_id in rejected_ids:
        try:
            rejected_identity = registry.get_identity(rejected_id)
        except KeyError:
            continue

        # UI BOUNDARY: sanitize name for safe rendering
        raw_name = ensure_utf8_display(rejected_identity.get("name"))
        name = raw_name or f"Identity {rejected_id[:8]}..."

        # Resolve thumbnail using anchor faces, then candidates
        thumbnail_img = None
        anchor_face_ids = registry.get_anchor_face_ids(rejected_id)
        for face_id in anchor_face_ids:
            crop_url = resolve_face_image_url(face_id, crop_files)
            if crop_url:
                thumbnail_img = Img(
                    src=crop_url,
                    alt=name,
                    cls="w-8 h-8 object-cover rounded border border-slate-600"
                )
                break

        if thumbnail_img is None:
            candidate_face_ids = registry.get_candidate_face_ids(rejected_id)
            for face_id in candidate_face_ids:
                crop_url = resolve_face_image_url(face_id, crop_files)
                if crop_url:
                    thumbnail_img = Img(
                        src=crop_url,
                        alt=name,
                        cls="w-8 h-8 object-cover rounded border border-slate-600"
                    )
                    break

        if thumbnail_img is None:
            thumbnail_img = Div(cls="w-8 h-8 bg-slate-600 rounded")

        unblock_btn = Button(
            "Unblock",
            cls="px-2 py-0.5 text-xs text-indigo-400 hover:text-indigo-300 border border-indigo-500/50 rounded hover:bg-indigo-500/20",
            hx_post=f"/api/identity/{identity_id}/unreject/{rejected_id}",
            hx_target=f"#rejected-item-{rejected_id}",
            hx_swap="outerHTML",
            type="button",
        )

        items.append(
            Div(
                thumbnail_img,
                Span(name, cls="text-xs text-slate-300 truncate flex-1 mx-2"),
                unblock_btn,
                id=f"rejected-item-{rejected_id}",
                cls="flex items-center py-1.5 border-b border-slate-700 last:border-0",
            )
        )

    close_list_btn = Button(
        "Hide",
        cls="text-xs text-slate-400 hover:text-slate-300",
        hx_get=f"/api/identity/{identity_id}/rejected/close",
        hx_target=f"#rejected-list-{identity_id}",
        hx_swap="innerHTML",
        type="button",
    )

    return Div(
        Div(
            Span("Hidden Matches", cls="text-xs font-medium text-slate-400"),
            close_list_btn,
            cls="flex items-center justify-between mb-2",
        ),
        Div(*items),
        cls="mt-2 bg-slate-700 rounded border border-slate-600 p-2",
    )


@rt("/api/identity/{identity_id}/rejected/close")
def get(identity_id: str):
    """Close the rejected identities list."""
    return ""


@rt("/api/identity/{source_id}/reject/{target_id}")
def post(source_id: str, target_id: str, sess=None):
    """
    Record that two identities are NOT the same person (D2, D4). Requires admin.
    """
    denied = _check_admin(sess)
    if denied:
        return denied
    try:
        registry = load_registry()
    except Exception:
        return Response(
            to_xml(toast("System busy. Please try again.", "warning")),
            status_code=423,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # Validate both identities exist
    try:
        registry.get_identity(source_id)
        registry.get_identity(target_id)
    except KeyError:
        return Response(
            to_xml(toast("Identity not found.", "error")),
            status_code=404,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # Record rejection
    registry.reject_identity_pair(source_id, target_id, user_source="web")
    save_registry(registry)

    # Log the action
    log_user_action(
        "REJECT_IDENTITY",
        source_identity_id=source_id,
        target_identity_id=target_id,
    )

    # Return empty div to replace the neighbor card + toast with undo (D5)
    # The neighbor card will be removed via hx-swap="outerHTML"
    return (
        Div(),  # Empty replacement - card disappears
        toast_with_undo("Marked as 'Not Same Person'", source_id, target_id, "info"),
    )


@rt("/api/identity/{source_id}/unreject/{target_id}")
def post(source_id: str, target_id: str, sess=None):
    """Undo "Not Same Person" rejection (D5). Requires admin."""
    denied = _check_admin(sess)
    if denied:
        return denied
    try:
        registry = load_registry()
    except Exception:
        return Response(
            to_xml(toast("System busy. Please try again.", "warning")),
            status_code=423,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # Validate both identities exist
    try:
        registry.get_identity(source_id)
        registry.get_identity(target_id)
    except KeyError:
        return Response(
            to_xml(toast("Identity not found.", "error")),
            status_code=404,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # Remove rejection
    registry.unreject_identity_pair(source_id, target_id, user_source="web")
    save_registry(registry)

    # Log the action
    log_user_action(
        "UNREJECT_IDENTITY",
        source_identity_id=source_id,
        target_identity_id=target_id,
    )

    # Return empty div to replace target + OOB toast
    # This handles both: undo from toast (replaces toast) and unblock from list (removes item)
    oob_toast = Div(
        toast("Rejection undone. Identity will reappear in Find Similar.", "success"),
        hx_swap_oob="beforeend:#toast-container",
    )
    return (Div(), oob_toast)


def _name_conflict_modal(target_id: str, source_id: str, details: dict, merge_source: str) -> Div:
    """Render a name conflict resolution modal for two-named merges."""
    a = details["identity_a"]
    b = details["identity_b"]
    return Div(
        Div(cls="absolute inset-0 bg-black/80",
            **{"_": "on click remove closest .fixed"}),
        Div(
            H3("Name Conflict", cls="text-lg font-bold text-white mb-4"),
            P("Both identities have names. Choose which name to keep:",
              cls="text-slate-300 mb-4 text-sm"),
            Form(
                Input(type="hidden", name="source", value=merge_source),
                Div(
                    Label(
                        Input(type="radio", name="resolved_name", value=a["name"],
                              cls="mr-2", checked=True),
                        Span(a["name"], cls="font-semibold text-white"),
                        Span(f" ({a['face_count']} faces, {a['state']})",
                             cls="text-slate-400 text-sm"),
                        cls="flex items-center cursor-pointer hover:bg-slate-700 p-2 rounded",
                    ),
                    cls="mb-2",
                ),
                Div(
                    Label(
                        Input(type="radio", name="resolved_name", value=b["name"],
                              cls="mr-2"),
                        Span(b["name"], cls="font-semibold text-white"),
                        Span(f" ({b['face_count']} faces, {b['state']})",
                             cls="text-slate-400 text-sm"),
                        cls="flex items-center cursor-pointer hover:bg-slate-700 p-2 rounded",
                    ),
                    cls="mb-2",
                ),
                Div(
                    Label(
                        Input(type="radio", name="resolved_name", value="__custom__",
                              cls="mr-2",
                              **{"_": "on change show #custom-name-input"}),
                        Span("Custom name", cls="text-slate-300"),
                        cls="flex items-center cursor-pointer hover:bg-slate-700 p-2 rounded",
                    ),
                    Input(type="text", name="custom_name", id="custom-name-input",
                          placeholder="Enter custom name...",
                          cls="hidden mt-2 w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-white text-sm"),
                    cls="mb-4",
                ),
                Div(
                    Button("Cancel", type="button",
                           cls="px-4 py-2 text-sm text-slate-400 hover:text-white",
                           **{"_": "on click remove closest .fixed"}),
                    Button("Merge", type="submit",
                           cls="px-4 py-2 text-sm font-bold bg-blue-600 text-white rounded hover:bg-blue-500"),
                    cls="flex justify-end gap-3",
                ),
                hx_post=f"/api/identity/{target_id}/merge/{source_id}",
                hx_target=f"#identity-{target_id}",
                hx_swap="outerHTML",
            ),
            cls="bg-slate-800 rounded-lg shadow-2xl w-full max-w-md p-6 relative border border-slate-700",
        ),
        cls="fixed inset-0 flex items-center justify-center p-4 z-[9999]",
    )


def toast_with_merge_undo(message: str, target_id: str) -> Div:
    """Toast notification with Undo button for merge actions."""
    return Div(
        Span("\u2713", cls="mr-2"),
        Span(message, cls="flex-1"),
        Button(
            "Undo",
            cls="ml-3 px-2 py-1 text-xs font-bold bg-white/20 hover:bg-white/30 rounded transition-colors",
            hx_post=f"/api/identity/{target_id}/undo-merge",
            hx_swap="outerHTML",
            hx_target="closest div",
            type="button",
        ),
        cls="px-4 py-3 rounded shadow-lg flex items-center bg-emerald-600 text-white animate-fade-in",
        **{"_": "on load wait 8s then remove me"},
    )


@rt("/api/identity/{target_id}/merge/{source_id}")
def post(target_id: str, source_id: str, source: str = "web",
         resolved_name: str = None, custom_name: str = None, from_focus: bool = False, filter: str = "", focus_section: str = "", sess=None):
    """
    Merge source identity into target identity. Requires admin.

    Enhanced behavior:
    - Auto-corrects merge direction (named identity always survives)
    - Detects name conflicts (both named) and shows resolution modal
    - Records merge_history on target for undo capability
    - Promotes target state if source had higher-trust state
    """
    denied = _check_admin(sess)
    if denied:
        return denied
    try:
        registry = load_registry()
    except Exception:
        return Response(
            to_xml(toast("System busy. Please try again.", "warning")),
            status_code=423,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # Validate both identities exist
    try:
        registry.get_identity(target_id)
        registry.get_identity(source_id)
    except KeyError:
        return Response(
            to_xml(toast("Identity not found.", "error")),
            status_code=404,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # Load photo registry for validation
    photo_registry = load_photo_registry()

    # Determine user_source from merge origin
    user_source = source if source in ("web", "manual_search") else "web"

    # Handle custom name from conflict resolution form
    actual_resolved_name = resolved_name
    if resolved_name == "__custom__" and custom_name:
        actual_resolved_name = custom_name.strip()
    elif resolved_name == "__custom__":
        actual_resolved_name = None  # No custom name, will re-trigger conflict

    # Attempt merge (with auto-correction)
    result = registry.merge_identities(
        source_id=source_id,
        target_id=target_id,
        user_source=user_source,
        photo_registry=photo_registry,
        resolved_name=actual_resolved_name,
    )

    if not result["success"]:
        # Handle name conflict -- show resolution modal
        if result["reason"] == "name_conflict":
            return _name_conflict_modal(
                target_id, source_id,
                result["name_conflict_details"],
                merge_source=source,
            )

        error_messages = {
            "co_occurrence": "Cannot merge: these identities appear in the same photo.",
            "already_merged": "Cannot merge: source identity was already merged.",
        }
        message = error_messages.get(result["reason"], f"Merge failed: {result['reason']}")

        return Response(
            to_xml(toast(message, "error")),
            status_code=409,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # Save and return success
    save_registry(registry)

    # Use the actual target/source from the result (may have been swapped)
    actual_target_id = result["target_id"]
    actual_source_id = result["source_id"]

    # BE-006: Retarget annotations from source to target
    _merge_annotations(actual_source_id, actual_target_id)

    crop_files = get_crop_files()
    updated_identity = registry.get_identity(actual_target_id)
    target_name = ensure_utf8_display(updated_identity.get("name")) or "identity"
    is_unnamed = target_name.startswith("Unidentified") or target_name.startswith("identity")

    # Log the action
    log_user_action(
        "MERGE",
        source_identity_id=actual_source_id,
        target_identity_id=actual_target_id,
        faces_merged=result["faces_merged"],
        direction_swapped=result.get("direction_swapped", False),
    )

    # Build OOB elements to remove absorbed identity from DOM
    oob_elements = [
        Div(id=f"identity-{actual_source_id}", hx_swap_oob="delete"),
        Div(id=f"neighbor-{actual_source_id}", hx_swap_oob="delete"),
        Div(id=f"search-result-{actual_source_id}", hx_swap_oob="delete"),
    ]

    # If direction was swapped, also clean up the original identity cards
    if result.get("direction_swapped"):
        oob_elements.extend([
            Div(id=f"neighbor-{actual_target_id}", hx_swap_oob="delete"),
            Div(id=f"search-result-{actual_target_id}", hx_swap_oob="delete"),
        ])

    # Toast with undo
    merge_toast = toast_with_merge_undo(
        f"Merged {_pl(result['faces_merged'], 'face')} into {target_name}.",
        actual_target_id,
    )

    # Post-merge re-evaluation: suggest nearby unmatched faces (ML-005)
    suggestion_panel = _post_merge_suggestions(actual_target_id, registry, crop_files)

    # Post-merge guidance banner — encourage naming unnamed identities
    if is_unnamed:
        faces_merged = result["faces_merged"]
        merge_guidance = Div(
            Div(
                Span("Grouped!", cls="font-bold text-emerald-300"),
                Span(f" {_pl(faces_merged, 'face')} are now linked together.", cls="text-slate-300"),
                cls="text-sm",
            ),
            Button(
                "Add a name \u2192",
                cls="text-xs text-indigo-400 hover:text-indigo-300 underline mt-1",
                hx_get=f"/api/identity/{actual_target_id}/rename-form",
                hx_target=f"#name-{actual_target_id}",
                hx_swap="outerHTML",
                type="button",
            ),
            cls="bg-emerald-900/20 border border-emerald-500/30 rounded-lg px-4 py-3 mb-3",
            id=f"merge-guidance-{actual_target_id}",
            hx_swap_oob=f"afterbegin:#identity-{actual_target_id}",
        )
    else:
        total_faces = len(updated_identity.get("anchor_ids", [])) + len(updated_identity.get("candidate_ids", []))
        merge_guidance = Div(
            Div(
                Span("Merge complete!", cls="font-bold text-emerald-300"),
                Span(f" {_pl(total_faces, 'face')} now confirmed as ", cls="text-slate-300"),
                Span(target_name, cls="font-semibold text-white"),
                Span(".", cls="text-slate-300"),
                cls="text-sm",
            ),
            cls="bg-emerald-900/20 border border-emerald-500/30 rounded-lg px-4 py-3 mb-3",
            id=f"merge-guidance-{actual_target_id}",
            hx_swap_oob=f"afterbegin:#identity-{actual_target_id}",
            **{"_": "on load wait 6s then transition opacity to 0 over 1s then remove me"},
        )

    # If from focus mode, advance to next identity instead of showing browse card
    if from_focus:
        if focus_section == "skipped":
            return (
                get_next_skipped_focus_card(exclude_id=actual_target_id),
                merge_toast,
            )
        return (
            get_next_focus_card(exclude_id=actual_target_id, triage_filter=filter),
            merge_toast,
        )

    return (
        identity_card(updated_identity, crop_files, lane_color="emerald", show_actions=False),
        merge_guidance,
        *oob_elements,
        merge_toast,
        suggestion_panel,
    )


def _post_merge_suggestions(target_id: str, registry, crop_files: set, max_suggestions: int = 3):
    """
    After a merge, find nearby unmatched faces and suggest them for review.
    Uses multi-anchor best-linkage (AD-001 compliant). Only shows HIGH+ matches.
    """
    try:
        from core.neighbors import find_nearest_neighbors
        face_data = get_face_data()
        photo_registry = load_photo_registry()
        neighbors = find_nearest_neighbors(
            target_id, registry, photo_registry, face_data, limit=max_suggestions
        )
    except Exception:
        return Span()

    # Filter to HIGH confidence or better
    high_matches = [n for n in neighbors if n["distance"] < MATCH_THRESHOLD_HIGH]
    if not high_matches:
        return Span()

    cards = []
    for n in high_matches:
        cards.append(neighbor_card(n, target_id, crop_files, show_checkbox=False))

    return Div(
        Div(
            H4("You might also want to review:", cls="text-sm font-medium text-amber-400"),
            P(f"{_pl(len(high_matches), 'similar face')} found after merge", cls="text-xs text-slate-400"),
            cls="mb-2"
        ),
        Div(*cards, cls="space-y-2"),
        cls="mt-4 p-4 bg-slate-800/50 border border-amber-500/30 rounded-lg",
        id="post-merge-suggestions",
        hx_swap_oob="beforeend:#toast-container",
    )


@rt("/api/identity/{target_id}/suggest-merge/{source_id}")
def post(target_id: str, source_id: str, confidence: str = "likely", reason: str = "", sess=None):
    """
    Contributor endpoint: suggest merging source into target. Creates a
    merge_suggestion annotation for admin review instead of executing the merge.
    """
    denied = _check_contributor(sess)
    if denied:
        return denied

    user = get_current_user(sess)
    submitted_by = user.email if user else "anonymous"

    # Validate both identities exist
    try:
        registry = load_registry()
        registry.get_identity(target_id)
        registry.get_identity(source_id)
    except KeyError:
        return Response(
            to_xml(toast("Identity not found.", "error")),
            status_code=404,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    _create_merge_suggestion(
        target_id=target_id, source_id=source_id,
        submitted_by=submitted_by,
        confidence=confidence,
        reason=reason,
    )

    log_user_action("SUGGEST_MERGE", target=target_id, source=source_id, user=submitted_by)

    return Response(
        to_xml(toast("Merge suggestion submitted for admin review.", "success")),
        headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
    )


@rt("/api/identity/{identity_id}/undo-merge")
def post(identity_id: str, sess=None):
    """
    Undo the most recent merge on an identity. Requires admin.

    Reads merge_history, restores the source identity, removes
    merged faces from target.
    """
    denied = _check_admin(sess)
    if denied:
        return denied
    try:
        registry = load_registry()
    except Exception:
        return Response(
            to_xml(toast("System busy. Please try again.", "warning")),
            status_code=423,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # Validate identity exists
    try:
        registry.get_identity(identity_id)
    except KeyError:
        return Response(
            to_xml(toast("Identity not found.", "error")),
            status_code=404,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # Attempt undo
    result = registry.undo_merge(identity_id, user_source="web")

    if not result["success"]:
        error_messages = {
            "no_merge_history": "Nothing to undo.",
            "source_not_found": "Cannot undo: source identity no longer exists.",
            "target_is_merged": "Cannot undo: this identity has been merged into another.",
        }
        message = error_messages.get(result["reason"], f"Undo failed: {result['reason']}")
        return Response(
            to_xml(toast(message, "warning")),
            status_code=409,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    save_registry(registry)

    log_user_action(
        "UNDO_MERGE",
        target_identity_id=identity_id,
        restored_source_id=result["source_id"],
        faces_removed=result["faces_removed"],
    )

    return toast(f"Merge undone. {_pl(result['faces_removed'], 'face')} restored.", "success")


@rt("/api/identity/{identity_id}/bulk-merge")
def post(identity_id: str, bulk_ids: list[str] = None, sess=None):
    """
    Bulk merge multiple identities into one target. Requires admin.

    Merges each selected identity into the target one by one.
    """
    denied = _check_admin(sess)
    if denied:
        return denied

    if not bulk_ids:
        return toast("No identities selected.", "warning")

    # Ensure bulk_ids is a list (single value comes as string)
    if isinstance(bulk_ids, str):
        bulk_ids = [bulk_ids]

    try:
        registry = load_registry()
    except Exception:
        return Response(
            to_xml(toast("System busy. Please try again.", "warning")),
            status_code=423,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    photo_registry = load_photo_registry()

    merged_count = 0
    total_faces = 0
    errors = []

    for source_id in bulk_ids:
        try:
            result = registry.merge_identities(
                source_id=source_id,
                target_id=identity_id,
                user_source="web",
                photo_registry=photo_registry,
            )
            if result["success"]:
                merged_count += 1
                total_faces += result["faces_merged"]
            else:
                errors.append(f"{source_id[:8]}: {result['reason']}")
        except Exception as e:
            errors.append(f"{source_id[:8]}: {str(e)}")

    if merged_count > 0:
        save_registry(registry)

    if errors:
        return toast(f"Merged {merged_count} identities ({total_faces} faces). {len(errors)} failed.", "warning")

    return toast(f"Merged {merged_count} identities ({total_faces} faces).", "success")


@rt("/api/identity/{identity_id}/bulk-reject")
def post(identity_id: str, bulk_ids: list[str] = None, sess=None):
    """
    Bulk mark multiple identities as Not Same. Requires admin.
    """
    denied = _check_admin(sess)
    if denied:
        return denied

    if not bulk_ids:
        return toast("No identities selected.", "warning")

    # Ensure bulk_ids is a list
    if isinstance(bulk_ids, str):
        bulk_ids = [bulk_ids]

    try:
        registry = load_registry()
    except Exception:
        return Response(
            to_xml(toast("System busy. Please try again.", "warning")),
            status_code=423,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    rejected_count = 0
    for target_id in bulk_ids:
        try:
            registry.reject_identity_pair(identity_id, target_id, user_source="web")
            rejected_count += 1
        except Exception:
            pass

    if rejected_count > 0:
        save_registry(registry)

    return toast(f"Marked {rejected_count} identities as 'Not Same'.", "info")


@rt("/api/identity/{identity_id}/faces")
def get(identity_id: str, sort: str = "date", page: int = 0):
    """
    Get faces for an identity with optional sorting and pagination.

    Query params:
    - sort: "date" (default) or "outlier"
    - page: 0-indexed page number (FACES_PER_PAGE items per page)

    Returns HTML partial with face cards and pagination controls.
    """
    try:
        registry = load_registry()
        identity = registry.get_identity(identity_id)
    except KeyError:
        return Response("Identity not found", status_code=404)

    crop_files = get_crop_files()
    face_data = get_face_data()

    # Get all face entries in requested order
    if sort == "outlier":
        from core.neighbors import sort_faces_by_outlier_score
        sorted_faces = sort_faces_by_outlier_score(identity_id, registry, face_data)
        all_entries = [face_id for face_id, _ in sorted_faces]
    else:
        all_entries = identity.get("anchor_ids", []) + identity.get("candidate_ids", [])

    total_faces = len(all_entries)
    can_detach = total_faces > 1

    # Paginate
    start = page * FACES_PER_PAGE
    end = start + FACES_PER_PAGE
    page_entries = all_entries[start:end]

    # Build face cards
    if sort == "outlier":
        # For outlier sort, entries are plain face_id strings
        cards = []
        for face_id in page_entries:
            crop_url = resolve_face_image_url(face_id, crop_files)
            if crop_url:
                photo_id = get_photo_id_for_face(face_id)
                cards.append(face_card(
                    face_id=face_id,
                    crop_url=crop_url,
                    photo_id=photo_id,
                    identity_id=identity_id,
                    show_detach=can_detach,
                ))
            else:
                cards.append(Div(
                    Div(Span("?", cls="text-4xl text-slate-500"),
                        cls="w-full aspect-square bg-slate-700 border border-slate-600 flex items-center justify-center"),
                    P("Image unavailable", cls="text-xs text-slate-400 mt-1"),
                    P(f"ID: {face_id[:12]}...", cls="text-xs font-data text-slate-500"),
                    cls="face-card", id=make_css_id(face_id),
                ))
    else:
        cards = _build_face_cards_for_entries(page_entries, crop_files, identity_id, can_detach)

    pagination = _face_pagination_controls(identity_id, page, total_faces, sort)

    return Div(
        Div(
            *cards,
            cls="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3",
        ),
        pagination,
        id=f"faces-{identity_id}",
    )


# =============================================================================
# ROUTES - RENAME IDENTITY
# =============================================================================

@rt("/api/identity/{identity_id}/photos")
def get(identity_id: str, index: int = 0):
    """Get a single photo for the lightbox, with face overlays and navigation."""
    try:
        registry = load_registry()
        identity = registry.get_identity(identity_id)
    except KeyError:
        return P("Identity not found", cls="text-red-400")

    all_face_entries = identity.get("anchor_ids", []) + identity.get("candidate_ids", [])
    if not all_face_entries:
        return P("No faces for this identity", cls="text-slate-400")

    index = max(0, min(index, len(all_face_entries) - 1))
    total = len(all_face_entries)

    face_entry = all_face_entries[index]
    face_id = face_entry if isinstance(face_entry, str) else face_entry.get("face_id", "")

    pid = get_photo_id_for_face(face_id)
    if not pid:
        return P("Photo not found for this face", cls="text-slate-400")
    photo = get_photo_metadata(pid)
    if not photo:
        return P("Photo metadata not found", cls="text-slate-400")

    width, height = get_photo_dimensions(photo["filename"])
    has_dimensions = width > 0 and height > 0

    face_overlays = []
    identity_name = ensure_utf8_display(identity.get("name")) or "Unknown"
    if has_dimensions:
        for fd in photo["faces"]:
            fid = fd["face_id"]
            x1, y1, x2, y2 = fd["bbox"]
            lp = (x1 / width) * 100
            tp = (y1 / height) * 100
            wp = ((x2 - x1) / width) * 100
            hp = ((y2 - y1) / height) * 100
            fi = get_identity_for_face(registry, fid)
            is_t = fi and fi["identity_id"] == identity_id
            if is_t:
                oc = "absolute border-2 border-amber-500 bg-amber-500/20 cursor-pointer"
                lb = Span(identity_name, cls="absolute -top-7 left-1/2 -translate-x-1/2 bg-amber-600 text-white text-xs px-2 py-0.5 rounded whitespace-nowrap pointer-events-none")
            else:
                dn = ensure_utf8_display(fi.get("name", "")) if fi else ""
                oc = "absolute border border-emerald-500/50 bg-emerald-500/5 group cursor-pointer hover:bg-emerald-500/15"
                lb = Span(dn or "Unknown", cls="absolute -top-7 left-1/2 -translate-x-1/2 bg-stone-800 text-white text-xs px-2 py-0.5 rounded opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap pointer-events-none") if dn else None

            # Determine the correct section for navigation based on identity state
            fi_id = fi["identity_id"] if fi else None
            fi_section = _section_for_state(fi.get("state", "INBOX")) if fi else "to_review"

            # Click handler: navigate to the identity's face card in the correct section
            click_script = None
            if fi_id:
                click_script = (
                    f"on click halt the event's bubbling "
                    f"then add .hidden to #photo-modal "
                    f"then go to url '/?section={fi_section}&view=browse#identity-{fi_id}'"
                )

            face_overlays.append(Div(
                lb, cls=oc,
                style=f"left: {lp:.2f}%; top: {tp:.2f}%; width: {wp:.2f}%; height: {hp:.2f}%;",
                **{"_": click_script} if click_script else {},
            ))

    # Lightbox prev/next buttons use data-action for event delegation.
    # The global handler reads data-action and hx-get to dispatch navigation.
    prev_btn = Button(Span("\u25C0", cls="text-xl"), cls="absolute left-2 top-1/2 -translate-y-1/2 bg-black/60 hover:bg-black/80 text-white w-12 h-12 rounded-full flex items-center justify-center transition-colors z-10",
        hx_get=f"/api/identity/{identity_id}/photos?index={index - 1}", hx_target="#photo-modal-content", hx_swap="innerHTML",
        type="button", data_action="lightbox-prev") if index > 0 else None
    next_btn = Button(Span("\u25B6", cls="text-xl"), cls="absolute right-2 top-1/2 -translate-y-1/2 bg-black/60 hover:bg-black/80 text-white w-12 h-12 rounded-full flex items-center justify-center transition-colors z-10",
        hx_get=f"/api/identity/{identity_id}/photos?index={index + 1}", hx_target="#photo-modal-content", hx_swap="innerHTML",
        type="button", data_action="lightbox-next") if index < total - 1 else None

    # Touch swipe script only — keyboard is handled by global event delegation
    nav_script = Script(f"""(function(){{var el=document.getElementById('lightbox-photo-container');if(!el)return;var sx=0;el.addEventListener('touchstart',function(e){{sx=e.touches[0].clientX}});el.addEventListener('touchend',function(e){{var d=e.changedTouches[0].clientX-sx;if(Math.abs(d)>50){{if(d>0&&{index}>0)htmx.ajax('GET','/api/identity/{identity_id}/photos?index={index-1}',{{target:'#photo-modal-content',swap:'innerHTML'}});else if(d<0&&{index}<{total-1})htmx.ajax('GET','/api/identity/{identity_id}/photos?index={index+1}',{{target:'#photo-modal-content',swap:'innerHTML'}})}}}});}})();""")

    return Div(
        Div(Img(src=photo_url(photo["filename"]), alt=photo["filename"], cls="max-h-[80vh] max-w-full object-contain"),
            *face_overlays, prev_btn, next_btn, cls="relative inline-block", id="lightbox-photo-container"),
        Div(Span(f"{index + 1} / {total}", cls="text-white font-medium"),
            Span(f" -- {photo['filename']}", cls="text-slate-400 text-sm ml-2"),
            Span(identity_name, cls="text-amber-400 text-sm ml-4"), cls="mt-3 text-center"),
        nav_script, cls="flex flex-col items-center")


def _compare_photo_with_overlays(photo_url_str: str, photo_id: str, highlight_face_id: str, registry, img_height_cls: str) -> Div:
    """Render a photo with face bounding box overlays for the compare modal.

    Shows all faces in the photo with state-based colors. The face being
    compared (highlight_face_id) gets a bright amber highlight.
    """
    photo = get_photo_metadata(photo_id) if photo_id else None
    if not photo or not photo_url_str:
        return Div(
            Img(src=photo_url_str or "", cls=f"max-w-full {img_height_cls} object-contain rounded") if photo_url_str else Div(
                Span("?", cls="text-6xl text-slate-500"),
                cls="w-48 h-48 bg-slate-700 rounded flex items-center justify-center"),
            cls="flex justify-center bg-slate-700/50 rounded p-2")

    width, height = get_photo_dimensions(photo["filename"])
    has_dimensions = width > 0 and height > 0

    face_overlays = []
    if has_dimensions:
        for face_data in photo.get("faces", []):
            face_id = face_data["face_id"]
            bbox = face_data.get("bbox")
            if not bbox:
                continue
            x1, y1, x2, y2 = bbox

            left_pct = (x1 / width) * 100
            top_pct = (y1 / height) * 100
            width_pct = ((x2 - x1) / width) * 100
            height_pct = ((y2 - y1) / height) * 100

            identity = get_identity_for_face(registry, face_id)
            raw_name = identity.get("name", "Unidentified") if identity else "Unidentified"
            display_name = ensure_utf8_display(raw_name)
            identity_id = identity["identity_id"] if identity else None

            is_highlighted = face_id == highlight_face_id

            if is_highlighted:
                overlay_cls = "border-2 border-amber-400 bg-amber-400/25"
            elif identity:
                state = identity.get("state", "INBOX")
                if state == "CONFIRMED":
                    overlay_cls = "border-2 border-emerald-500/60 bg-emerald-500/10"
                elif state == "PROPOSED":
                    overlay_cls = "border-2 border-indigo-400/60 bg-indigo-400/10"
                else:
                    overlay_cls = "border-2 border-slate-400/60 bg-slate-400/5"
            else:
                overlay_cls = "border-2 border-dashed border-slate-400/40 bg-slate-400/5"

            # Click handler: navigate to identity card, closing the modal
            nav_section = _section_for_state(identity.get("state", "INBOX")) if identity else "to_review"
            click_script = (
                f"on click halt the event's bubbling "
                f"then add .hidden to #compare-modal "
                f"then go to url '/?section={nav_section}&view=browse#identity-{identity_id}'"
            ) if identity_id else ""

            overlay = Div(
                Span(
                    display_name,
                    cls="absolute -top-7 left-1/2 -translate-x-1/2 bg-stone-800 text-white text-[10px] px-1.5 py-0.5 rounded opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap pointer-events-none z-10"
                ),
                cls=f"absolute cursor-pointer transition-all group {overlay_cls}",
                style=f"left: {left_pct:.2f}%; top: {top_pct:.2f}%; width: {width_pct:.2f}%; height: {height_pct:.2f}%;",
                title=display_name,
                data_face_id=face_id,
                **{"_": click_script} if click_script else {},
            )
            face_overlays.append(overlay)

    return Div(
        Div(
            Img(src=photo_url_str, cls=f"max-w-full {img_height_cls} object-contain rounded"),
            *face_overlays,
            cls="relative inline-block max-w-full"),
        cls="flex justify-center bg-slate-700/50 rounded p-2")


@rt("/api/identity/{target_id}/compare/{neighbor_id}")
def get(target_id: str, neighbor_id: str, target_idx: int = 0, neighbor_idx: int = 0, view: str = "faces", filter: str = "", sess=None):
    """Side-by-side comparison view for evaluating merge candidates."""
    try:
        registry = load_registry()
        tgt = registry.get_identity(target_id)
        nbr = registry.get_identity(neighbor_id)
    except KeyError:
        return P("Identity not found", cls="text-red-400")
    crop_files = get_crop_files()
    tf = tgt.get("anchor_ids", []) + tgt.get("candidate_ids", [])
    nf = nbr.get("anchor_ids", []) + nbr.get("candidate_ids", [])
    if not tf or not nf:
        return P("No faces available for comparison", cls="text-slate-400")
    target_idx = max(0, min(target_idx, len(tf) - 1))
    neighbor_idx = max(0, min(neighbor_idx, len(nf) - 1))

    def _rf(entries, idx):
        e = entries[idx]
        fid = e if isinstance(e, str) else e.get("face_id", "")
        return fid, resolve_face_image_url(fid, crop_files)

    t_fid, t_url = _rf(tf, target_idx)
    n_fid, n_url = _rf(nf, neighbor_idx)
    t_name = ensure_utf8_display(tgt.get("name")) or f"Identity {target_id[:8]}..."
    n_name = ensure_utf8_display(nbr.get("name")) or f"Identity {neighbor_id[:8]}..."

    # Resolve photo IDs (always needed for View Photo links) and photo URLs (for photos view)
    t_photo_url = None
    n_photo_url = None
    _build_caches()
    t_photo_id = _face_to_photo_cache.get(t_fid, "")
    n_photo_id = _face_to_photo_cache.get(n_fid, "")
    if view == "photos":
        if t_photo_id and _photo_cache and t_photo_id in _photo_cache:
            t_photo_url = storage.get_photo_url(_photo_cache[t_photo_id].get("filename", ""))
        if n_photo_id and _photo_cache and n_photo_id in _photo_cache:
            n_photo_url = storage.get_photo_url(_photo_cache[n_photo_id].get("filename", ""))

    # Determine which image URLs to show
    t_display_url = t_photo_url if view == "photos" and t_photo_url else t_url
    n_display_url = n_photo_url if view == "photos" and n_photo_url else n_url

    # Section routing for clickable names
    t_section = _section_for_state(tgt.get("state", "INBOX"))
    n_section = _section_for_state(nbr.get("state", "INBOX"))
    _filter_suffix = f"&filter={filter}" if filter else ""

    def _cn(side, cur, tot, oth):
        if tot <= 1:
            return None
        b = f"/api/identity/{target_id}/compare/{neighbor_id}"
        if side == "t":
            pu = f"{b}?target_idx={cur-1}&neighbor_idx={oth}&view={view}{_filter_suffix}"
            nu = f"{b}?target_idx={cur+1}&neighbor_idx={oth}&view={view}{_filter_suffix}"
        else:
            pu = f"{b}?target_idx={oth}&neighbor_idx={cur-1}&view={view}{_filter_suffix}"
            nu = f"{b}?target_idx={oth}&neighbor_idx={cur+1}&view={view}{_filter_suffix}"
        pb = Button("\u2190", cls="px-2 py-1 text-slate-400 hover:text-white hover:bg-slate-600 rounded text-sm",
                    hx_get=pu, hx_target="#compare-modal-content", hx_swap="innerHTML",
                    type="button") if cur > 0 else Button(
                    "\u2190", cls="px-2 py-1 text-slate-500 opacity-30 rounded text-sm", disabled=True, type="button")
        nb = Button("\u2192", cls="px-2 py-1 text-slate-400 hover:text-white hover:bg-slate-600 rounded text-sm",
                    hx_get=nu, hx_target="#compare-modal-content", hx_swap="innerHTML",
                    type="button") if cur < tot - 1 else Button(
                    "\u2192", cls="px-2 py-1 text-slate-500 opacity-30 rounded text-sm", disabled=True, type="button")
        return Div(pb, Span(f"{cur+1} of {tot}", cls="text-xs text-slate-400 mx-2"), nb,
                   cls="flex items-center justify-center gap-1 mt-2")

    # Face/Photo toggle
    base_url = f"/api/identity/{target_id}/compare/{neighbor_id}?target_idx={target_idx}&neighbor_idx={neighbor_idx}{_filter_suffix}"
    toggle = Div(
        Button("Faces",
               cls=f"px-3 py-1 text-xs font-medium rounded-l {'bg-amber-600 text-white' if view == 'faces' else 'bg-slate-700 text-slate-300 hover:bg-slate-600'}",
               hx_get=f"{base_url}&view=faces", hx_target="#compare-modal-content", hx_swap="innerHTML", type="button"),
        Button("Photos",
               cls=f"px-3 py-1 text-xs font-medium rounded-r {'bg-amber-600 text-white' if view == 'photos' else 'bg-slate-700 text-slate-300 hover:bg-slate-600'}",
               hx_get=f"{base_url}&view=photos", hx_target="#compare-modal-content", hx_swap="innerHTML", type="button"),
        cls="flex justify-center mb-4"
    )

    # Action buttons -- role-aware
    _role = _get_user_role(sess)
    if _role == "contributor":
        m_btn = Button("Suggest Merge", cls="px-4 py-2 text-sm font-bold bg-purple-600 text-white rounded hover:bg-purple-500",
            hx_post=f"/api/identity/{target_id}/suggest-merge/{neighbor_id}", hx_target=f"#neighbor-{neighbor_id}", hx_swap="outerHTML",
            **{"_": "on htmx:afterRequest add .hidden to #compare-modal"}, type="button")
    else:
        m_btn = Button("Merge", cls="px-4 py-2 text-sm font-bold bg-blue-600 text-white rounded hover:bg-blue-500",
            hx_post=f"/api/identity/{target_id}/merge/{neighbor_id}", hx_target=f"#identity-{target_id}", hx_swap="outerHTML",
            **{"_": "on htmx:afterRequest add .hidden to #compare-modal"}, type="button")
    ns_btn = Button("Not Same", cls="px-4 py-2 text-sm font-bold border border-red-400/50 text-red-400 rounded hover:bg-red-500/20",
        hx_post=f"/api/identity/{target_id}/reject/{neighbor_id}", hx_target=f"#neighbor-{neighbor_id}", hx_swap="outerHTML",
        **{"_": "on htmx:afterRequest add .hidden to #compare-modal"}, type="button")
    cl_btn = Button("Close", cls="px-4 py-2 text-sm text-slate-400 hover:text-white border border-slate-600 rounded",
        **{"_": "on click add .hidden to #compare-modal"}, type="button")

    img_h = "max-h-[60vh]" if view == "photos" else "max-h-[50vh]"

    # Hyperscript for click-to-zoom on face crop images in compare modal
    _zoom_script = (
        "on click toggle .compare-crop-zoomed on me "
        "then if I match .compare-crop-zoomed "
        "set my style.transform to 'scale(2)' "
        "then set my style.cursor to 'zoom-out' "
        "else "
        "set my style.transform to 'scale(1)' "
        "then set my style.cursor to 'zoom-in' "
        "end"
    )

    # Build photo containers — with face overlays when in photos view
    if view == "photos" and t_photo_url:
        t_photo_div = _compare_photo_with_overlays(t_photo_url, t_photo_id, t_fid, registry, img_h)
    else:
        t_photo_div = Div(
            Img(src=t_display_url or "", alt=t_name,
                cls=f"max-w-full {img_h} object-contain rounded cursor-zoom-in transition-transform duration-200",
                data_compare_zoom="true",
                **{"_": _zoom_script}) if t_display_url else Div(
                Span("?", cls="text-6xl text-slate-500"),
                cls="w-48 h-48 bg-slate-700 rounded flex items-center justify-center"),
            cls="flex justify-center bg-slate-700/50 rounded p-2 overflow-hidden")

    if view == "photos" and n_photo_url:
        n_photo_div = _compare_photo_with_overlays(n_photo_url, n_photo_id, n_fid, registry, img_h)
    else:
        n_photo_div = Div(
            Img(src=n_display_url or "", alt=n_name,
                cls=f"max-w-full {img_h} object-contain rounded cursor-zoom-in transition-transform duration-200",
                data_compare_zoom="true",
                **{"_": _zoom_script}) if n_display_url else Div(
                Span("?", cls="text-6xl text-slate-500"),
                cls="w-48 h-48 bg-slate-700 rounded flex items-center justify-center"),
            cls="flex justify-center bg-slate-700/50 rounded p-2 overflow-hidden")

    # View Photo links — open the full photo lightbox from compare modal
    # Pass from_compare=1 so the photo view shows a "Back to Compare" button
    t_view_photo = Button(
        "View Photo \u2192",
        cls="text-xs text-amber-400/70 hover:text-amber-400 mt-1",
        hx_get=f"/photo/{t_photo_id}/partial?face={t_fid}&from_compare=1",
        hx_target="#photo-modal-content",
        hx_swap="innerHTML",
        **{"_": "on click remove .hidden from #photo-modal then add .hidden to #compare-modal"},
        type="button",
    ) if t_photo_id else None
    n_view_photo = Button(
        "View Photo \u2192",
        cls="text-xs text-indigo-400/70 hover:text-indigo-400 mt-1",
        hx_get=f"/photo/{n_photo_id}/partial?face={n_fid}&from_compare=1",
        hx_target="#photo-modal-content",
        hx_swap="innerHTML",
        **{"_": "on click remove .hidden from #photo-modal then add .hidden to #compare-modal"},
        type="button",
    ) if n_photo_id else None

    return Div(
        toggle,
        Div(
            Div(
                A(t_name, href=f"/?section={t_section}&current={target_id}{_filter_suffix}",
                  cls="text-sm font-medium text-amber-400 mb-2 text-center truncate block hover:underline",
                  **{"_": "on click add .hidden to #compare-modal"}),
                t_photo_div,
                t_view_photo,
                _cn("t", target_idx, len(tf), neighbor_idx),
                cls="flex-1 min-w-0"),
            Div(Span("vs", cls="text-slate-500 text-sm font-bold"), cls="flex items-center px-4"),
            Div(
                A(n_name, href=f"/?section={n_section}&current={neighbor_id}{_filter_suffix}",
                  cls="text-sm font-medium text-indigo-400 mb-2 text-center truncate block hover:underline",
                  **{"_": "on click add .hidden to #compare-modal"}),
                n_photo_div,
                n_view_photo,
                _cn("n", neighbor_idx, len(nf), target_idx),
                cls="flex-1 min-w-0"),
            cls="flex flex-col sm:flex-row gap-4 items-center sm:items-start"),
        Div(m_btn, ns_btn, cl_btn,
            cls="flex flex-wrap items-center justify-center gap-3 mt-6 pt-4 border-t border-slate-700"))


@rt("/api/identity/{identity_id}/rename-form")
def get(identity_id: str):
    """
    Return inline edit form for renaming an identity.
    Replaces the name display via HTMX.
    """
    try:
        registry = load_registry()
        identity = registry.get_identity(identity_id)
    except KeyError:
        return Response("Identity not found", status_code=404)

    # UI BOUNDARY: sanitize name for safe rendering in input value
    current_name = ensure_utf8_display(identity.get("name")) or ""

    return Form(
        Input(
            name="name",
            value=current_name,
            placeholder="Enter name...",
            cls="border border-slate-600 bg-slate-700 text-slate-200 rounded px-2 py-1 text-sm w-48 focus:outline-none focus:ring-2 focus:ring-blue-400",
            autofocus=True,
        ),
        Button(
            "Save",
            type="submit",
            cls="ml-2 bg-emerald-600 text-white px-2 py-1 rounded text-sm hover:bg-emerald-500",
        ),
        Button(
            "Cancel",
            type="button",
            hx_get=f"/api/identity/{identity_id}/name-display",
            hx_target=f"#name-{identity_id}",
            hx_swap="outerHTML",
            cls="ml-1 text-slate-400 hover:text-slate-300 text-sm underline",
        ),
        hx_post=f"/api/identity/{identity_id}/rename",
        hx_target=f"#name-{identity_id}",
        hx_swap="outerHTML",
        id=f"name-{identity_id}",
        cls="flex items-center",
    )


@rt("/api/identity/{identity_id}/name-display")
def get(identity_id: str):
    """
    Return the name display component (for cancel button).
    """
    try:
        registry = load_registry()
        identity = registry.get_identity(identity_id)
    except KeyError:
        return Response("Identity not found", status_code=404)

    return name_display(identity_id, identity.get("name"))


@rt("/api/identity/{identity_id}/rename")
def post(identity_id: str, name: str = "", sess=None):
    """Rename an identity. Requires admin."""
    denied = _check_admin(sess)
    if denied:
        return denied
    try:
        registry = load_registry()
    except Exception:
        return Response(
            to_xml(toast("System busy. Please try again.", "warning")),
            status_code=423,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    try:
        registry.get_identity(identity_id)
    except KeyError:
        return Response(
            to_xml(toast("Identity not found.", "error")),
            status_code=404,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # Validate name
    name = name.strip() if name else ""
    if not name:
        return Response(
            to_xml(toast("Name cannot be empty.", "warning")),
            status_code=400,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    try:
        previous_name = registry.rename_identity(identity_id, name, user_source="web")
        save_registry(registry)
    except ValueError as e:
        return Response(
            to_xml(toast(str(e), "error")),
            status_code=400,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )
    except Exception as e:
        return Response(
            to_xml(toast(f"Rename failed: {str(e)}", "error")),
            status_code=500,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # Return updated name display + success toast
    return (
        name_display(identity_id, name),
        toast(f"Renamed to '{name}'", "success"),
    )


# =============================================================================
# ROUTES - IDENTITY NOTES
# =============================================================================

@rt("/api/identity/{identity_id}/notes")
def get(identity_id: str):
    """Get notes for an identity and show the notes panel."""
    try:
        registry = load_registry()
        notes = registry.get_notes(identity_id)
    except KeyError:
        return P("Identity not found.", cls="text-red-400 text-sm")

    note_items = [
        Div(
            P(n["text"], cls="text-sm text-slate-200"),
            Div(
                Span(n.get("author", ""), cls="text-xs text-slate-500"),
                Span(n.get("timestamp", "")[:10], cls="text-xs text-slate-500 ml-2"),
                cls="flex items-center mt-1"
            ),
            cls="p-2 bg-slate-700 rounded mb-1"
        )
        for n in reversed(notes)  # Newest first
    ]

    return Div(
        H5("Notes", cls="text-sm font-semibold text-slate-300 mb-2"),
        Div(*note_items) if note_items else P("No notes yet.", cls="text-xs text-slate-500 italic"),
        # Add note form
        Form(
            Input(
                type="text", name="text",
                placeholder="Add a note...",
                cls="w-full px-2 py-1.5 text-sm bg-slate-800 border border-slate-600 text-white rounded "
                    "focus:outline-none focus:ring-1 focus:ring-indigo-400 placeholder-slate-500",
                required=True,
            ),
            Button(
                "Add",
                type="submit",
                cls="mt-1 px-3 py-1 text-xs bg-indigo-600 text-white rounded hover:bg-indigo-500",
            ),
            hx_post=f"/api/identity/{identity_id}/notes",
            hx_target=f"#notes-{identity_id}",
            hx_swap="innerHTML",
            cls="mt-2",
        ),
        id=f"notes-{identity_id}",
    )


@rt("/api/identity/{identity_id}/notes")
def post(identity_id: str, text: str = "", sess=None):
    """Add a note to an identity. Requires admin."""
    denied = _check_admin(sess)
    if denied:
        return denied

    text = text.strip()
    if not text:
        return toast("Note cannot be empty.", "warning")

    user_email = ""
    if sess:
        user = get_current_user(sess)
        if user:
            user_email = user.email

    try:
        registry = load_registry()
        registry.add_note(identity_id, text, author=user_email)
        save_registry(registry)
    except KeyError:
        return toast("Identity not found.", "error")
    except Exception as e:
        return toast(f"Failed to add note: {e}", "error")

    # Re-render the notes panel
    notes = registry.get_notes(identity_id)
    note_items = [
        Div(
            P(n["text"], cls="text-sm text-slate-200"),
            Div(
                Span(n.get("author", ""), cls="text-xs text-slate-500"),
                Span(n.get("timestamp", "")[:10], cls="text-xs text-slate-500 ml-2"),
                cls="flex items-center mt-1"
            ),
            cls="p-2 bg-slate-700 rounded mb-1"
        )
        for n in reversed(notes)
    ]

    return Div(
        H5("Notes", cls="text-sm font-semibold text-slate-300 mb-2"),
        Div(*note_items),
        Form(
            Input(
                type="text", name="text",
                placeholder="Add a note...",
                cls="w-full px-2 py-1.5 text-sm bg-slate-800 border border-slate-600 text-white rounded "
                    "focus:outline-none focus:ring-1 focus:ring-indigo-400 placeholder-slate-500",
                required=True,
            ),
            Button(
                "Add",
                type="submit",
                cls="mt-1 px-3 py-1 text-xs bg-indigo-600 text-white rounded hover:bg-indigo-500",
            ),
            hx_post=f"/api/identity/{identity_id}/notes",
            hx_target=f"#notes-{identity_id}",
            hx_swap="innerHTML",
            cls="mt-2",
        ),
        id=f"notes-{identity_id}",
    )


@rt("/api/identity/{identity_id}/metadata-form")
def get(identity_id: str, sess=None):
    """Return an inline metadata edit form for an identity."""
    denied = _check_admin(sess)
    if denied:
        return denied

    try:
        registry = load_registry()
        identity = registry.get_identity(identity_id)
    except KeyError:
        return toast("Identity not found.", "error")

    _input_cls = ("w-full px-2 py-1.5 text-sm bg-slate-700 border border-slate-600 text-white rounded "
                  "focus:outline-none focus:ring-1 focus:ring-indigo-400 placeholder-slate-500")

    return Div(
        Form(
            Div(
                Div(
                    Label("Maiden Name", cls="text-xs text-slate-400"),
                    Input(type="text", name="maiden_name", value=identity.get("maiden_name", ""),
                          placeholder="née ...", cls=_input_cls),
                    cls="flex-1"
                ),
                Div(
                    Label("Qualifier", cls="text-xs text-slate-400"),
                    Input(type="text", name="generation_qualifier", value=identity.get("generation_qualifier", ""),
                          placeholder="e.g. Sr., Jr.", cls=_input_cls),
                    cls="w-24"
                ),
                cls="flex gap-2"
            ),
            Div(
                Div(
                    Label("Birth Year", cls="text-xs text-slate-400"),
                    Input(type="text", name="birth_year", value=str(identity.get("birth_year", "")),
                          placeholder="e.g. 1920", cls=_input_cls),
                    cls="w-24"
                ),
                Div(
                    Label("Death Year", cls="text-xs text-slate-400"),
                    Input(type="text", name="death_year", value=str(identity.get("death_year", "")),
                          placeholder="e.g. 1995", cls=_input_cls),
                    cls="w-24"
                ),
                Div(
                    Label("Birthplace", cls="text-xs text-slate-400"),
                    Input(type="text", name="birth_place", value=identity.get("birth_place", ""),
                          placeholder="e.g. Rhodes, Greece", cls=_input_cls, list="places-list"),
                    cls="flex-1"
                ),
                Div(
                    Label("Death Place", cls="text-xs text-slate-400"),
                    Input(type="text", name="death_place", value=identity.get("death_place", ""),
                          placeholder="e.g. Auschwitz", cls=_input_cls, list="places-list"),
                    cls="flex-1"
                ),
                cls="flex gap-2 flex-wrap"
            ),
            Div(
                Label("Relationships", cls="text-xs text-slate-400"),
                Input(type="text", name="relationship_notes", value=identity.get("relationship_notes", ""),
                      placeholder="e.g. Daughter of X & Y, married to Z", cls=_input_cls),
            ),
            Div(
                Label("Bio", cls="text-xs text-slate-400"),
                Textarea(
                    identity.get("bio", ""),
                    name="bio", rows="2",
                    placeholder="Biographical notes...",
                    cls=_input_cls + " resize-y",
                ),
            ),
            Div(
                Button("Save", type="submit",
                       cls="px-3 py-1.5 text-xs bg-indigo-600 text-white rounded hover:bg-indigo-500"),
                Button("Cancel", type="button",
                       cls="px-3 py-1.5 text-xs bg-slate-600 text-slate-300 rounded hover:bg-slate-500",
                       hx_get=f"/api/identity/{identity_id}/metadata-display",
                       hx_target=f"#metadata-{identity_id}",
                       hx_swap="innerHTML"),
                cls="flex gap-2 mt-1"
            ),
            hx_post=f"/api/identity/{identity_id}/metadata",
            hx_target=f"#metadata-{identity_id}",
            hx_swap="innerHTML",
            cls="space-y-2",
        ),
        _place_datalist(),
        id=f"metadata-{identity_id}",
    )


@rt("/api/identity/{identity_id}/metadata-display")
def get(identity_id: str, sess=None):
    """Return the metadata display (non-form) for an identity."""
    try:
        registry = load_registry()
        identity = registry.get_identity(identity_id)
    except KeyError:
        return Span()
    is_admin = not _check_admin(sess)
    return _identity_metadata_display(identity, is_admin=is_admin)


@rt("/api/identity/{identity_id}/metadata")
def post(identity_id: str, birth_year: str = "", death_year: str = "",
         birth_place: str = "", death_place: str = "", maiden_name: str = "",
         generation_qualifier: str = "",
         relationship_notes: str = "", bio: str = "", sess=None):
    """Update identity metadata. Admin-only (BE-011)."""
    denied = _check_admin(sess)
    if denied:
        return denied

    metadata = {}
    if birth_year.strip():
        try:
            metadata["birth_year"] = int(birth_year.strip())
        except ValueError:
            pass
    if death_year.strip():
        try:
            metadata["death_year"] = int(death_year.strip())
        except ValueError:
            pass
    if birth_place.strip():
        metadata["birth_place"] = birth_place.strip()
    if death_place.strip():
        metadata["death_place"] = death_place.strip()
    if maiden_name.strip():
        metadata["maiden_name"] = maiden_name.strip()
    if generation_qualifier.strip():
        metadata["generation_qualifier"] = generation_qualifier.strip()
    if relationship_notes.strip():
        metadata["relationship_notes"] = relationship_notes.strip()
    if bio.strip():
        metadata["bio"] = bio.strip()

    if not metadata:
        return toast("No metadata provided.", "warning")

    try:
        registry = load_registry()
        registry.set_metadata(identity_id, metadata, user_source="admin_web")
        save_registry(registry)
        # Return updated display with success toast
        identity = registry.get_identity(identity_id)
        display = _identity_metadata_display(identity, is_admin=True)
        oob_toast = Div(
            toast(f"Metadata updated ({len(metadata)} field(s)).", "success"),
            hx_swap_oob="beforeend:#toast-container",
        )
        return (display, oob_toast)
    except KeyError:
        return toast("Identity not found.", "error")


# =============================================================================
# ML BIRTH YEAR REVIEW ENDPOINTS (Gatekeeper Pattern — AD-097)
# =============================================================================

@rt("/api/ml-review/birth-year/{identity_id}/accept")
def post(identity_id: str, birth_year: str = "", source_detail: str = "", sess=None):
    """Accept (or edit & accept) an ML birth year estimate. Admin-only.

    Writes the accepted birth year to canonical identity metadata.
    Records in ground truth file for ML feedback loop.
    """
    denied = _check_admin(sess)
    if denied:
        return denied

    try:
        by = int(birth_year)
    except (ValueError, TypeError):
        return Div(
            Span("Invalid birth year", cls="text-red-400 text-xs"),
            id=f"ml-suggestion-{identity_id}",
        )

    registry = load_registry()
    try:
        identity = registry.get_identity(identity_id)
    except KeyError:
        return Div(
            Span("Identity not found", cls="text-red-400 text-xs"),
            id=f"ml-suggestion-{identity_id}",
        )

    # Get original ML estimate for ground truth
    estimates = _load_birth_year_estimates()
    est = estimates.get(identity_id, {})
    original_ml = est.get("birth_year_estimate")

    # Determine source provenance
    if original_ml and by != original_ml:
        source = "admin_correction"
    else:
        source = "ml_accepted"

    # Write to canonical identity metadata
    registry.set_metadata(identity_id, {"birth_year": by}, user_source="admin_ml_review")
    save_registry(registry)

    # Record review decision
    decisions = dict(_load_ml_review_decisions())
    decisions[identity_id] = {
        "action": "accepted",
        "birth_year": by,
        "original_ml_estimate": original_ml,
        "source": source,
        "source_detail": source_detail.strip() if source_detail else "",
        "decided_at": datetime.now(timezone.utc).isoformat(),
        "decided_by": "admin",
    }
    _save_ml_review_decisions(decisions)

    # Write ground truth for ML feedback loop
    _save_ground_truth_birth_year(
        identity_id=identity_id,
        identity=registry.get_identity(identity_id),
        birth_year=by,
        source=source,
        source_detail=source_detail.strip() if source_detail else "",
        original_ml_estimate=original_ml,
    )

    name = ensure_utf8_display(identity.get("name", ""))
    correction_note = f" (ML: {original_ml})" if original_ml and by != original_ml else ""
    return Div(
        Div(
            Span("\u2705 ", cls="mr-1"),
            Span(f"Born {by}{correction_note}", cls="text-emerald-400 text-sm font-medium"),
            cls="mb-1",
        ),
        Span(f"Confirmed for {name}", cls="text-xs text-slate-500"),
        id=f"ml-suggestion-{identity_id}",
        cls="bg-emerald-500/5 border border-emerald-500/20 rounded-lg p-3 mt-3 mb-3 text-center max-w-sm mx-auto",
        data_testid="ml-suggestion-accepted",
    )


@rt("/api/ml-review/birth-year/{identity_id}/reject")
def post(identity_id: str, reason: str = "", sess=None):
    """Reject an ML birth year estimate. Admin-only."""
    denied = _check_admin(sess)
    if denied:
        return denied

    estimates = _load_birth_year_estimates()
    est = estimates.get(identity_id, {})
    original_ml = est.get("birth_year_estimate")

    decisions = dict(_load_ml_review_decisions())
    decisions[identity_id] = {
        "action": "rejected",
        "original_ml_estimate": original_ml,
        "reason": reason.strip() if reason else "",
        "decided_at": datetime.now(timezone.utc).isoformat(),
        "decided_by": "admin",
    }
    _save_ml_review_decisions(decisions)

    # Invalidate cache
    global _ml_review_decisions_cache
    _ml_review_decisions_cache = None

    return Div(
        Span("\u274c Estimate rejected", cls="text-slate-500 text-xs"),
        id=f"ml-suggestion-{identity_id}",
        cls="text-center py-2",
        data_testid="ml-suggestion-rejected",
    )


@rt("/api/photo/{photo_id}/metadata")
def post(photo_id: str, date_taken: str = "", location: str = "",
         caption: str = "", occasion: str = "", donor: str = "",
         notes: str = "", back_image: str = "", back_transcription: str = "",
         sess=None):
    """Update photo metadata. Admin-only (BE-012)."""
    denied = _check_admin(sess)
    if denied:
        return denied

    metadata = {}
    if date_taken.strip():
        metadata["date_taken"] = date_taken.strip()
    if location.strip():
        metadata["location"] = location.strip()
    if caption.strip():
        metadata["caption"] = caption.strip()
    if occasion.strip():
        metadata["occasion"] = occasion.strip()
    if donor.strip():
        metadata["donor"] = donor.strip()
    if notes.strip():
        metadata["notes"] = notes.strip()
    if back_image.strip():
        metadata["back_image"] = back_image.strip()
    if back_transcription.strip():
        metadata["back_transcription"] = back_transcription.strip()

    if not metadata:
        return toast("No metadata provided.", "warning")

    photo_registry = load_photo_registry()
    if not photo_registry.set_metadata(photo_id, metadata):
        return toast("Photo not found.", "error")
    save_photo_registry(photo_registry)

    return toast(f"Photo metadata updated ({len(metadata)} field(s)).", "success")


@rt("/api/photo/{photo_id}/back-image")
async def post(photo_id: str, file: UploadFile = None, back_transcription: str = "", sess=None):
    """Upload a back image for a photo and optionally add transcription. Admin-only."""
    denied = _check_admin(sess)
    if denied:
        return denied

    if not file or not file.filename:
        return toast("No file selected.", "warning")

    # Validate file type
    ext = Path(file.filename).suffix.lower()
    if ext not in {".jpg", ".jpeg", ".png", ".webp"}:
        return toast(f"File type '{ext}' not allowed. Use .jpg, .png, or .webp.", "error")

    # Read file content
    content = await file.read()
    if len(content) > 50 * 1024 * 1024:  # 50MB limit
        return toast("File too large. Maximum is 50 MB.", "error")

    # Generate back image filename: {original_stem}_back{ext}
    photo_registry = load_photo_registry()
    photo = photo_registry.get_photo(photo_id)
    if not photo:
        return toast("Photo not found.", "error")

    original_path = photo.get("path", photo.get("filename", ""))
    original_stem = Path(original_path).stem
    back_filename = f"{original_stem}_back{ext}"

    # Save to raw_photos/ (local dev) or staging (production)
    raw_photos_dir = Path("raw_photos")
    if raw_photos_dir.exists():
        save_path = raw_photos_dir / back_filename
        save_path.write_bytes(content)
    else:
        # Staging for production upload
        staging_dir = data_path / "staging" / "back_images"
        staging_dir.mkdir(parents=True, exist_ok=True)
        save_path = staging_dir / back_filename
        save_path.write_bytes(content)

    # Update photo metadata
    metadata = {"back_image": back_filename}
    if back_transcription.strip():
        metadata["back_transcription"] = back_transcription.strip()
    photo_registry.set_metadata(photo_id, metadata)
    save_photo_registry(photo_registry)

    return Div(
        P(f"Back image uploaded: {back_filename}", cls="text-emerald-400 text-sm"),
        P("The 'Turn Over' button is now available on this photo.", cls="text-slate-400 text-xs mt-1"),
        cls="p-2",
    )


@rt("/api/photo/{photo_id}/back-transcription")
def post(photo_id: str, back_transcription: str = "", sess=None):
    """Update the back transcription for a photo. Admin-only."""
    denied = _check_admin(sess)
    if denied:
        return denied

    if not back_transcription.strip():
        return toast("No transcription provided.", "warning")

    photo_registry = load_photo_registry()
    if not photo_registry.set_metadata(photo_id, {"back_transcription": back_transcription.strip()}):
        return toast("Photo not found.", "error")
    save_photo_registry(photo_registry)

    return toast("Transcription saved.", "success")


@rt("/api/photo/{photo_id}/transform")
def post(photo_id: str, transform: str = "", field: str = "transform", sess=None):
    """Set non-destructive image transformation. Admin-only.

    transform: The transform to apply (e.g., 'rotate:90', 'flipH', 'reset')
    field: 'transform' (front image) or 'back_transform' (back image)
    """
    denied = _check_admin(sess)
    if denied:
        return denied

    if field not in {"transform", "back_transform"}:
        return toast("Invalid field.", "error")

    photo_registry = load_photo_registry()
    photo = photo_registry.get_photo(photo_id)
    if not photo:
        return toast("Photo not found.", "error")

    if transform == "reset":
        new_transform = ""
    else:
        # Append to existing transform (or start fresh)
        existing = photo.get(field, "")
        if existing:
            new_transform = f"{existing},{transform}"
        else:
            new_transform = transform

    photo_registry.set_metadata(photo_id, {field: new_transform})
    save_photo_registry(photo_registry)

    # Return the CSS transform for live preview
    css_transform = parse_transform_to_css(new_transform)
    css_filter = parse_transform_to_filter(new_transform)
    return Div(
        P(f"Transform: {new_transform}" if new_transform else "Transform reset.", cls="text-xs text-slate-400"),
        Script(f"""
            var img = document.querySelector('.photo-hero, .photo-flip-front img');
            if (img) {{
                img.style.transform = '{css_transform}';
                img.style.filter = '{css_filter}';
            }}
        """) if css_transform or css_filter or transform == "reset" else None,
        cls="mt-1",
    )


@rt("/api/onboarding/discover")
def get(surnames: str = ""):
    """Return HTML fragment showing confirmed identities matching selected surnames.

    Public endpoint — no auth required. Used by the onboarding modal.
    """
    if not surnames.strip():
        return Div(P("No surnames selected.", cls="text-sm text-slate-400"))

    surname_list = [s.strip() for s in surnames.split(",") if s.strip()]

    # Load surname variants for matching
    from core.registry import _load_surname_variants
    variant_lookup = _load_surname_variants()

    # Expand each surname to its variant group
    target_names = set()
    for surname in surname_list:
        target_names.add(surname.lower())
        variants = variant_lookup.get(surname.lower(), [])
        target_names.update(variants)

    # Find confirmed identities whose last name matches
    registry = load_registry()
    confirmed = registry.list_identities(state=IdentityState.CONFIRMED)
    crop_files = get_crop_files()

    matches = []
    for identity in confirmed:
        name = (identity.get("name") or "").strip()
        if not name or name.startswith("Unidentified"):
            continue
        # Check last name or any word in name
        name_words = [w.lower() for w in name.split()]
        if any(w in target_names for w in name_words):
            face_ids = identity.get("anchor_ids", []) + identity.get("candidate_ids", [])
            crop_url = resolve_face_image_url(face_ids[0], crop_files) if face_ids else None
            if crop_url:
                matches.append({
                    "name": name,
                    "crop_url": crop_url,
                    "identity_id": identity["identity_id"],
                    "photo_count": len(face_ids),
                })

    if not matches:
        return Div(
            H3("No matches yet", cls="text-lg font-bold text-white mb-2"),
            P("We don't have confirmed identities with those surnames yet, "
              "but you can still help identify unknown faces!",
              cls="text-sm text-slate-400 mb-4"),
            Button("Continue", type="button", data_action="onboarding-continue",
                   cls="px-4 py-2 bg-amber-600 text-white text-sm font-medium rounded-lg hover:bg-amber-500 w-full"),
        )

    # Show up to 6 matching people
    people_cards = []
    for m in matches[:6]:
        people_cards.append(
            A(
                Div(
                    Img(src=m["crop_url"], alt=m["name"],
                        cls="w-16 h-16 rounded-full object-cover border-2 border-amber-400/50"),
                    Div(
                        Span(m["name"], cls="text-sm font-medium text-white"),
                        Span(f"{m['photo_count']} photo{'s' if m['photo_count'] != 1 else ''}",
                             cls="text-xs text-slate-400"),
                        cls="flex flex-col",
                    ),
                    cls="flex items-center gap-3",
                ),
                href=f"/?section=confirmed&current={m['identity_id']}",
                cls="block p-2 rounded-lg hover:bg-slate-700/50 transition-colors",
                data_action="onboarding-close",
            )
        )

    return Div(
        H3(f"We found {len(matches)} {'person' if len(matches) == 1 else 'people'} "
           f"with those family names!",
           cls="text-lg font-bold text-white mb-3"),
        Div(*people_cards, cls="space-y-1 mb-4 max-h-64 overflow-y-auto"),
        P(f"{len(matches)} identified so far — can you help find more?",
          cls="text-xs text-slate-500 mb-3") if len(matches) > 6 else None,
        Button("Continue", type="button", data_action="onboarding-continue",
               cls="px-4 py-2 bg-amber-600 text-white text-sm font-medium rounded-lg hover:bg-amber-500 w-full"),
    )


@rt("/api/photos/bulk-update-source")
def post(photo_ids: str = "[]", collection: str = "", source: str = "",
         source_url: str = "", sess=None):
    """Bulk update collection/source/source_url for multiple photos. Admin-only."""
    denied = _check_admin(sess)
    if denied:
        return denied

    if not collection.strip() and not source.strip() and not source_url.strip():
        return toast("Please provide collection, source, or source URL.", "warning")

    try:
        ids = json.loads(photo_ids)
    except (json.JSONDecodeError, TypeError):
        return toast("Invalid photo selection.", "error")

    if not ids:
        return toast("No photos selected.", "warning")

    photo_registry = load_photo_registry()
    updated = 0
    for pid in ids:
        if collection.strip():
            photo_registry.set_collection(pid, collection.strip())
        if source.strip():
            photo_registry.set_source(pid, source.strip())
        if source_url.strip():
            photo_registry.set_source_url(pid, source_url.strip())
        updated += 1
    save_photo_registry(photo_registry)

    # Invalidate photo cache so grid reflects changes
    global _photo_cache
    _photo_cache = None

    fields = []
    if collection.strip():
        fields.append(f"collection={collection.strip()}")
    if source.strip():
        fields.append(f"source={source.strip()}")
    if source_url.strip():
        fields.append("source_url")

    log_user_action("BULK_UPDATE_METADATA", count=updated, fields=", ".join(fields))

    return toast(f"Updated {updated} photo(s): {', '.join(fields)}.", "success")


# =============================================================================
# ROUTES - PROPOSED MATCHES
# =============================================================================

@rt("/api/identity/{identity_id}/propose-match")
def post(identity_id: str, target_id: str, note: str = "", sess=None):
    """Propose a match between two identities without executing it. Requires admin."""
    denied = _check_admin(sess)
    if denied:
        return denied

    user_email = ""
    if sess:
        user = get_current_user(sess)
        if user:
            user_email = user.email

    try:
        registry = load_registry()
        proposal = registry.add_proposed_match(identity_id, target_id, note=note, author=user_email)
        save_registry(registry)
    except KeyError:
        return toast("Identity not found.", "error")
    except Exception as e:
        return toast(f"Failed to propose match: {e}", "error")

    return toast(f"Match proposed!", "success")


@rt("/api/proposed-matches")
def get():
    """List all pending proposed matches."""
    try:
        registry = load_registry()
    except Exception:
        return P("Unable to load proposals.", cls="text-red-400")

    proposals = registry.list_proposed_matches()
    if not proposals:
        return Div(
            P("No pending proposals.", cls="text-slate-400 italic text-sm"),
            cls="text-center py-8"
        )

    crop_files = get_crop_files()
    items = []
    for p in proposals:
        source_name = ensure_utf8_display(p.get("source_name")) or f"Identity {p['source_id'][:8]}..."
        target_name = ensure_utf8_display(p.get("target_name")) or f"Identity {p['target_id'][:8]}..."

        items.append(Div(
            Div(
                Span(source_name, cls="text-sm font-medium text-slate-200"),
                Span(" → ", cls="text-slate-500"),
                Span(target_name, cls="text-sm font-medium text-slate-200"),
                cls="flex items-center gap-1"
            ),
            P(p.get("note", ""), cls="text-xs text-slate-400 mt-1") if p.get("note") else None,
            Div(
                Span(f"by {p.get('author', 'unknown')}", cls="text-xs text-slate-500"),
                Span(p.get("timestamp", "")[:10], cls="text-xs text-slate-500 ml-2"),
                cls="flex items-center mt-1"
            ),
            Div(
                Button(
                    "Accept (Merge)",
                    cls="px-2 py-1 text-xs bg-emerald-600 text-white rounded hover:bg-emerald-500",
                    hx_post=f"/api/proposed-matches/{p['source_id']}/{p['id']}/accept",
                    hx_target="#proposed-matches-list",
                    hx_swap="innerHTML",
                    type="button",
                ),
                Button(
                    "Reject",
                    cls="px-2 py-1 text-xs border border-red-400 text-red-400 rounded hover:bg-red-500/20",
                    hx_post=f"/api/proposed-matches/{p['source_id']}/{p['id']}/reject",
                    hx_target="#proposed-matches-list",
                    hx_swap="innerHTML",
                    type="button",
                ),
                cls="flex gap-2 mt-2"
            ),
            cls="p-3 bg-slate-800 border border-slate-700 rounded-lg mb-2"
        ))

    return Div(*items, id="proposed-matches-list")


@rt("/api/proposed-matches/{source_id}/{proposal_id}/accept")
def post(source_id: str, proposal_id: str, sess=None):
    """Accept a proposed match — execute the merge."""
    denied = _check_admin(sess)
    if denied:
        return denied

    try:
        registry = load_registry()
        photo_registry = load_photo_registry()

        # Get the proposal to find target_id
        identity = registry.get_identity(source_id)
        proposal = None
        for pm in identity.get("proposed_matches", []):
            if pm["id"] == proposal_id:
                proposal = pm
                break

        if not proposal:
            return toast("Proposal not found.", "error")

        target_id = proposal["target_id"]

        # Execute the merge
        result = registry.merge_identities(
            source_id=source_id,
            target_id=target_id,
            user_source="proposed_match",
            photo_registry=photo_registry,
        )

        if result["success"]:
            registry.resolve_proposed_match(source_id, proposal_id, "accepted")
            save_registry(registry)
            oob_toast = Div(
                toast(f"Merged! {_pl(result['faces_merged'], 'face')} combined.", "success"),
                hx_swap_oob="beforeend:#toast-container",
            )
        else:
            oob_toast = Div(
                toast(f"Cannot merge: {result['reason']}", "warning"),
                hx_swap_oob="beforeend:#toast-container",
            )
    except Exception as e:
        oob_toast = Div(
            toast(f"Error: {e}", "error"),
            hx_swap_oob="beforeend:#toast-container",
        )

    # Re-render the proposals list
    proposals = registry.list_proposed_matches()
    if not proposals:
        return (Div(
            P("No pending proposals.", cls="text-slate-400 italic text-sm"),
            cls="text-center py-8", id="proposed-matches-list"
        ), oob_toast)

    # Return a placeholder that triggers reload of the proposals list
    return (Div(
        P("Refreshing...", cls="text-slate-400"),
        hx_get="/api/proposed-matches",
        hx_trigger="load",
        hx_swap="outerHTML",
        id="proposed-matches-list"
    ), oob_toast)


@rt("/api/proposed-matches/{source_id}/{proposal_id}/reject")
def post(source_id: str, proposal_id: str, sess=None):
    """Reject a proposed match."""
    denied = _check_admin(sess)
    if denied:
        return denied

    try:
        registry = load_registry()
        registry.resolve_proposed_match(source_id, proposal_id, "rejected")
        save_registry(registry)
    except Exception as e:
        return toast(f"Error: {e}", "error")

    # Re-render with reload trigger
    return Div(
        P("Refreshing...", cls="text-slate-400"),
        hx_get="/api/proposed-matches",
        hx_trigger="load",
        hx_swap="outerHTML",
        id="proposed-matches-list"
    )


# =============================================================================
# ROUTES - DETACH FACE
# =============================================================================

@rt("/api/face/{face_id:path}/detach")
def post(face_id: str, sess=None):
    """Detach a face from its identity into a new identity. Requires admin."""
    denied = _check_admin(sess)
    if denied:
        return denied
    try:
        registry = load_registry()
    except Exception:
        return Response(
            to_xml(toast("System busy. Please try again.", "warning")),
            status_code=423,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # Find identity containing this face
    identity = get_identity_for_face(registry, face_id)
    if not identity:
        return Response(
            to_xml(toast("Face not found in any identity.", "error")),
            status_code=404,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    identity_id = identity["identity_id"]

    # Attempt detach
    result = registry.detach_face(
        identity_id=identity_id,
        face_id=face_id,
        user_source="web",
    )

    if not result["success"]:
        error_messages = {
            "only_face": "Cannot detach: this is the only face in the identity.",
            "face_not_found": "Face not found in identity.",
        }
        message = error_messages.get(result["reason"], f"Detach failed: {result['reason']}")

        return Response(
            to_xml(toast(message, "error")),
            status_code=409,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # Save registry
    save_registry(registry)

    # Log the action
    log_user_action(
        "DETACH",
        face_id=face_id,
        from_identity_id=identity_id,
        to_identity_id=result["to_identity_id"],
    )

    # 1. Get crop files for rendering
    crop_files = get_crop_files()

    # 2. Render the NEW identity card (detached face's new home)
    new_identity = registry.get_identity(result["to_identity_id"])
    new_card_html = identity_card(
        new_identity,
        crop_files,
        lane_color="amber", # New identities are PROPOSED
        show_actions=True
    )

    # 3. Render the UPDATED old identity card (with correct face count)
    old_identity = registry.get_identity(identity_id)
    state_colors = {
        "INBOX": "blue",
        "PROPOSED": "amber",
        "CONFIRMED": "emerald",
        "CONTESTED": "red",
    }
    old_lane_color = state_colors.get(old_identity["state"], "stone")
    old_card_html = identity_card(
        old_identity,
        crop_files,
        lane_color=old_lane_color,
        show_actions=old_identity["state"] in ("INBOX", "PROPOSED"),
    )

    return (
        # A. Replace OLD identity card with updated face count
        Div(old_card_html, id=f"identity-{identity_id}", hx_swap_oob="outerHTML"),

        # B. Insert the new identity card at the top of the Proposed lane
        Div(new_card_html, hx_swap_oob="afterbegin:#proposed-lane"),

        # C. Success toast
        toast("Face moved to its own identity. Use Merge to combine them back.", "success"),
    )


# --- INSTRUMENTATION SKIP ENDPOINT ---
@rt("/api/identity/{id}/skip")
def post(id: str, sess=None):
    """Log the skip action. Requires admin."""
    denied = _check_admin(sess)
    if denied:
        return denied
    get_event_recorder().record("SKIP", {"identity_id": id})
    # No return needed as this is fire-and-forget for logging
    # The UI handles the DOM move client-side
    return Response(status_code=200)
# -------------------------------------


# =============================================================================
# ROUTES - INBOX INGESTION
# =============================================================================

@rt("/upload")
def get(sess=None):
    """
    Render the upload page. Requires login when auth is enabled.
    Non-admin uploads go through the moderation queue (pending_uploads.json).
    """
    denied = _check_login(sess)
    if denied:
        return denied
    user = get_current_user(sess or {})
    style = Style("""
        html, body {
            height: 100%;
            margin: 0;
            overflow-x: hidden;
        }
        body {
            background-color: #0f172a;
        }
        /* Mobile responsive layout */
        @media (max-width: 767px) {
            .mobile-header { display: flex !important; }
            .main-content { margin-left: 0 !important; padding-top: 3.5rem; }
            .main-content .main-inner { padding: 1rem; }
        }
        @media (min-width: 768px) and (max-width: 1023px) {
            .mobile-header { display: flex !important; }
            .main-content { margin-left: 0 !important; padding-top: 3.5rem; }
            .main-content .main-inner { padding: 1.5rem; }
        }
        @media (min-width: 1024px) {
            .mobile-header { display: none !important; }
            .main-content { margin-left: 16rem; }
        }
    """)

    # Canonical sidebar counts
    registry = load_registry()
    counts = _compute_sidebar_counts(registry)

    # Load existing sources and collections for autocomplete
    existing_sources = []
    existing_collections = []
    try:
        from core.photo_registry import PhotoRegistry
        photo_registry = PhotoRegistry.load(data_path / "photo_index.json")
        sources_set = set()
        collections_set = set()
        for photo_id in photo_registry._photos:
            source = photo_registry.get_source(photo_id)
            if source:
                sources_set.add(source)
            collection = photo_registry.get_collection(photo_id)
            if collection:
                collections_set.add(collection)
        existing_sources = sorted(sources_set)
        existing_collections = sorted(collections_set)
    except FileNotFoundError:
        pass  # No photos yet

    upload_style = Style("""
        .sidebar-container { width: 15rem; transition: width 0.2s ease, transform 0.3s ease; }
        .sidebar-container.collapsed { width: 3.5rem; }
        .sidebar-container.collapsed .sidebar-label,
        .sidebar-container.collapsed .sidebar-search,
        .sidebar-container.collapsed .sidebar-search-results { display: none; }
        .sidebar-container.collapsed .sidebar-nav-item { justify-content: center; padding-left: 0; padding-right: 0; }
        .sidebar-container.collapsed .sidebar-icon { margin: 0; }
        .sidebar-container.collapsed .sidebar-chevron { transform: rotate(180deg); }
        .sidebar-container.collapsed .sidebar-collapse-btn { margin: 0 auto; }
        .sidebar-search-results:not(:empty) { position: absolute; left: 0.75rem; right: 0.75rem; top: 100%; background: #1e293b; border: 1px solid #334155; border-radius: 0.5rem; max-height: 300px; overflow-y: auto; z-index: 50; box-shadow: 0 10px 25px rgba(0,0,0,0.5); }
        @media (max-width: 767px) {
            #sidebar { width: 15rem !important; transform: translateX(-100%); transition: transform 0.3s ease; }
            #sidebar.open { transform: translateX(0); }
            #sidebar .sidebar-label { display: inline !important; }
            #sidebar .sidebar-search { display: block !important; }
            .main-content { margin-left: 0 !important; }
        }
        @media (min-width: 768px) { #sidebar { transform: translateX(0); } }
        @media (min-width: 1024px) { .main-content { margin-left: 15rem; transition: margin-left 0.2s ease; } .main-content.sidebar-collapsed { margin-left: 3.5rem; } }
    """)
    mobile_header = Div(
        Button(
            Svg(Path(stroke_linecap="round", stroke_linejoin="round", stroke_width="2",
                     d="M4 6h16M4 12h16M4 18h16"),
                cls="w-6 h-6", fill="none", stroke="currentColor", viewBox="0 0 24 24"),
            onclick="toggleSidebar()",
            cls="p-2 text-slate-300 hover:text-white min-h-[44px] min-w-[44px] flex items-center justify-center"
        ),
        Span("Upload Photos", cls="text-lg font-bold text-white"),
        cls="mobile-header lg:hidden flex items-center gap-3 px-4 py-3 bg-slate-800 border-b border-slate-700 sticky top-0 z-30"
    )
    sidebar_overlay = Div(onclick="closeSidebar()",
                          cls="sidebar-overlay fixed inset-0 bg-black/50 z-30 hidden lg:hidden")
    sidebar_script = Script("""
        function toggleSidebar() {
            var sb = document.getElementById('sidebar');
            var ov = document.querySelector('.sidebar-overlay');
            sb.classList.toggle('open');
            sb.classList.toggle('-translate-x-full');
            ov.classList.toggle('hidden');
        }
        function closeSidebar() {
            var sb = document.getElementById('sidebar');
            var ov = document.querySelector('.sidebar-overlay');
            sb.classList.remove('open');
            sb.classList.add('-translate-x-full');
            ov.classList.add('hidden');
        }
        function toggleSidebarCollapse() {
            var sb = document.getElementById('sidebar');
            var mc = document.querySelector('.main-content');
            var isCollapsed = sb.classList.toggle('collapsed');
            if (mc) mc.classList.toggle('sidebar-collapsed', isCollapsed);
            try { localStorage.setItem('sidebar_collapsed', isCollapsed ? 'true' : 'false'); } catch(e) {}
        }
        (function() {
            try {
                var collapsed = localStorage.getItem('sidebar_collapsed') === 'true';
                if (collapsed && window.innerWidth >= 1024) {
                    var sb = document.getElementById('sidebar');
                    var mc = document.querySelector('.main-content');
                    if (sb) sb.classList.add('collapsed');
                    if (mc) mc.classList.add('sidebar-collapsed');
                }
            } catch(e) {}
        })();
    """)

    return Title("Upload Photos - Rhodesli"), style, upload_style, Div(
        toast_container(),
        mobile_header,
        sidebar_overlay,
        sidebar(counts, current_section=None, user=user),
        # Sidebar overlay for mobile
        Div(
            cls="fixed inset-0 bg-black bg-opacity-50 z-30 hidden",
            id="sidebar-overlay",
            onclick="closeSidebar()",
        ),
        Main(
            Div(
                # Header
                Div(
                    H2("Upload Photos", cls="text-2xl font-bold text-white"),
                    P("Add new photos for identity analysis", cls="text-sm text-slate-400 mt-1"),
                    cls="mb-6"
                ),
                # Upload form
                upload_area(existing_sources=existing_sources, existing_collections=existing_collections),
                cls="max-w-3xl mx-auto px-4 sm:px-8 py-6"
            ),
            cls="main-content min-h-screen overflow-x-hidden"
        ),
        sidebar_script,
        cls="h-full"
    )


@rt("/upload")
async def post(files: list[UploadFile], source: str = "", collection: str = "",
               source_url: str = "", sess=None):
    """
    Accept file upload(s) and optionally spawn subprocess for processing.
    Requires login. Non-admin uploads go to moderation queue.

    Handles multiple files (images and/or ZIPs) in a single batch job.
    All files are saved to a job directory.

    All uploads go to data/staging/{job_id}/.

    Admin flow:
        When PROCESSING_ENABLED=True (local dev):
            - Subprocess spawned to run core/ingest_inbox.py
            - Real-time status polling
        When PROCESSING_ENABLED=False (production):
            - No subprocess spawned (ML deps not available)
            - Shows "pending admin review" message

    Non-admin flow:
        - Pending upload record created in pending_uploads.json
        - Admin email notification sent (if RESEND_API_KEY configured)
        - Shows "submitted for review" message

    Args:
        files: Uploaded image files or ZIPs
        source: Provenance/origin label (e.g., "Newspapers.com")
        collection: Classification label (e.g., "Immigration Records")
        source_url: Citation URL (e.g., "https://newspapers.com/article/123")

    Returns HTML partial with upload status.
    """
    denied = _check_login(sess)
    if denied:
        return denied

    import json
    import uuid
    from datetime import datetime, timezone

    # Filter out empty uploads
    valid_files = [f for f in files if f and f.filename]

    if not valid_files:
        return Div(
            P("No files selected.", cls="text-red-600 text-sm"),
            cls="p-2"
        )

    # --- Upload safety checks ---
    MAX_FILE_SIZE = 50 * 1024 * 1024  # 50 MB per file
    MAX_BATCH_SIZE = 500 * 1024 * 1024  # 500 MB per batch
    MAX_FILES_PER_UPLOAD = 50
    ALLOWED_EXTENSIONS = {".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp", ".tiff", ".tif", ".zip"}

    if len(valid_files) > MAX_FILES_PER_UPLOAD:
        return Div(
            P(f"Too many files. Maximum {MAX_FILES_PER_UPLOAD} per upload.", cls="text-red-400 text-sm"),
            cls="p-2"
        )

    # Validate file extensions before reading content
    for f in valid_files:
        ext = Path(f.filename).suffix.lower()
        if ext not in ALLOWED_EXTENSIONS:
            return Div(
                P(f"File type '{ext}' not allowed. Accepted: images and .zip archives.", cls="text-red-400 text-sm"),
                cls="p-2"
            )

    # Determine if current user is admin
    user = get_current_user(sess or {})
    user_is_admin = user and user.is_admin if is_auth_enabled() else True
    uploader_email = user.email if user else "unknown"

    # Generate unique job ID
    job_id = str(uuid.uuid4())[:8]

    # All uploads go to staging first (processing or moderation)
    job_dir = data_path / "staging" / job_id

    job_dir.mkdir(parents=True, exist_ok=True)

    # Save all files to job directory with size checks
    saved_files = []
    total_size = 0
    for f in valid_files:
        # Sanitize filename
        safe_filename = f.filename.replace(" ", "_").replace("/", "_")
        upload_path = job_dir / safe_filename

        # Read and check file size
        content = await f.read()
        file_size = len(content)

        if file_size > MAX_FILE_SIZE:
            # Clean up job dir on failure
            import shutil
            shutil.rmtree(job_dir, ignore_errors=True)
            mb = file_size / (1024 * 1024)
            return Div(
                P(f"File '{safe_filename}' is too large ({mb:.1f} MB). Maximum is 50 MB per file.", cls="text-red-400 text-sm"),
                cls="p-2"
            )

        total_size += file_size
        if total_size > MAX_BATCH_SIZE:
            import shutil
            shutil.rmtree(job_dir, ignore_errors=True)
            return Div(
                P("Total batch size exceeds 500 MB limit.", cls="text-red-400 text-sm"),
                cls="p-2"
            )

        with open(upload_path, "wb") as out:
            out.write(content)
        saved_files.append(safe_filename)

    # Save metadata for staged uploads (helps admin know context)
    metadata = {
        "job_id": job_id,
        "source": source or "Unknown",
        "collection": collection or "",
        "source_url": source_url or "",
        "files": saved_files,
        "uploaded_at": datetime.now(timezone.utc).isoformat(),
        "processing_enabled": PROCESSING_ENABLED,
        "uploader_email": uploader_email,
    }
    metadata_path = job_dir / "_metadata.json"
    with open(metadata_path, "w") as f:
        json.dump(metadata, f, indent=2)

    # Non-admin flow: create pending upload record and notify admin
    if not user_is_admin:
        pending = _load_pending_uploads()
        pending["uploads"][job_id] = {
            "job_id": job_id,
            "uploader_email": uploader_email,
            "source": source or "Unknown",
            "collection": collection or "",
            "source_url": source_url or "",
            "files": saved_files,
            "file_count": len(saved_files),
            "submitted_at": datetime.now(timezone.utc).isoformat(),
            "status": "pending",
        }
        _save_pending_uploads(pending)

        # Fire-and-forget email notification to admin
        try:
            await _notify_admin_upload(uploader_email, job_id, len(saved_files), source)
        except Exception:
            pass  # Email notification failure should never block upload

        file_count = len(saved_files)
        file_msg = f"1 photo" if file_count == 1 else f"{file_count} photos"

        return Div(
            Div(
                Span("✓", cls="text-green-400 text-lg"),
                P(f"Submitted {file_msg} for review", cls="text-slate-200 font-medium"),
                cls="flex items-center gap-2"
            ),
            P(
                "Your upload has been submitted for admin review. "
                "You'll see the photos once they are approved and processed.",
                cls="text-slate-400 text-sm mt-1"
            ),
            P(f"Reference: {job_id}", cls="text-slate-500 text-xs mt-2 font-mono"),
            cls="p-3 bg-green-900/20 border border-green-500/30 rounded"
        )

    # Admin flow: If processing is disabled (production), stage for local processing
    if not PROCESSING_ENABLED:
        file_count = len(saved_files)
        file_msg = f"1 photo" if file_count == 1 else f"{file_count} photos"

        # Create a pending upload record so it appears on the admin pending page
        pending = _load_pending_uploads()
        pending["uploads"][job_id] = {
            "job_id": job_id,
            "uploader_email": uploader_email,
            "source": source or "Unknown",
            "collection": collection or "",
            "source_url": source_url or "",
            "files": saved_files,
            "file_count": file_count,
            "submitted_at": datetime.now(timezone.utc).isoformat(),
            "status": "staged",
        }
        _save_pending_uploads(pending)

        # Build metadata detail line
        detail_parts = []
        if collection:
            detail_parts.append(f"Collection: {collection}")
        if source:
            detail_parts.append(f"Source: {source}")
        detail_line = " · ".join(detail_parts) if detail_parts else ""

        return Div(
            Div(
                Span("✓", cls="text-green-400 text-lg"),
                P(f"{file_msg} uploaded successfully", cls="text-slate-200 font-medium"),
                cls="flex items-center gap-2"
            ),
            P(detail_line, cls="text-slate-300 text-sm mt-1") if detail_line else None,
            P(
                "Staged for processing. Run the local pipeline to detect faces and push to production.",
                cls="text-slate-400 text-sm mt-1"
            ),
            A(
                "View in Pending Uploads →",
                href="/admin/pending",
                cls="inline-block text-blue-400 hover:text-blue-300 text-sm mt-2 underline"
            ),
            P(f"Reference: {job_id}", cls="text-slate-500 text-xs mt-2 font-mono"),
            cls="p-3 bg-green-900/20 border border-green-500/30 rounded"
        )

    # Processing enabled: spawn subprocess for ML processing
    import os
    import subprocess

    # INVARIANT: All subprocesses must run from PROJECT_ROOT with cwd AND PYTHONPATH set
    subprocess_env = os.environ.copy()
    # Explicitly set PYTHONPATH to ensure core imports work in all environments
    existing_pythonpath = subprocess_env.get("PYTHONPATH", "")
    if existing_pythonpath:
        subprocess_env["PYTHONPATH"] = f"{project_root}{os.pathsep}{existing_pythonpath}"
    else:
        subprocess_env["PYTHONPATH"] = str(project_root)

    # Build subprocess arguments
    subprocess_args = [
        sys.executable,
        "-m",
        "core.ingest_inbox",
        "--directory",
        str(job_dir),
        "--job-id",
        job_id,
    ]
    if source:
        subprocess_args.extend(["--source", source])
    if collection:
        subprocess_args.extend(["--collection", collection])

    subprocess.Popen(
        subprocess_args,
        cwd=project_root,
        env=subprocess_env,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )

    # Build initial status message
    file_count = len(saved_files)
    if file_count == 1:
        msg = f"Processing {saved_files[0]}..."
    else:
        msg = f"Processing {file_count} files..."

    # Return status component that polls for completion
    return Div(
        P(msg, cls="text-slate-300 text-sm"),
        Span("\u23f3", cls="animate-pulse"),
        hx_get=f"/upload/status/{job_id}",
        hx_trigger="every 2s",
        hx_swap="outerHTML",
        cls="p-2 bg-blue-900/30 border border-blue-500/30 rounded flex items-center gap-2"
    )


@rt("/upload/status/{job_id}")
def get(job_id: str):
    """
    Poll job status for upload processing.

    Returns HTML partial with current status driven by backend job state.
    Shows real progress (% complete, files processed) and error counts.
    """
    import json

    status_path = data_path / "inbox" / f"{job_id}.status.json"

    if not status_path.exists():
        # Status file not yet created - job just started
        return Div(
            P("Starting...", cls="text-slate-300 text-sm"),
            Span("\u23f3", cls="animate-pulse"),
            hx_get=f"/upload/status/{job_id}",
            hx_trigger="every 2s",
            hx_swap="outerHTML",
            cls="p-2 bg-blue-900/30 border border-blue-500/30 rounded flex items-center gap-2"
        )

    with open(status_path) as f:
        status = json.load(f)

    if status["status"] == "processing":
        # Show real progress from job state
        total = status.get("total_files")
        succeeded = status.get("files_succeeded", 0)
        failed = status.get("files_failed", 0)
        current_file = status.get("current_file")
        faces = status.get("faces_extracted", 0)

        # Build progress message driven by actual job state
        if total and total > 0:
            processed = succeeded + failed
            pct = int((processed / total) * 100)
            progress_text = f"Processing {processed}/{total} ({pct}%)"
            if current_file:
                progress_text = f"{progress_text}: {current_file}"
            progress_elements = [
                P(progress_text, cls="text-slate-300 text-sm"),
                # Real progress bar based on actual completion
                Div(
                    Div(cls=f"h-1 bg-blue-500 rounded", style=f"width: {pct}%"),
                    cls="w-full bg-slate-700 rounded h-1 mt-1"
                ),
            ]
            if faces > 0:
                progress_elements.append(
                    P(f"{_pl(faces, 'face')} found so far", cls="text-slate-400 text-xs mt-1")
                )
        else:
            progress_elements = [
                P("Processing...", cls="text-slate-300 text-sm"),
                Span("\u23f3", cls="animate-pulse"),
            ]

        return Div(
            *progress_elements,
            hx_get=f"/upload/status/{job_id}",
            hx_trigger="every 2s",
            hx_swap="outerHTML",
            cls="p-2 bg-blue-900/30 border border-blue-500/30 rounded"
        )

    if status["status"] == "error":
        # Total failure
        error_msg = status.get("error", "Unknown error")
        errors = status.get("errors", [])

        elements = [P(f"Error: {error_msg}", cls="text-red-400 text-sm font-medium")]

        # Show per-file errors if available
        if errors:
            # UI BOUNDARY: sanitize filenames for safe rendering
            error_list = Ul(
                *[Li(f"{ensure_utf8_display(e['filename'])}: {ensure_utf8_display(e['error'])}", cls="text-xs") for e in errors[:5]],
                cls="text-red-400 mt-1 ml-4 list-disc"
            )
            elements.append(error_list)
            if len(errors) > 5:
                elements.append(P(f"... and {len(errors) - 5} more errors", cls="text-red-500 text-xs"))

        return Div(*elements, cls="p-2 bg-red-900/30 border border-red-500/30 rounded")

    if status["status"] == "partial":
        # Some files succeeded, some failed
        faces = status.get("faces_extracted", 0)
        identities = len(status.get("identities_created", []))
        total = status.get("total_files", 0)
        succeeded = status.get("files_succeeded", 0)
        failed = status.get("files_failed", 0)
        errors = status.get("errors", [])

        elements = [
            P(
                f"\u2713 {_pl(faces, 'face')} extracted from {succeeded}/{total} images",
                cls="text-amber-600 text-sm font-medium"
            ),
        ]

        # Show failure summary
        if failed > 0:
            elements.append(
                P(f"\u26a0 {failed} image(s) failed", cls="text-red-400 text-sm")
            )
            # Show first few errors
            if errors:
                # UI BOUNDARY: sanitize filenames for safe rendering
                error_summary = ", ".join(ensure_utf8_display(e["filename"]) for e in errors[:3])
                if len(errors) > 3:
                    error_summary += f", +{len(errors) - 3} more"
                elements.append(P(f"Failed: {error_summary}", cls="text-red-500 text-xs"))

        elements.append(
            A("Refresh to see inbox", href="/", cls="text-indigo-400 hover:underline text-xs mt-1 block")
        )

        return Div(*elements, cls="p-2 bg-amber-900/30 border border-amber-500/30 rounded")

    # Success (all files processed successfully)
    faces = status.get("faces_extracted", 0)
    identities = len(status.get("identities_created", []))
    total = status.get("total_files")

    success_text = f"\u2713 {_pl(faces, 'face')} extracted"
    if total and total > 1:
        success_text = f"\u2713 {_pl(faces, 'face')} extracted from {_pl(total, 'image')}"
    success_text += f", {identities} added to Inbox"

    return Div(
        P(success_text, cls="text-emerald-400 text-sm font-medium"),
        A("Refresh to see inbox", href="/", cls="text-indigo-400 hover:underline text-xs ml-2"),
        cls="p-2 bg-emerald-900/30 border border-emerald-500/30 rounded flex items-center"
    )


# =============================================================================
# ROUTES - ADMIN PENDING UPLOADS REVIEW
# =============================================================================


@rt("/admin/pending")
def get(sess=None):
    """
    Admin page to review pending uploads from non-admin users.
    Requires admin when auth is enabled.
    """
    denied = _check_admin(sess)
    if denied:
        return denied
    user = get_current_user(sess or {})

    style = Style("""
        html, body { height: 100%; margin: 0; }
        body { background-color: #0f172a; }
    """)

    # Canonical sidebar counts
    registry = load_registry()
    counts = _compute_sidebar_counts(registry)

    # Load pending uploads (both contributor "pending" and admin "staged")
    pending = _load_pending_uploads()
    pending_items = [u for u in pending["uploads"].values() if u["status"] in ("pending", "staged")]
    # Sort by submitted_at descending (newest first)
    pending_items.sort(key=lambda x: x.get("submitted_at", ""), reverse=True)

    # Also show recently reviewed items
    reviewed_items = [u for u in pending["uploads"].values() if u["status"] in ("approved", "rejected")]
    reviewed_items.sort(key=lambda x: x.get("reviewed_at", x.get("submitted_at", "")), reverse=True)
    reviewed_items = reviewed_items[:10]  # Show last 10

    # Build pending cards
    if pending_items:
        pending_cards = []
        for item in pending_items:
            job_id = item["job_id"]
            file_count = item.get("file_count", len(item.get("files", [])))
            file_msg = f"1 file" if file_count == 1 else f"{file_count} files"
            is_staged = item.get("status") == "staged"
            collection_label = item.get("collection", "")
            source_label = item.get("source", "Unknown")
            detail_parts = [file_msg]
            if collection_label:
                detail_parts.append(f"Collection: {collection_label}")
            if source_label and source_label != "Unknown":
                detail_parts.append(f"Source: {source_label}")
            detail_line = " · ".join(detail_parts)

            # Staged items (admin uploads) show status badge, no approve/reject
            # Pending items (contributor uploads) show approve/reject buttons
            if is_staged:
                actions = Div(
                    Span("Staged", cls="px-2 py-1 bg-blue-600/30 text-blue-300 text-xs font-bold rounded uppercase"),
                    Button(
                        "Mark Processed",
                        hx_post=f"/admin/pending/{job_id}/mark-processed",
                        hx_target=f"#pending-card-{job_id}",
                        hx_swap="outerHTML",
                        cls="px-3 py-1.5 bg-green-600 text-white text-xs font-medium rounded hover:bg-green-500 transition-colors"
                    ),
                    cls="flex gap-2 items-start"
                )
            else:
                actions = Div(
                    Button(
                        "Approve",
                        hx_post=f"/admin/pending/{job_id}/approve",
                        hx_target=f"#pending-card-{job_id}",
                        hx_swap="outerHTML",
                        cls="px-3 py-1.5 bg-green-600 text-white text-xs font-medium rounded hover:bg-green-500 transition-colors"
                    ),
                    Button(
                        "Reject",
                        hx_post=f"/admin/pending/{job_id}/reject",
                        hx_target=f"#pending-card-{job_id}",
                        hx_swap="outerHTML",
                        cls="px-3 py-1.5 bg-red-600 text-white text-xs font-medium rounded hover:bg-red-500 transition-colors"
                    ),
                    cls="flex gap-2 items-start"
                )

            # Photo preview thumbnails (served via admin-authenticated endpoint)
            preview_thumbs = []
            upload_files = item.get("files", [])
            from urllib.parse import quote
            for fname in upload_files[:6]:
                if fname.lower().endswith((".jpg", ".jpeg", ".png", ".webp")):
                    thumb_url = f"/admin/staging-preview/{quote(job_id)}/{quote(fname)}"
                    # Graceful fallback: show filename label if image fails to load
                    preview_thumbs.append(
                        Div(
                            Img(src=thumb_url, alt=fname, loading="lazy",
                                cls="w-16 h-16 object-cover rounded border border-slate-600",
                                title=fname,
                                onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'"),
                            Div(fname[:12], cls="w-16 h-16 bg-slate-700 border border-slate-600 rounded text-[8px] text-slate-400 items-center justify-center text-center p-1 hidden"),
                            cls="flex-shrink-0"
                        )
                    )
            remaining = len(upload_files) - 6
            if remaining > 0:
                preview_thumbs.append(
                    Div(f"+{remaining}", cls="w-16 h-16 flex items-center justify-center rounded border border-slate-600 text-slate-400 text-sm bg-slate-800")
                )
            preview_row = Div(*preview_thumbs, cls="flex gap-2 mt-3 flex-wrap") if preview_thumbs else None

            pending_cards.append(
                Div(
                    Div(
                        Div(
                            P(item.get("uploader_email", "Unknown"), cls="text-slate-200 font-medium text-sm"),
                            P(detail_line, cls="text-slate-400 text-xs"),
                            P(f"Submitted: {item.get('submitted_at', 'Unknown')[:19].replace('T', ' ')}", cls="text-slate-500 text-xs mt-0.5"),
                            P(f"Job ID: {job_id}", cls="text-slate-600 text-xs font-mono"),
                            cls="flex-1"
                        ),
                        actions,
                        cls="flex items-start justify-between gap-4"
                    ),
                    preview_row,
                    id=f"pending-card-{job_id}",
                    cls="p-4 bg-slate-800 border border-slate-700 rounded-lg"
                )
            )
        pending_section = Div(*pending_cards, cls="space-y-3")
    else:
        pending_section = Div(
            P("No pending uploads.", cls="text-slate-500 text-sm"),
            cls="p-4 bg-slate-800/50 border border-slate-700/50 rounded-lg"
        )

    # Build reviewed history cards
    if reviewed_items:
        reviewed_cards = []
        for item in reviewed_items:
            status_color = "green" if item["status"] == "approved" else "red"
            status_label = "Approved" if item["status"] == "approved" else "Rejected"
            file_count = item.get("file_count", len(item.get("files", [])))
            file_msg = f"1 file" if file_count == 1 else f"{file_count} files"
            reviewed_cards.append(
                Div(
                    Div(
                        Span(status_label, cls=f"text-{status_color}-400 text-xs font-bold uppercase"),
                        Span(" | ", cls="text-slate-600"),
                        Span(item.get("uploader_email", "Unknown"), cls="text-slate-400 text-xs"),
                        Span(f" | {file_msg}", cls="text-slate-500 text-xs"),
                        cls="flex items-center gap-1"
                    ),
                    cls="px-3 py-2 bg-slate-800/30 border border-slate-700/30 rounded"
                )
            )
        reviewed_section = Div(
            H3("Recently Reviewed", cls="text-lg font-semibold text-slate-300 mb-3 mt-6"),
            *reviewed_cards,
            cls="space-y-2"
        )
    else:
        reviewed_section = None

    # Sidebar styles (same as upload page)
    page_style = Style("""
        .sidebar-container { width: 15rem; transition: width 0.2s ease, transform 0.3s ease; }
        .sidebar-container.collapsed { width: 3.5rem; }
        .sidebar-container.collapsed .sidebar-label,
        .sidebar-container.collapsed .sidebar-search,
        .sidebar-container.collapsed .sidebar-search-results { display: none; }
        .sidebar-container.collapsed .sidebar-nav-item { justify-content: center; padding-left: 0; padding-right: 0; }
        .sidebar-container.collapsed .sidebar-icon { margin: 0; }
        .sidebar-container.collapsed .sidebar-chevron { transform: rotate(180deg); }
        .sidebar-container.collapsed .sidebar-collapse-btn { margin: 0 auto; }
        .sidebar-search-results:not(:empty) { position: absolute; left: 0.75rem; right: 0.75rem; top: 100%; background: #1e293b; border: 1px solid #334155; border-radius: 0.5rem; max-height: 300px; overflow-y: auto; z-index: 50; box-shadow: 0 10px 25px rgba(0,0,0,0.5); }
        @media (max-width: 767px) {
            #sidebar { width: 15rem !important; transform: translateX(-100%); transition: transform 0.3s ease; }
            #sidebar.open { transform: translateX(0); }
            #sidebar .sidebar-label { display: inline !important; }
            #sidebar .sidebar-search { display: block !important; }
            .main-content { margin-left: 0 !important; }
        }
        @media (min-width: 768px) { #sidebar { transform: translateX(0); } }
        @media (min-width: 1024px) { .main-content { margin-left: 15rem; transition: margin-left 0.2s ease; } .main-content.sidebar-collapsed { margin-left: 3.5rem; } }
    """)
    mobile_header = Div(
        Button(
            Svg(Path(stroke_linecap="round", stroke_linejoin="round", stroke_width="2",
                     d="M4 6h16M4 12h16M4 18h16"),
                cls="w-6 h-6", fill="none", stroke="currentColor", viewBox="0 0 24 24"),
            onclick="toggleSidebar()",
            cls="p-2 text-slate-300 hover:text-white min-h-[44px] min-w-[44px] flex items-center justify-center"
        ),
        Span("Pending Uploads", cls="text-lg font-bold text-white"),
        cls="mobile-header lg:hidden flex items-center gap-3 px-4 py-3 bg-slate-800 border-b border-slate-700 sticky top-0 z-30"
    )
    sidebar_overlay = Div(onclick="closeSidebar()",
                          cls="sidebar-overlay fixed inset-0 bg-black/50 z-30 hidden lg:hidden")
    sidebar_script = Script("""
        function toggleSidebar() {
            var sb = document.getElementById('sidebar');
            var ov = document.querySelector('.sidebar-overlay');
            sb.classList.toggle('open');
            sb.classList.toggle('-translate-x-full');
            ov.classList.toggle('hidden');
        }
        function closeSidebar() {
            var sb = document.getElementById('sidebar');
            var ov = document.querySelector('.sidebar-overlay');
            sb.classList.remove('open');
            sb.classList.add('-translate-x-full');
            ov.classList.add('hidden');
        }
        function toggleSidebarCollapse() {
            var sb = document.getElementById('sidebar');
            var mc = document.querySelector('.main-content');
            var isCollapsed = sb.classList.toggle('collapsed');
            if (mc) mc.classList.toggle('sidebar-collapsed', isCollapsed);
            try { localStorage.setItem('sidebar_collapsed', isCollapsed ? 'true' : 'false'); } catch(e) {}
        }
        (function() {
            try {
                var collapsed = localStorage.getItem('sidebar_collapsed') === 'true';
                if (collapsed && window.innerWidth >= 1024) {
                    var sb = document.getElementById('sidebar');
                    var mc = document.querySelector('.main-content');
                    if (sb) sb.classList.add('collapsed');
                    if (mc) mc.classList.add('sidebar-collapsed');
                }
            } catch(e) {}
        })();
    """)

    return Title("Pending Uploads - Rhodesli"), style, page_style, Div(
        toast_container(),
        mobile_header,
        sidebar_overlay,
        sidebar(counts, current_section="pending_uploads", user=user),
        Main(
            Div(
                # Header
                Div(
                    H2("Pending Uploads", cls="text-2xl font-bold text-white"),
                    P(f"{len(pending_items)} upload{'s' if len(pending_items) != 1 else ''} awaiting review", cls="text-sm text-slate-400 mt-1"),
                    cls="mb-6"
                ),
                pending_section,
                reviewed_section if reviewed_section else "",
                cls="max-w-3xl mx-auto px-4 sm:px-8 py-6"
            ),
            cls="main-content min-h-screen overflow-x-hidden"
        ),
        sidebar_script,
        cls="h-full"
    )


@rt("/admin/proposals")
def get(sess=None):
    """
    Admin page to review proposed identity matches.
    Requires admin when auth is enabled.
    """
    denied = _check_admin(sess)
    if denied:
        return denied
    user = get_current_user(sess or {})

    style = Style("""
        html, body { height: 100%; margin: 0; }
        body { background-color: #0f172a; }
    """)

    # Canonical sidebar counts
    registry = load_registry()
    counts = _compute_sidebar_counts(registry)

    # Sidebar styles (reuse)
    page_style = Style("""
        .sidebar-container { width: 15rem; transition: width 0.2s ease, transform 0.3s ease; }
        .sidebar-container.collapsed { width: 3.5rem; }
        .sidebar-container.collapsed .sidebar-label,
        .sidebar-container.collapsed .sidebar-search,
        .sidebar-container.collapsed .sidebar-search-results { display: none; }
        .sidebar-container.collapsed .sidebar-nav-item { justify-content: center; padding-left: 0; padding-right: 0; }
        .sidebar-container.collapsed .sidebar-icon { margin: 0; }
        .sidebar-container.collapsed .sidebar-chevron { transform: rotate(180deg); }
        .sidebar-container.collapsed .sidebar-collapse-btn { margin: 0 auto; }
        .sidebar-search-results:not(:empty) { position: absolute; left: 0.75rem; right: 0.75rem; top: 100%; background: #1e293b; border: 1px solid #334155; border-radius: 0.5rem; max-height: 300px; overflow-y: auto; z-index: 50; box-shadow: 0 10px 25px rgba(0,0,0,0.5); }
        @media (max-width: 767px) {
            #sidebar { width: 15rem !important; transform: translateX(-100%); transition: transform 0.3s ease; }
            #sidebar.open { transform: translateX(0); }
            #sidebar .sidebar-label { display: inline !important; }
            #sidebar .sidebar-search { display: block !important; }
            .main-content { margin-left: 0 !important; }
        }
        @media (min-width: 768px) { #sidebar { transform: translateX(0); } }
        @media (min-width: 1024px) { .main-content { margin-left: 15rem; transition: margin-left 0.2s ease; } .main-content.sidebar-collapsed { margin-left: 3.5rem; } }
    """)
    mobile_header = Div(
        Button(
            Svg(Path(stroke_linecap="round", stroke_linejoin="round", stroke_width="2",
                     d="M4 6h16M4 12h16M4 18h16"),
                cls="w-6 h-6", fill="none", stroke="currentColor", viewBox="0 0 24 24"),
            onclick="toggleSidebar()",
            cls="p-2 text-slate-300 hover:text-white min-h-[44px] min-w-[44px] flex items-center justify-center"
        ),
        Span("Proposals", cls="text-lg font-bold text-white"),
        cls="mobile-header lg:hidden flex items-center gap-3 px-4 py-3 bg-slate-800 border-b border-slate-700 sticky top-0 z-30"
    )
    sidebar_overlay = Div(onclick="closeSidebar()",
                          cls="sidebar-overlay fixed inset-0 bg-black/50 z-30 hidden lg:hidden")
    sidebar_script = Script("""
        function toggleSidebar() {
            var sb = document.getElementById('sidebar');
            var ov = document.querySelector('.sidebar-overlay');
            sb.classList.toggle('open');
            sb.classList.toggle('-translate-x-full');
            ov.classList.toggle('hidden');
        }
        function closeSidebar() {
            var sb = document.getElementById('sidebar');
            var ov = document.querySelector('.sidebar-overlay');
            sb.classList.remove('open');
            sb.classList.add('-translate-x-full');
            ov.classList.add('hidden');
        }
        function toggleSidebarCollapse() {
            var sb = document.getElementById('sidebar');
            var mc = document.querySelector('.main-content');
            var isCollapsed = sb.classList.toggle('collapsed');
            if (mc) mc.classList.toggle('sidebar-collapsed', isCollapsed);
            try { localStorage.setItem('sidebar_collapsed', isCollapsed ? 'true' : 'false'); } catch(e) {}
        }
        (function() {
            try {
                var collapsed = localStorage.getItem('sidebar_collapsed') === 'true';
                if (collapsed && window.innerWidth >= 1024) {
                    var sb = document.getElementById('sidebar');
                    var mc = document.querySelector('.main-content');
                    if (sb) sb.classList.add('collapsed');
                    if (mc) mc.classList.add('sidebar-collapsed');
                }
            } catch(e) {}
        })();
    """)

    return Title("Proposals - Rhodesli"), style, page_style, Div(
        toast_container(),
        mobile_header,
        sidebar_overlay,
        sidebar(counts, current_section="proposals", user=user),
        Main(
            Div(
                Div(
                    H2("Proposed Matches", cls="text-2xl font-bold text-white"),
                    P(f"{counts['proposals']} pending proposal{'s' if counts['proposals'] != 1 else ''}", cls="text-sm text-slate-400 mt-1"),
                    cls="mb-6"
                ),
                # Load proposals list via HTMX on page load
                Div(
                    id="proposed-matches-list",
                    hx_get="/api/proposed-matches",
                    hx_trigger="load",
                    hx_swap="innerHTML",
                ),
                cls="max-w-3xl mx-auto px-4 sm:px-8 py-6"
            ),
            cls="main-content min-h-screen overflow-x-hidden"
        ),
        sidebar_script,
        cls="h-full"
    )


@rt("/admin/pending/{job_id}/approve")
def post(job_id: str, sess=None):
    """Approve a pending upload. Requires admin."""
    denied = _check_admin(sess)
    if denied:
        return denied

    pending = _load_pending_uploads()
    if job_id not in pending["uploads"]:
        return Div(
            P("Upload not found.", cls="text-red-400 text-sm"),
            cls="p-3 bg-red-900/20 border border-red-500/30 rounded-lg"
        )

    upload = pending["uploads"][job_id]
    if upload["status"] != "pending":
        return Div(
            P(f"Upload already {upload['status']}.", cls="text-slate-400 text-sm"),
            cls="p-3 bg-slate-800/50 border border-slate-700/50 rounded-lg"
        )

    # Update status to approved
    upload["status"] = "approved"
    upload["reviewed_at"] = datetime.now(timezone.utc).isoformat()
    user = get_current_user(sess or {})
    upload["reviewed_by"] = user.email if user else "unknown"
    _save_pending_uploads(pending)
    log_user_action("APPROVE_UPLOAD", job_id=job_id,
                    uploader=upload.get("uploaded_by", "unknown"),
                    file_count=len(upload.get("files", [])),
                    admin=user.email if user else "unknown")

    # If PROCESSING_ENABLED, move files from staging to uploads and spawn processing
    if PROCESSING_ENABLED:
        import shutil
        staging_dir = data_path / "staging" / job_id
        uploads_dir = data_path / "uploads" / job_id
        if staging_dir.exists():
            uploads_dir.parent.mkdir(parents=True, exist_ok=True)
            shutil.copytree(staging_dir, uploads_dir, dirs_exist_ok=True)

            # Spawn processing subprocess (same as admin upload flow)
            import os
            import subprocess
            subprocess_env = os.environ.copy()
            existing_pythonpath = subprocess_env.get("PYTHONPATH", "")
            if existing_pythonpath:
                subprocess_env["PYTHONPATH"] = f"{project_root}{os.pathsep}{existing_pythonpath}"
            else:
                subprocess_env["PYTHONPATH"] = str(project_root)

            source = upload.get("source", "")
            upload_collection = upload.get("collection", "")
            subprocess_args = [
                sys.executable, "-m", "core.ingest_inbox",
                "--directory", str(uploads_dir),
                "--job-id", job_id,
            ]
            if source:
                subprocess_args.extend(["--source", source])
            if upload_collection:
                subprocess_args.extend(["--collection", upload_collection])

            subprocess.Popen(
                subprocess_args,
                cwd=project_root,
                env=subprocess_env,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )

    file_count = upload.get("file_count", len(upload.get("files", [])))
    return Div(
        Div(
            Span("Approved", cls="text-green-400 text-xs font-bold uppercase"),
            Span(" | ", cls="text-slate-600"),
            Span(upload.get("uploader_email", "Unknown"), cls="text-slate-400 text-xs"),
            Span(f" | {file_count} file{'s' if file_count != 1 else ''}", cls="text-slate-500 text-xs"),
            cls="flex items-center gap-1"
        ),
        cls="p-3 bg-green-900/20 border border-green-500/30 rounded-lg"
    )


@rt("/admin/pending/{job_id}/reject")
def post(job_id: str, sess=None):
    """Reject a pending upload. Requires admin."""
    denied = _check_admin(sess)
    if denied:
        return denied

    pending = _load_pending_uploads()
    if job_id not in pending["uploads"]:
        return Div(
            P("Upload not found.", cls="text-red-400 text-sm"),
            cls="p-3 bg-red-900/20 border border-red-500/30 rounded-lg"
        )

    upload = pending["uploads"][job_id]
    if upload["status"] != "pending":
        return Div(
            P(f"Upload already {upload['status']}.", cls="text-slate-400 text-sm"),
            cls="p-3 bg-slate-800/50 border border-slate-700/50 rounded-lg"
        )

    # Update status to rejected
    upload["status"] = "rejected"
    upload["reviewed_at"] = datetime.now(timezone.utc).isoformat()
    user = get_current_user(sess or {})
    upload["reviewed_by"] = user.email if user else "unknown"
    _save_pending_uploads(pending)
    log_user_action("REJECT_UPLOAD", job_id=job_id,
                    uploader=upload.get("uploaded_by", "unknown"),
                    admin=user.email if user else "unknown")

    # Optionally clean up staging files
    import shutil
    staging_dir = data_path / "staging" / job_id
    if staging_dir.exists():
        shutil.rmtree(staging_dir, ignore_errors=True)

    file_count = upload.get("file_count", len(upload.get("files", [])))
    return Div(
        Div(
            Span("Rejected", cls="text-red-400 text-xs font-bold uppercase"),
            Span(" | ", cls="text-slate-600"),
            Span(upload.get("uploader_email", "Unknown"), cls="text-slate-400 text-xs"),
            Span(f" | {file_count} file{'s' if file_count != 1 else ''}", cls="text-slate-500 text-xs"),
            cls="flex items-center gap-1"
        ),
        cls="p-3 bg-red-900/20 border border-red-500/30 rounded-lg"
    )


@rt("/admin/pending/{job_id}/mark-processed")
def post(job_id: str, sess=None):
    """Mark a staged upload as processed. Requires admin."""
    denied = _check_admin(sess)
    if denied:
        return denied

    pending = _load_pending_uploads()
    if job_id not in pending["uploads"]:
        return Div(
            P("Upload not found.", cls="text-red-400 text-sm"),
            cls="p-3 bg-red-900/20 border border-red-500/30 rounded-lg"
        )

    upload = pending["uploads"][job_id]
    if upload["status"] != "staged":
        return Div(
            P(f"Upload already {upload['status']}.", cls="text-slate-400 text-sm"),
            cls="p-3 bg-slate-800/50 border border-slate-700/50 rounded-lg"
        )

    upload["status"] = "processed"
    upload["processed_at"] = datetime.now(timezone.utc).isoformat()
    user = get_current_user(sess or {})
    upload["processed_by"] = user.email if user else "unknown"
    _save_pending_uploads(pending)

    file_count = upload.get("file_count", len(upload.get("files", [])))
    return Div(
        Div(
            Span("Processed", cls="text-green-400 text-xs font-bold uppercase"),
            Span(" | ", cls="text-slate-600"),
            Span(upload.get("uploader_email", "Unknown"), cls="text-slate-400 text-xs"),
            Span(f" | {file_count} file{'s' if file_count != 1 else ''}", cls="text-slate-500 text-xs"),
            cls="flex items-center gap-1"
        ),
        cls="p-3 bg-green-900/20 border border-green-500/30 rounded-lg"
    )


@app.get("/admin/staging-preview/{job_id}/{filename:path}")
async def admin_staging_preview(job_id: str, filename: str, sess=None):
    """Serve staged upload photos for admin preview. Session-authenticated."""
    denied = _check_admin(sess)
    if denied:
        return Response("Unauthorized", status_code=401)

    # Security: block path traversal
    if ".." in job_id or ".." in filename or job_id.startswith("/") or filename.startswith("/"):
        return Response("Invalid path", status_code=400)

    staging_dir = data_path / "staging"
    target = (staging_dir / job_id / filename).resolve()

    # Ensure resolved path is still inside staging dir
    if not str(target).startswith(str(staging_dir.resolve())):
        return Response("Invalid path", status_code=400)

    if not target.exists() or not target.is_file():
        return Response("File not found", status_code=404)

    # Determine content type from extension
    ext = target.suffix.lower()
    content_types = {".jpg": "image/jpeg", ".jpeg": "image/jpeg", ".png": "image/png", ".webp": "image/webp"}
    content_type = content_types.get(ext, "application/octet-stream")

    return FileResponse(str(target), media_type=content_type)

# Move staging preview route before FastHTML's catch-all static route
for i, route in enumerate(app.routes):
    if getattr(route, "path", None) == "/admin/staging-preview/{job_id}/{filename:path}":
        _staging_route = app.routes.pop(i)
        app.routes.insert(0, _staging_route)
        break


# =============================================================================
# ROUTES - INBOX REVIEW (existing)
# =============================================================================


@rt("/inbox/{identity_id}/review")
def post(identity_id: str, sess=None):
    """Move identity from INBOX to PROPOSED state. Requires admin."""
    denied = _check_admin(sess)
    if denied:
        return denied
    try:
        registry = load_registry()
    except Exception:
        return Response(
            to_xml(toast("System busy. Please try again.", "warning")),
            status_code=423,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    try:
        registry.get_identity(identity_id)
    except KeyError:
        return Response(
            to_xml(toast("Identity not found.", "error")),
            status_code=404,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    try:
        registry.move_to_proposed(identity_id, user_source="web")
        save_registry(registry)
    except ValueError as e:
        return Response(
            to_xml(toast(str(e), "error")),
            status_code=400,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    crop_files = get_crop_files()
    updated_identity = registry.get_identity(identity_id)

    # Return updated card (now PROPOSED, with full action buttons)
    return (
        identity_card(updated_identity, crop_files, lane_color="amber", show_actions=True),
        toast("Moved to Proposed for review.", "success"),
    )


@rt("/inbox/{identity_id}/confirm")
def post(identity_id: str, from_focus: bool = False, filter: str = "", sess=None):
    """Confirm identity from INBOX state (INBOX -> CONFIRMED). Requires admin."""
    denied = _check_admin(sess)
    if denied:
        return denied
    try:
        registry = load_registry()
    except Exception:
        return Response(
            to_xml(toast("System busy. Please try again.", "warning")),
            status_code=423,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    try:
        registry.get_identity(identity_id)
    except KeyError:
        return Response(
            to_xml(toast("Identity not found.", "error")),
            status_code=404,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    try:
        registry.confirm_identity(identity_id, user_source="web_review")
        save_registry(registry)
    except ValueError as e:
        return Response(
            to_xml(toast(str(e), "error")),
            status_code=400,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # If from focus mode, return the next focus card
    if from_focus:
        return (
            get_next_focus_card(exclude_id=identity_id, triage_filter=filter),
            toast("Identity confirmed.", "success"),
        )

    crop_files = get_crop_files()
    updated_identity = registry.get_identity(identity_id)

    # Return updated card (now CONFIRMED)
    return (
        identity_card(updated_identity, crop_files, lane_color="emerald", show_actions=False),
        toast("Identity confirmed.", "success"),
    )


@rt("/inbox/{identity_id}/reject")
def post(identity_id: str, from_focus: bool = False, filter: str = "", sess=None):
    """Reject identity from INBOX state (INBOX -> REJECTED). Requires admin."""
    denied = _check_admin(sess)
    if denied:
        return denied
    try:
        registry = load_registry()
    except Exception:
        return Response(
            to_xml(toast("System busy. Please try again.", "warning")),
            status_code=423,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    try:
        registry.get_identity(identity_id)
    except KeyError:
        return Response(
            to_xml(toast("Identity not found.", "error")),
            status_code=404,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    try:
        registry.reject_identity(identity_id, user_source="web_review")
        save_registry(registry)
    except ValueError as e:
        return Response(
            to_xml(toast(str(e), "error")),
            status_code=400,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # If from focus mode, return the next focus card
    if from_focus:
        return (
            get_next_focus_card(exclude_id=identity_id, triage_filter=filter),
            toast("Identity rejected.", "success"),
        )

    crop_files = get_crop_files()
    updated_identity = registry.get_identity(identity_id)

    # Return updated card (now REJECTED)
    return (
        identity_card(updated_identity, crop_files, lane_color="rose", show_actions=False),
        toast("Identity rejected.", "success"),
    )


@rt("/identity/{identity_id}/skip")
def post(identity_id: str, from_focus: bool = False, filter: str = "", sess=None):
    """
    Skip identity (defer for later review). Requires admin.

    Works from INBOX or PROPOSED state -> SKIPPED.
    """
    denied = _check_admin(sess)
    if denied:
        return denied
    try:
        registry = load_registry()
    except Exception:
        return Response(
            to_xml(toast("System busy. Please try again.", "warning")),
            status_code=423,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    try:
        registry.get_identity(identity_id)
    except KeyError:
        return Response(
            to_xml(toast("Identity not found.", "error")),
            status_code=404,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    try:
        registry.skip_identity(identity_id, user_source="web_review")
        save_registry(registry)
    except ValueError as e:
        return Response(
            to_xml(toast(str(e), "error")),
            status_code=400,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    # If from focus mode, return the next focus card
    if from_focus:
        return (
            get_next_focus_card(exclude_id=identity_id, triage_filter=filter),
            toast("Skipped for later.", "info"),
        )

    crop_files = get_crop_files()
    updated_identity = registry.get_identity(identity_id)

    return (
        identity_card(updated_identity, crop_files, lane_color="stone", show_actions=False),
        toast("Skipped for later.", "info"),
    )


# =============================================================================
# ROUTES — SKIPPED FOCUS MODE ACTIONS
# =============================================================================

@rt("/api/skipped/{identity_id}/focus-skip")
def post(identity_id: str, sess=None):
    """Advance to next identity in skipped focus mode without taking action."""
    denied = _check_admin(sess)
    if denied:
        return denied
    return (
        get_next_skipped_focus_card(exclude_id=identity_id),
        toast("Skipped for now.", "info"),
    )


@rt("/api/skipped/{identity_id}/reject-suggestion")
def post(identity_id: str, suggestion_id: str = "", sess=None):
    """Reject a suggestion for a skipped identity and advance to next."""
    denied = _check_admin(sess)
    if denied:
        return denied

    if suggestion_id:
        try:
            registry = load_registry()
            registry.reject_identity_pair(identity_id, suggestion_id, user_source="skipped_focus")
            save_registry(registry)
        except (KeyError, ValueError):
            # If reject fails, just advance — don't block the user
            pass

    # Toast with undo for reject action
    reject_toast = Div(
        Span("✗", cls="mr-2"),
        Span("Suggestion rejected. Moving to next.", cls="flex-1"),
        Button(
            "Undo",
            cls="ml-3 px-2 py-1 text-xs font-bold bg-white/20 hover:bg-white/30 rounded transition-colors",
            hx_post=f"/api/identity/{identity_id}/unreject/{suggestion_id}",
            hx_swap="outerHTML",
            hx_target="closest div",
            type="button",
        ) if suggestion_id else None,
        cls="px-4 py-3 rounded shadow-lg flex items-center bg-amber-600 text-white animate-fade-in",
        **{"_": "on load wait 8s then remove me"},
    )

    return (
        get_next_skipped_focus_card(exclude_id=identity_id),
        reject_toast,
    )


@rt("/api/skipped/{identity_id}/name-and-confirm")
def post(identity_id: str, name: str = "", sess=None):
    """Name a skipped identity and confirm it, then advance to next in focus mode."""
    denied = _check_admin(sess)
    if denied:
        return denied

    name = name.strip()
    if not name:
        return Response(
            to_xml(toast("Please enter a name.", "warning")),
            status_code=400,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    try:
        registry = load_registry()
        registry.rename_identity(identity_id, name, user_source="web_review")
        registry.confirm_identity(identity_id, user_source="web_review")
        save_registry(registry)
    except (KeyError, ValueError) as e:
        return Response(
            to_xml(toast(f"Cannot confirm: {str(e)}", "error")),
            status_code=400,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    log_user_action("CONFIRM_NAMED", identity_id=identity_id, name=name)

    return (
        get_next_skipped_focus_card(exclude_id=identity_id),
        toast(f"Confirmed as {name}!", "success"),
    )


@rt("/identity/{identity_id}/reset")
def post(identity_id: str, sess=None):
    """Reset identity back to Inbox. Requires admin."""
    denied = _check_admin(sess)
    if denied:
        return denied
    try:
        registry = load_registry()
    except Exception:
        return Response(
            to_xml(toast("System busy. Please try again.", "warning")),
            status_code=423,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    try:
        registry.get_identity(identity_id)
    except KeyError:
        return Response(
            to_xml(toast("Identity not found.", "error")),
            status_code=404,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    try:
        registry.reset_identity(identity_id, user_source="web_review")
        save_registry(registry)
    except ValueError as e:
        return Response(
            to_xml(toast(str(e), "error")),
            status_code=400,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    crop_files = get_crop_files()
    updated_identity = registry.get_identity(identity_id)

    return (
        identity_card(updated_identity, crop_files, lane_color="blue", show_actions=True),
        toast("Returned to Inbox.", "info"),
    )


# =============================================================================
# AUTHENTICATION ROUTES
# =============================================================================

@rt("/login")
def get(sess, next: str = ""):
    """Login page. Redirects to home if already authenticated or auth disabled."""
    if not is_auth_enabled():
        return RedirectResponse('/', status_code=303)
    if sess.get('auth'):
        return RedirectResponse(next or '/', status_code=303)

    # Build POST action with ?next= if provided
    post_action = "/login"
    if next:
        post_action = f"/login?next={next}"

    return Html(
        Head(
            Meta(name="viewport", content="width=device-width, initial-scale=1"),
            Title("Login - Rhodesli"),
            Meta(name="viewport", content="width=device-width, initial-scale=1"),
            Script(src="https://cdn.tailwindcss.com"),
        ),
        Body(
            Div(
                H1("Rhodesli", cls="text-2xl font-bold mb-2"),
                P("Family Heritage Archive", cls="text-gray-400 mb-8"),
                Form(
                    Div(
                        Label("Email", fr="email", cls="block text-sm mb-1"),
                        Input(type="email", name="email", id="email", required=True,
                              cls="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"),
                        cls="mb-4"
                    ),
                    Div(
                        Label("Password", fr="password", cls="block text-sm mb-1"),
                        Input(type="password", name="password", id="password", required=True,
                              cls="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"),
                        cls="mb-4"
                    ),
                    Button("Sign In", type="submit",
                           cls="w-full p-2 bg-blue-600 hover:bg-blue-700 rounded text-white font-medium"),
                    method="post", action=post_action, cls="space-y-2"
                ),
                Div(
                    Div(cls="flex-grow border-t border-gray-600"),
                    Span("or", cls="px-4 text-gray-500 text-sm"),
                    Div(cls="flex-grow border-t border-gray-600"),
                    cls="flex items-center my-6"
                ) if get_oauth_url("google") else None,
                A(
                    NotStr('<svg viewBox="0 0 24 24" width="18" height="18" xmlns="http://www.w3.org/2000/svg"><path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92a5.06 5.06 0 0 1-2.2 3.32v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.1z" fill="#4285F4"/><path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/><path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/><path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/></svg>'),
                    Span("Sign in with Google"),
                    href=get_oauth_url("google") or "#",
                    style="display: flex; align-items: center; gap: 12px; padding: 0 16px; height: 40px; "
                          "background: white; border: 1px solid #dadce0; border-radius: 4px; cursor: pointer; "
                          "font-family: 'Roboto', Arial, sans-serif; font-size: 14px; color: #3c4043; "
                          "font-weight: 500; text-decoration: none; justify-content: center; width: 100%;",
                ) if get_oauth_url("google") else None,
                P(
                    A("Forgot password?", href="/forgot-password", cls="text-blue-400 hover:underline"),
                    cls="mt-4 text-center text-sm"
                ),
                P(
                    "Need an account? ",
                    A("Sign up with invite code", href="/signup", cls="text-blue-400 hover:underline"),
                    cls="mt-2 text-gray-400 text-sm"
                ),
                cls="max-w-md mx-auto mt-10 sm:mt-20 p-4 sm:p-8 bg-gray-800 rounded-lg"
            ),
            cls="min-h-screen bg-gray-900 text-white"
        ),
    )


@rt("/login")
async def post(email: str, password: str, sess, next: str = ""):
    """Handle login form submission."""
    user, error = await login_with_supabase(email, password)
    if error:
        return Html(
            Head(
                Meta(name="viewport", content="width=device-width, initial-scale=1"),
                Title("Login - Rhodesli"),
                Script(src="https://cdn.tailwindcss.com"),
            ),
            Body(
                Div(
                    H1("Rhodesli", cls="text-2xl font-bold mb-2"),
                    P(error, cls="text-red-400 mb-4 text-sm"),
                    Form(
                        Div(Label("Email", fr="email", cls="block text-sm mb-1"),
                            Input(type="email", name="email", id="email", value=email, required=True,
                                  cls="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"), cls="mb-4"),
                        Div(Label("Password", fr="password", cls="block text-sm mb-1"),
                            Input(type="password", name="password", id="password", required=True,
                                  cls="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"), cls="mb-4"),
                        Button("Sign In", type="submit", cls="w-full p-2 bg-blue-600 hover:bg-blue-700 rounded text-white font-medium"),
                        method="post", action="/login",
                    ),
                    cls="max-w-md mx-auto mt-10 sm:mt-20 p-4 sm:p-8 bg-gray-800 rounded-lg"
                ),
                cls="min-h-screen bg-gray-900 text-white"
            ),
        )
    sess['auth'] = user
    # Redirect to the page they were trying to reach, or home
    redirect_to = next if next and next.startswith('/') else '/'
    return RedirectResponse(redirect_to, status_code=303)


@rt("/login/modal")
async def post(email: str, password: str, sess):
    """Handle login from the modal context. Returns error text or HX-Refresh on success."""
    user, error = await login_with_supabase(email, password)
    if error:
        return error
    sess['auth'] = user
    return Response("", headers={"HX-Refresh": "true"})


@rt("/signup")
def get(sess):
    """Signup page with invite code."""
    if not is_auth_enabled():
        return RedirectResponse('/', status_code=303)
    if sess.get('auth'):
        return RedirectResponse('/', status_code=303)

    return Html(
        Head(
            Meta(name="viewport", content="width=device-width, initial-scale=1"),
            Title("Sign Up - Rhodesli"),
            Script(src="https://cdn.tailwindcss.com"),
        ),
        Body(
            Div(
                H1("Join Rhodesli", cls="text-2xl font-bold mb-2"),
                P("Invite-only registration", cls="text-gray-400 mb-8"),
                Form(
                    Div(
                        Label("Invite Code", fr="invite_code", cls="block text-sm mb-1"),
                        Input(type="text", name="invite_code", id="invite_code", required=True,
                              cls="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"),
                        cls="mb-4"
                    ),
                    Div(
                        Label("Email", fr="email", cls="block text-sm mb-1"),
                        Input(type="email", name="email", id="email", required=True,
                              cls="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"),
                        cls="mb-4"
                    ),
                    Div(
                        Label("Password", fr="password", cls="block text-sm mb-1"),
                        Input(type="password", name="password", id="password", required=True, minlength="8",
                              cls="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"),
                        P("Minimum 8 characters", cls="text-gray-500 text-xs mt-1"),
                        cls="mb-4"
                    ),
                    Button("Create Account", type="submit",
                           cls="w-full p-2 bg-green-600 hover:bg-green-700 rounded text-white font-medium"),
                    method="post", action="/signup",
                ),
                P(
                    "Already have an account? ",
                    A("Sign in", href="/login", cls="text-blue-400 hover:underline"),
                    cls="mt-4 text-gray-400 text-sm"
                ),
                cls="max-w-md mx-auto mt-10 sm:mt-20 p-4 sm:p-8 bg-gray-800 rounded-lg"
            ),
            cls="min-h-screen bg-gray-900 text-white"
        ),
    )


@rt("/signup")
async def post(email: str, password: str, invite_code: str, sess):
    """Handle signup form submission."""
    if not validate_invite_code(invite_code):
        error = "Invalid invite code"
        user = None
    else:
        user, error = await signup_with_supabase(email, password)
    if error:
        return Html(
            Head(Meta(name="viewport", content="width=device-width, initial-scale=1"), Title("Sign Up - Rhodesli"), Script(src="https://cdn.tailwindcss.com")),
            Body(
                Div(
                    H1("Join Rhodesli", cls="text-2xl font-bold mb-2"),
                    P(error, cls="text-red-400 mb-4 text-sm"),
                    Form(
                        Div(Label("Invite Code", fr="invite_code", cls="block text-sm mb-1"),
                            Input(type="text", name="invite_code", id="invite_code", value=invite_code, required=True,
                                  cls="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"), cls="mb-4"),
                        Div(Label("Email", fr="email", cls="block text-sm mb-1"),
                            Input(type="email", name="email", id="email", value=email, required=True,
                                  cls="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"), cls="mb-4"),
                        Div(Label("Password", fr="password", cls="block text-sm mb-1"),
                            Input(type="password", name="password", id="password", required=True, minlength="8",
                                  cls="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"), cls="mb-4"),
                        Button("Create Account", type="submit",
                               cls="w-full p-2 bg-green-600 hover:bg-green-700 rounded text-white font-medium"),
                        method="post", action="/signup",
                    ),
                    cls="max-w-md mx-auto mt-10 sm:mt-20 p-4 sm:p-8 bg-gray-800 rounded-lg"
                ),
                cls="min-h-screen bg-gray-900 text-white"
            ),
        )
    sess['auth'] = user
    return RedirectResponse('/', status_code=303)


@rt("/forgot-password")
def get(sess):
    """Forgot password page."""
    if not is_auth_enabled():
        return RedirectResponse('/', status_code=303)

    return Html(
        Head(
            Meta(name="viewport", content="width=device-width, initial-scale=1"),
            Title("Reset Password - Rhodesli"),
            Script(src="https://cdn.tailwindcss.com"),
        ),
        Body(
            Div(
                H1("Reset Password", cls="text-2xl font-bold mb-2"),
                P("Enter your email to receive a reset link", cls="text-gray-400 mb-6"),
                Form(
                    Div(
                        Label("Email", fr="email", cls="block text-sm mb-1"),
                        Input(type="email", name="email", id="email", required=True,
                              cls="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"),
                        cls="mb-4"
                    ),
                    Button("Send Reset Link", type="submit",
                           cls="w-full p-2 bg-blue-600 hover:bg-blue-700 rounded text-white font-medium"),
                    method="post", action="/forgot-password",
                ),
                P(
                    A("← Back to Login", href="/login", cls="text-blue-400 hover:underline"),
                    cls="mt-6 text-center"
                ),
                cls="max-w-md mx-auto mt-10 sm:mt-20 p-4 sm:p-8 bg-gray-800 rounded-lg"
            ),
            cls="min-h-screen bg-gray-900 text-white"
        ),
    )


@rt("/forgot-password")
async def post(email: str, sess):
    """Handle forgot password form."""
    success, error = await send_password_reset(email)

    # Always show success message to avoid email enumeration
    msg = "If an account exists with that email, you'll receive a reset link."
    return Html(
        Head(
            Meta(name="viewport", content="width=device-width, initial-scale=1"),
            Title("Reset Password - Rhodesli"),
            Script(src="https://cdn.tailwindcss.com"),
        ),
        Body(
            Div(
                H1("Reset Password", cls="text-2xl font-bold mb-2"),
                P(msg, cls="text-green-400 mb-6 text-sm"),
                P(
                    A("← Back to Login", href="/login", cls="text-blue-400 hover:underline"),
                    cls="mt-6 text-center"
                ),
                cls="max-w-md mx-auto mt-10 sm:mt-20 p-4 sm:p-8 bg-gray-800 rounded-lg"
            ),
            cls="min-h-screen bg-gray-900 text-white"
        ),
    )


@rt("/reset-password")
def get(sess):
    """Handle reset password callback from email link. Tokens are in URL fragment."""
    return Html(
        Head(
            Meta(name="viewport", content="width=device-width, initial-scale=1"),
            Title("Set New Password - Rhodesli"),
            Script(src="https://cdn.tailwindcss.com"),
            Script("""
                document.addEventListener('DOMContentLoaded', function() {
                    // Check for PKCE code in query params (Supabase email flow)
                    const urlParams = new URLSearchParams(window.location.search);
                    const code = urlParams.get('code');

                    if (code) {
                        // Exchange PKCE code server-side for access token
                        document.getElementById('error-msg').textContent = 'Verifying your link...';
                        fetch('/auth/exchange-code', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({code: code})
                        }).then(r => r.json()).then(data => {
                            if (data.access_token) {
                                document.getElementById('access_token').value = data.access_token;
                                document.getElementById('reset-form').style.display = 'block';
                                document.getElementById('error-msg').style.display = 'none';
                            } else {
                                document.getElementById('error-msg').textContent = data.error || 'This link has expired. Please request a new one.';
                            }
                        }).catch(function() {
                            document.getElementById('error-msg').textContent = 'Something went wrong. Please request a new reset link.';
                        });
                        return;
                    }

                    // Legacy: check for access_token in URL hash fragment
                    const hash = window.location.hash.substring(1);
                    const params = new URLSearchParams(hash);
                    const accessToken = params.get('access_token');
                    const type = params.get('type');

                    if (accessToken && type === 'recovery') {
                        document.getElementById('access_token').value = accessToken;
                        document.getElementById('reset-form').style.display = 'block';
                        document.getElementById('error-msg').style.display = 'none';
                    } else if (!accessToken && !code) {
                        document.getElementById('error-msg').textContent = 'Invalid or expired reset link. Please request a new one.';
                    }
                });
            """),
        ),
        Body(
            Div(
                H1("Set New Password", cls="text-2xl font-bold mb-6"),
                P("Invalid or expired reset link.", id="error-msg", cls="text-red-400 mb-4 text-sm"),
                Form(
                    Input(type="hidden", name="access_token", id="access_token"),
                    Div(
                        Label("New Password", fr="password", cls="block text-sm mb-1"),
                        Input(type="password", name="password", id="password", required=True, minlength="8",
                              cls="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"),
                        P("Minimum 8 characters", cls="text-gray-500 text-xs mt-1"),
                        cls="mb-4"
                    ),
                    Div(
                        Label("Confirm Password", fr="password_confirm", cls="block text-sm mb-1"),
                        Input(type="password", name="password_confirm", id="password_confirm", required=True, minlength="8",
                              cls="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"),
                        cls="mb-4"
                    ),
                    Button("Update Password", type="submit",
                           cls="w-full p-2 bg-green-600 hover:bg-green-700 rounded text-white font-medium"),
                    method="post", action="/reset-password",
                    id="reset-form", style="display:none",
                ),
                P(
                    A("← Back to Login", href="/login", cls="text-blue-400 hover:underline"),
                    cls="mt-6 text-center"
                ),
                cls="max-w-md mx-auto mt-10 sm:mt-20 p-4 sm:p-8 bg-gray-800 rounded-lg"
            ),
            cls="min-h-screen bg-gray-900 text-white"
        ),
    )


@rt("/reset-password")
async def post(access_token: str, password: str, password_confirm: str, sess):
    """Handle password reset form submission."""
    error = None
    if not access_token:
        error = "Invalid reset link. Please request a new one."
    elif password != password_confirm:
        error = "Passwords do not match."
    elif len(password) < 8:
        error = "Password must be at least 8 characters."

    if error:
        return Html(
            Head(Meta(name="viewport", content="width=device-width, initial-scale=1"), Title("Set New Password - Rhodesli"), Script(src="https://cdn.tailwindcss.com")),
            Body(
                Div(
                    H1("Set New Password", cls="text-2xl font-bold mb-6"),
                    P(error, cls="text-red-400 mb-4 text-sm"),
                    P(A("← Request a new reset link", href="/forgot-password", cls="text-blue-400 hover:underline"), cls="mt-4"),
                    cls="max-w-md mx-auto mt-10 sm:mt-20 p-4 sm:p-8 bg-gray-800 rounded-lg"
                ),
                cls="min-h-screen bg-gray-900 text-white"
            ),
        )

    success, err = await update_password(access_token, password)

    if success:
        return Html(
            Head(Meta(name="viewport", content="width=device-width, initial-scale=1"), Title("Password Updated - Rhodesli"), Script(src="https://cdn.tailwindcss.com")),
            Body(
                Div(
                    H1("Password Updated", cls="text-2xl font-bold mb-4"),
                    P("Your password has been updated successfully.", cls="text-green-400 mb-6"),
                    A("Sign in with your new password", href="/login",
                      cls="block w-full p-2 bg-blue-600 hover:bg-blue-700 rounded text-white font-medium text-center"),
                    cls="max-w-md mx-auto mt-10 sm:mt-20 p-4 sm:p-8 bg-gray-800 rounded-lg"
                ),
                cls="min-h-screen bg-gray-900 text-white"
            ),
        )
    else:
        return Html(
            Head(Meta(name="viewport", content="width=device-width, initial-scale=1"), Title("Set New Password - Rhodesli"), Script(src="https://cdn.tailwindcss.com")),
            Body(
                Div(
                    H1("Set New Password", cls="text-2xl font-bold mb-6"),
                    P(err or "Failed to update password.", cls="text-red-400 mb-4 text-sm"),
                    P(A("← Request a new reset link", href="/forgot-password", cls="text-blue-400 hover:underline"), cls="mt-4"),
                    cls="max-w-md mx-auto mt-10 sm:mt-20 p-4 sm:p-8 bg-gray-800 rounded-lg"
                ),
                cls="min-h-screen bg-gray-900 text-white"
            ),
        )


@rt("/auth/callback")
def get(sess):
    """Handle OAuth callback from social providers. Tokens are in URL fragment."""
    return Html(
        Head(
            Meta(name="viewport", content="width=device-width, initial-scale=1"),
            Title("Logging in..."),
            Script(src="https://cdn.tailwindcss.com"),
            Script("""
                document.addEventListener('DOMContentLoaded', function() {
                    const hash = window.location.hash.substring(1);
                    const params = new URLSearchParams(hash);
                    const accessToken = params.get('access_token');

                    if (accessToken) {
                        fetch('/auth/session', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({access_token: accessToken})
                        }).then(r => r.json()).then(data => {
                            if (data.success) {
                                window.location.href = '/';
                            } else {
                                window.location.href = '/login?error=oauth_failed';
                            }
                        }).catch(() => {
                            window.location.href = '/login?error=oauth_failed';
                        });
                    } else {
                        window.location.href = '/login?error=oauth_failed';
                    }
                });
            """),
        ),
        Body(
            Div(
                P("Completing login...", cls="text-gray-400"),
                cls="flex items-center justify-center min-h-screen bg-gray-900"
            ),
        ),
    )


@rt("/auth/session")
async def post(request, sess):
    """Create session from OAuth access token."""
    from starlette.responses import JSONResponse

    try:
        data = await request.json()
    except Exception:
        return JSONResponse({"error": "Invalid request"}, status_code=400)

    access_token = data.get("access_token")
    if not access_token:
        return JSONResponse({"error": "No token"}, status_code=400)

    user, error = await get_user_from_token(access_token)
    if user:
        sess['auth'] = user
        # Submit any pending annotation stashed before OAuth login
        _submit_pending_annotation(sess, user)
        return JSONResponse({"success": True})
    else:
        return JSONResponse({"error": error or "Failed to get user"}, status_code=401)


@rt("/auth/exchange-code")
async def post(request, sess):
    """Exchange a PKCE auth code for an access token (used by password recovery)."""
    from starlette.responses import JSONResponse

    try:
        data = await request.json()
    except Exception:
        return JSONResponse({"error": "Invalid request"}, status_code=400)

    code = data.get("code")
    if not code:
        return JSONResponse({"error": "No code provided"}, status_code=400)

    result, error = await exchange_code_for_session(code)
    if result:
        return JSONResponse({"access_token": result["access_token"]})
    else:
        return JSONResponse({"error": error or "Code exchange failed"}, status_code=400)


@rt("/logout")
def get(sess):
    """Log out and redirect to home."""
    sess.clear()
    return RedirectResponse('/', status_code=303)


# --- Admin Data Export Endpoints ---

@rt("/admin/export/identities")
def get(sess=None):
    """Download identities.json. Admin-only."""
    block = _check_admin(sess)
    if block:
        return block
    fpath = data_path / "identities.json"
    if not fpath.exists():
        return Response("File not found", status_code=404)
    return FileResponse(
        str(fpath),
        media_type="application/json",
        filename="identities.json",
    )


@rt("/admin/export/photo-index")
def get(sess=None):
    """Download photo_index.json. Admin-only."""
    block = _check_admin(sess)
    if block:
        return block
    fpath = data_path / "photo_index.json"
    if not fpath.exists():
        return Response("File not found", status_code=404)
    return FileResponse(
        str(fpath),
        media_type="application/json",
        filename="photo_index.json",
    )


@rt("/admin/export/all")
def get(sess=None):
    """Download a ZIP of all data files. Admin-only."""
    block = _check_admin(sess)
    if block:
        return block
    buf = io.BytesIO()
    with zipfile.ZipFile(buf, "w", zipfile.ZIP_DEFLATED) as zf:
        for name in ("identities.json", "photo_index.json"):
            fpath = data_path / name
            if fpath.exists():
                zf.write(str(fpath), arcname=name)
    buf.seek(0)
    return Response(
        content=buf.getvalue(),
        media_type="application/zip",
        headers={"Content-Disposition": "attachment; filename=rhodesli-data-export.zip"},
    )


# =============================================================================
# ML EVALUATION DASHBOARD (admin-only)
# =============================================================================

@rt("/admin/ml-dashboard")
def get(sess=None):
    """ML evaluation dashboard. Shows golden set stats, thresholds, identity counts."""
    denied = _check_admin(sess)
    if denied:
        return denied

    registry = load_registry()

    # Identity stats by state
    confirmed = registry.list_identities(state=IdentityState.CONFIRMED)
    skipped = registry.list_identities(state=IdentityState.SKIPPED)
    inbox = registry.list_identities(state=IdentityState.INBOX)
    proposed = registry.list_identities(state=IdentityState.PROPOSED)
    rejected = registry.list_identities(state=IdentityState.REJECTED)

    total_identities = len(confirmed) + len(skipped) + len(inbox) + len(proposed) + len(rejected)
    total_faces = sum(
        len(i.get("anchor_ids", [])) + len(i.get("candidate_ids", []))
        for i in confirmed + skipped + inbox + proposed
    )

    # Golden set stats
    gs_stats = _load_golden_set_stats()
    eval_stats = _load_evaluation_stats()

    # Recent actions from event log
    recent_actions = _load_recent_actions(limit=10)

    # Build stat cards
    stat_cards = Div(
        _stat_card("Confirmed", str(len(confirmed)), "emerald"),
        _stat_card("Skipped", str(len(skipped)), "amber"),
        _stat_card("New Matches", str(len(inbox) + len(proposed)), "blue"),
        _stat_card("Rejected", str(len(rejected)), "red"),
        _stat_card("Total Faces", str(total_faces), "slate"),
        _stat_card("Identities", str(total_identities), "indigo"),
        cls="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4 mb-8"
    )

    # Golden set section
    if gs_stats:
        gs_section = Div(
            H3("Golden Set", cls="text-lg font-semibold text-white mb-3"),
            Div(
                _stat_card("Mappings", str(gs_stats.get("total_mappings", 0)), "purple"),
                _stat_card("Identities", str(gs_stats.get("unique_identities", 0)), "purple"),
                _stat_card("Photos", str(gs_stats.get("unique_photos", 0)), "purple"),
                cls="grid grid-cols-3 gap-4"
            ),
            cls="bg-slate-800 rounded-xl p-6 border border-slate-700 mb-6"
        )
    else:
        gs_section = Div(
            H3("Golden Set", cls="text-lg font-semibold text-white mb-3"),
            P("No golden set data available. Run: python scripts/build_golden_set.py",
              cls="text-slate-400 text-sm"),
            cls="bg-slate-800 rounded-xl p-6 border border-slate-700 mb-6"
        )

    # Golden set diversity section (ML-011)
    diversity_path = data_path / "golden_set_diversity.json"
    if diversity_path.exists():
        try:
            import json as _json
            with open(diversity_path) as f:
                diversity = _json.load(f)
            diversity_section = Div(
                H3("Golden Set Diversity (ML-011)", cls="text-lg font-semibold text-white mb-3"),
                Div(
                    _stat_card("Multi-face", str(diversity.get("multi_face_identities", 0)), "blue"),
                    _stat_card("Single-face", str(diversity.get("single_face_identities", 0)), "amber"),
                    _stat_card("Same Pairs", str(diversity.get("same_person_pairs", 0)), "green"),
                    _stat_card("Collections", str(diversity.get("collections", 0)), "purple"),
                    cls="grid grid-cols-4 gap-4"
                ),
                P(f"Same-person pairs: {diversity.get('same_person_pairs', 0)} | "
                  f"Different-person pairs: {diversity.get('different_person_pairs', 0)}",
                  cls="text-xs text-slate-400 mt-2"),
                cls="bg-slate-800 rounded-xl p-6 border border-slate-700 mb-6"
            )
        except Exception:
            diversity_section = Span()
    else:
        diversity_section = Div(
            H3("Golden Set Diversity", cls="text-lg font-semibold text-white mb-3"),
            P("Run: python scripts/analyze_golden_set.py", cls="text-slate-400 text-sm"),
            cls="bg-slate-800 rounded-xl p-6 border border-slate-700 mb-6"
        )

    # Threshold section
    threshold_section = Div(
        H3("Calibrated Thresholds (AD-013)", cls="text-lg font-semibold text-white mb-3"),
        Div(
            _threshold_row("VERY HIGH", MATCH_THRESHOLD_VERY_HIGH, "100%", "~13%", "emerald"),
            _threshold_row("HIGH", MATCH_THRESHOLD_HIGH, "100%", "~63%", "green"),
            _threshold_row("MODERATE", MATCH_THRESHOLD_MODERATE, "~94%", "~81%", "amber"),
            _threshold_row("MEDIUM", MATCH_THRESHOLD_MEDIUM, "~87%", "~87%", "orange"),
            cls="space-y-2"
        ),
        cls="bg-slate-800 rounded-xl p-6 border border-slate-700 mb-6"
    )

    # Evaluation results
    if eval_stats:
        eval_section = Div(
            H3("Last Evaluation", cls="text-lg font-semibold text-white mb-3"),
            P(f"Zero-FP ceiling: {eval_stats.get('zero_fp_ceiling', 'N/A')}",
              cls="text-sm text-slate-300"),
            P(f"Optimal F1 threshold: {eval_stats.get('optimal_f1_threshold', 'N/A')}",
              cls="text-sm text-slate-300"),
            P(eval_stats.get("statistical_note", ""), cls="text-xs text-slate-400 mt-2"),
            cls="bg-slate-800 rounded-xl p-6 border border-slate-700 mb-6"
        )
    else:
        eval_section = Div(
            H3("Evaluation", cls="text-lg font-semibold text-white mb-3"),
            P("No evaluation data. Run: python scripts/evaluate_golden_set.py",
              cls="text-slate-400 text-sm"),
            cls="bg-slate-800 rounded-xl p-6 border border-slate-700 mb-6"
        )

    # Recent actions
    if recent_actions:
        action_rows = [
            Div(
                Span(a.get("action", "?"), cls="text-xs font-mono bg-slate-700 px-2 py-0.5 rounded text-slate-300"),
                Span(a.get("timestamp", "")[:19], cls="text-xs text-slate-500 ml-2"),
                Span(a.get("detail", ""), cls="text-xs text-slate-400 ml-2"),
                cls="flex items-center gap-1"
            )
            for a in recent_actions
        ]
        actions_section = Div(
            H3("Recent Actions", cls="text-lg font-semibold text-white mb-3"),
            Div(*action_rows, cls="space-y-1"),
            cls="bg-slate-800 rounded-xl p-6 border border-slate-700 mb-6"
        )
    else:
        actions_section = Div(
            H3("Recent Actions", cls="text-lg font-semibold text-white mb-3"),
            P("No recent actions logged.", cls="text-slate-400 text-sm"),
            cls="bg-slate-800 rounded-xl p-6 border border-slate-700 mb-6"
        )

    return Title("ML Dashboard — Rhodesli"), Div(
        _admin_nav_bar("ml-dashboard"),
        Div(
            H1("ML Evaluation Dashboard", cls="text-2xl font-bold text-white"),
            cls="mb-6"
        ),
        stat_cards,
        gs_section,
        diversity_section,
        threshold_section,
        eval_section,
        actions_section,
        cls="max-w-5xl mx-auto p-6"
    )


def _stat_card(label: str, value: str, color: str) -> Div:
    """Small stat card for the ML dashboard."""
    color_map = {
        "emerald": "border-emerald-500 text-emerald-400",
        "amber": "border-amber-500 text-amber-400",
        "blue": "border-blue-500 text-blue-400",
        "red": "border-red-500 text-red-400",
        "slate": "border-slate-500 text-slate-300",
        "indigo": "border-indigo-500 text-indigo-400",
        "purple": "border-purple-500 text-purple-400",
        "green": "border-green-500 text-green-400",
        "orange": "border-orange-500 text-orange-400",
    }
    cls = color_map.get(color, "border-slate-500 text-slate-300")
    return Div(
        Div(value, cls=f"text-2xl font-bold {cls.split()[-1]}"),
        Div(label, cls="text-xs text-slate-400 mt-1"),
        cls=f"bg-slate-800 rounded-lg p-4 border-l-4 {cls.split()[0]}"
    )


def _threshold_row(label: str, value: float, precision: str, recall: str, color: str) -> Div:
    """Single threshold row in the dashboard."""
    return Div(
        Span(label, cls=f"text-sm font-medium text-{color}-400 w-24"),
        Span(f"< {value}", cls="text-sm font-mono text-white w-16"),
        Span(f"Precision: {precision}", cls="text-xs text-slate-400 w-28"),
        Span(f"Recall: {recall}", cls="text-xs text-slate-400"),
        cls="flex items-center gap-4"
    )


def _load_golden_set_stats() -> dict:
    """Load golden set stats from data file."""
    gs_path = data_path / "golden_set.json"
    if not gs_path.exists():
        return {}
    try:
        import json as _json
        with open(gs_path) as f:
            gs = _json.load(f)
        return gs.get("stats", {})
    except Exception:
        return {}


def _load_evaluation_stats() -> dict:
    """Load the most recent evaluation results."""
    # Find the most recent evaluation file
    eval_files = sorted(data_path.glob("golden_set_evaluation_*.json"), reverse=True)
    if not eval_files:
        return {}
    try:
        import json as _json
        with open(eval_files[0]) as f:
            return _json.load(f)
    except Exception:
        return {}


def _load_recent_actions(limit: int = 10) -> list:
    """Load recent user actions from the event log."""
    log_path = data_path / "event_log.jsonl"
    if not log_path.exists():
        return []
    try:
        lines = log_path.read_text().strip().split("\n")
        recent = lines[-limit:] if len(lines) > limit else lines
        recent.reverse()  # Most recent first
        import json as _json
        actions = []
        for line in recent:
            if not line.strip():
                continue
            try:
                event = _json.load(io.StringIO(line))
                actions.append({
                    "action": event.get("event_type", event.get("action", "?")),
                    "timestamp": event.get("timestamp", ""),
                    "detail": event.get("identity_id", event.get("target_id", ""))[:12],
                })
            except Exception:
                continue
        return actions
    except Exception:
        return []


# =============================================================================
# ANNOTATION SYSTEM (contributor submissions + admin review)
# =============================================================================

# Annotation data stored in data/annotations.json
_annotations_cache = None

def _load_annotations() -> dict:
    """Load annotations from data file.

    Returns default empty structure if file is missing or corrupted,
    so the server never crashes on bad annotation data.
    """
    global _annotations_cache
    if _annotations_cache is not None:
        return _annotations_cache
    ann_path = data_path / "annotations.json"
    default = {"schema_version": 1, "annotations": {}}
    if ann_path.exists():
        import json as _json
        try:
            with open(ann_path) as f:
                _annotations_cache = _json.load(f)
        except (json.JSONDecodeError, OSError) as e:
            logging.error(f"Failed to load annotations from {ann_path}: {e}")
            _annotations_cache = default
    else:
        _annotations_cache = default
    return _annotations_cache


def _save_annotations(data: dict):
    """Save annotations atomically."""
    global _annotations_cache
    ann_path = data_path / "annotations.json"
    import json as _json
    import tempfile
    tmp_fd, tmp_path = tempfile.mkstemp(dir=str(data_path), suffix=".json")
    try:
        with os.fdopen(tmp_fd, "w") as f:
            _json.dump(data, f, indent=2, ensure_ascii=False)
        os.replace(tmp_path, str(ann_path))
        _annotations_cache = data
    except Exception:
        if os.path.exists(tmp_path):
            os.unlink(tmp_path)
        raise


def _invalidate_annotations_cache():
    """Clear annotations cache after write."""
    global _annotations_cache
    _annotations_cache = None


def _create_merge_suggestion(target_id: str, source_id: str, submitted_by: str,
                             confidence: str = "likely", reason: str = "") -> str:
    """Create a merge_suggestion annotation. Returns the annotation ID."""
    import uuid
    from datetime import datetime, timezone
    ann_id = str(uuid.uuid4())
    annotations = _load_annotations()
    annotations["annotations"][ann_id] = {
        "annotation_id": ann_id,
        "type": "merge_suggestion",
        "target_type": "identity",
        "target_id": target_id,
        "value": json.dumps({"source_id": source_id, "target_id": target_id}),
        "confidence": confidence,
        "reason": reason,
        "submitted_by": submitted_by,
        "submitted_at": datetime.now(timezone.utc).isoformat(),
        "status": "pending",
        "reviewed_by": None,
        "reviewed_at": None,
    }
    _save_annotations(annotations)
    return ann_id


def _photo_metadata_display(photo: dict):
    """Display stored photo metadata fields (BE-012)."""
    metadata_fields = {
        "date_taken": "Date",
        "location": "Location",
        "caption": "Caption",
        "occasion": "Occasion",
        "donor": "Donor",
        "camera": "Camera",
    }
    items = []
    for key, label in metadata_fields.items():
        value = photo.get(key)
        if value:
            items.append(P(
                Span(f"{label}: ", cls="text-slate-500"),
                Span(str(value), cls="text-slate-300"),
                cls="text-xs"
            ))
    if not items:
        return Span()
    return Div(*items, cls="mt-2 space-y-0.5")


def _photo_annotations_section(photo_id: str, is_admin: bool = False):
    """
    AN-002–AN-006: Show approved photo annotations and a form to add new ones.
    Displays captions, dates, locations, stories, source attributions.
    """
    try:
        annotations = _load_annotations()
    except Exception:
        annotations = {"annotations": {}}

    # Get approved annotations for this photo
    photo_anns = [
        ann for ann in annotations.get("annotations", {}).values()
        if ann.get("target_type") == "photo"
        and ann.get("target_id") == photo_id
        and ann.get("status") == "approved"
    ]

    # Also get pending count for admin badge (includes guest submissions)
    pending_count = sum(
        1 for ann in annotations.get("annotations", {}).values()
        if ann.get("target_type") == "photo"
        and ann.get("target_id") == photo_id
        and ann.get("status") in ("pending", "pending_unverified")
    )

    # Display approved annotations grouped by type
    type_labels = {
        "caption": "Caption",
        "date": "Date",
        "location": "Location",
        "story": "Story",
        "source": "Source",
    }
    ann_items = []
    for ann in sorted(photo_anns, key=lambda a: a.get("submitted_at", "")):
        label = type_labels.get(ann["type"], ann["type"].title())
        ann_items.append(Div(
            Span(f"{label}: ", cls="text-slate-400 text-xs font-medium"),
            Span(ann["value"], cls="text-slate-300 text-xs"),
            cls="py-1"
        ))

    # Annotation submission form (available to any logged-in user)
    form = Div(
        Details(
            Summary("Add annotation", cls="text-xs text-indigo-400 hover:text-indigo-300 cursor-pointer"),
            Form(
                Input(type="hidden", name="target_type", value="photo"),
                Input(type="hidden", name="target_id", value=photo_id),
                Div(
                    Select(
                        Option("Caption", value="caption"),
                        Option("Date", value="date"),
                        Option("Location", value="location"),
                        Option("Story", value="story"),
                        Option("Source/Donor", value="source"),
                        name="annotation_type",
                        cls="bg-slate-700 text-white text-xs rounded px-2 py-1 w-full",
                    ),
                    cls="mt-2"
                ),
                Div(
                    Textarea(
                        name="value",
                        placeholder="Enter annotation...",
                        cls="bg-slate-700 text-white text-xs rounded px-2 py-1 w-full h-16 resize-none",
                        required=True,
                    ),
                    cls="mt-1"
                ),
                Div(
                    Select(
                        Option("Certain", value="certain"),
                        Option("Likely", value="likely", selected=True),
                        Option("Guess", value="guess"),
                        name="confidence",
                        cls="bg-slate-700 text-white text-xs rounded px-2 py-1",
                    ),
                    Button(
                        "Submit",
                        type="submit",
                        cls="bg-indigo-600 hover:bg-indigo-500 text-white text-xs px-3 py-1 rounded",
                    ),
                    cls="mt-1 flex gap-2 items-center"
                ),
                hx_post="/api/annotations/submit",
                hx_target=f"#photo-annotations-{photo_id}",
                hx_swap="outerHTML",
                cls="mt-2",
            ),
            cls="mt-2",
        ),
        cls="mt-2"
    )

    pending_badge = Span(
        f" ({pending_count} pending)",
        cls="text-amber-400 text-xs"
    ) if pending_count and is_admin else None

    return Div(
        *ann_items,
        form,
        pending_badge,
        id=f"photo-annotations-{photo_id}",
        cls="mt-3 border-t border-slate-700 pt-2" if ann_items else "mt-2",
    )


# --- Person Comments ---

_person_comments_cache = None


def _load_person_comments() -> dict:
    """Load person comments from data file."""
    global _person_comments_cache
    if _person_comments_cache is not None:
        return _person_comments_cache
    path = data_path / "person_comments.json"
    default = {"schema_version": 1, "comments": {}}
    if path.exists():
        try:
            with open(path, encoding="utf-8") as f:
                _person_comments_cache = json.load(f)
        except (json.JSONDecodeError, OSError):
            _person_comments_cache = default
    else:
        _person_comments_cache = default
    return _person_comments_cache


def _save_person_comments(data: dict):
    """Save person comments atomically."""
    global _person_comments_cache
    path = data_path / "person_comments.json"
    import tempfile
    tmp_fd, tmp_path = tempfile.mkstemp(dir=str(data_path), suffix=".json")
    try:
        with os.fdopen(tmp_fd, "w") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
        os.replace(tmp_path, str(path))
        _person_comments_cache = data
    except Exception:
        try:
            os.unlink(tmp_path)
        except OSError:
            pass


def _person_comments_section(person_id: str, is_admin: bool = False):
    """Build the comments section for person pages."""
    comments_data = _load_person_comments()
    person_comments = comments_data.get("comments", {}).get(person_id, [])
    visible_comments = [c for c in person_comments if c.get("status", "visible") == "visible"]

    comment_items = []
    for c in visible_comments:
        author = c.get("author", "Anonymous")
        text = c.get("text", "")
        ts = c.get("timestamp", "")
        date_str = ts[:10] if ts else ""

        hide_btn = None
        if is_admin:
            hide_btn = Button(
                "Hide",
                hx_post=f"/api/person/{person_id}/comment/{c.get('id', '')}/hide",
                hx_target=f"#comment-{c.get('id', '')}",
                hx_swap="outerHTML",
                cls="text-xs text-rose-400 hover:text-rose-300 ml-2",
            )

        comment_items.append(
            Div(
                Div(
                    Span(author, cls="text-sm font-medium text-slate-300"),
                    Span(f" · {date_str}", cls="text-xs text-slate-600") if date_str else None,
                    hide_btn,
                    cls="flex items-center mb-1",
                ),
                P(text, cls="text-sm text-slate-400 leading-relaxed"),
                cls="py-3 border-b border-slate-800/50 last:border-0",
                id=f"comment-{c.get('id', '')}",
            )
        )

    # Comment form (no login required)
    form = Form(
        Input(type="hidden", name="person_id", value=person_id),
        Div(
            Input(type="text", name="author", placeholder="Your name (optional)",
                  cls="w-full px-3 py-2 bg-slate-800 border border-slate-700 rounded-lg text-white text-sm placeholder-slate-500 focus:border-indigo-500 focus:outline-none"),
            cls="mb-3",
        ),
        Div(
            Textarea(name="text", placeholder="Share a memory, correction, or anything you know about this person...",
                     rows=3,
                     cls="w-full px-3 py-2 bg-slate-800 border border-slate-700 rounded-lg text-white text-sm placeholder-slate-500 focus:border-indigo-500 focus:outline-none resize-none"),
            cls="mb-3",
        ),
        Button("Post Comment", type="submit",
               cls="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 text-white text-sm font-medium rounded-lg transition-colors"),
        hx_post=f"/api/person/{person_id}/comment",
        hx_target="#person-comments-list",
        hx_swap="innerHTML",
    )

    return Div(
        H3(f"Comments ({len(visible_comments)})", cls="text-lg font-serif font-semibold text-slate-300 mb-4"),
        Div(*comment_items, id="person-comments-list") if comment_items else
        Div(P("No comments yet. Be the first to share a memory!", cls="text-sm text-slate-500 italic"), id="person-comments-list"),
        Div(form, cls="mt-6"),
        cls="mt-10 pt-8 border-t border-slate-800",
        data_testid="comments-section",
    )


def _identity_metadata_display(identity: dict, is_admin: bool = False):
    """AN-012: Display identity metadata fields (bio, birth/death, relationships)."""
    identity_id = identity.get("identity_id", "")

    # Build compact summary line: "~1890–1944 · Rhodes → Auschwitz"
    summary_parts = []
    # Check metadata first, then ML estimates for birth year
    birth_year, by_source, _by_conf = _get_birth_year(identity_id, identity)
    death_year = identity.get("death_year")
    if birth_year and death_year:
        prefix = "~" if by_source == "ml_inferred" else ""
        summary_parts.append(f"{prefix}{birth_year}–{death_year}")
    elif birth_year:
        prefix = "~" if by_source == "ml_inferred" else ""
        summary_parts.append(f"b. {prefix}{birth_year}")
    elif death_year:
        summary_parts.append(f"d. {death_year}")

    birth_place = identity.get("birth_place")
    death_place = identity.get("death_place")
    if birth_place and death_place:
        summary_parts.append(f"{birth_place} \u2192 {death_place}")
    elif birth_place:
        summary_parts.append(birth_place)
    elif death_place:
        summary_parts.append(death_place)

    maiden_name = identity.get("maiden_name")
    if maiden_name:
        summary_parts.append(f"n\u00e9e {maiden_name}")

    items = []
    if summary_parts:
        items.append(P(
            " \u00b7 ".join(summary_parts),
            cls="text-xs text-slate-400 italic"
        ))

    # Additional fields shown below the summary
    detail_fields = {
        "relationship_notes": "Relationships",
        "bio": "Bio",
    }
    for key, label in detail_fields.items():
        value = identity.get(key)
        if value:
            items.append(P(
                Span(f"{label}: ", cls="text-slate-500"),
                Span(str(value), cls="text-slate-300"),
                cls="text-xs"
            ))

    # Edit button for admins
    edit_btn = None
    if is_admin and identity_id:
        edit_btn = Button(
            "Edit Details" if not items else "Edit",
            cls="text-xs text-indigo-400 hover:text-indigo-300 underline",
            hx_get=f"/api/identity/{identity_id}/metadata-form",
            hx_target=f"#metadata-{identity_id}",
            hx_swap="innerHTML",
            type="button",
        )

    if not items and not edit_btn:
        return Span()

    return Div(
        Div(*items, cls="space-y-0.5") if items else None,
        edit_btn,
        id=f"metadata-{identity_id}",
        cls="mt-2",
    )


def _identity_annotations_section(identity_id: str, is_admin: bool = False):
    """
    AN-013/AN-014: Show approved identity annotations and submission form.
    Displays bio, relationship, story, and other identity-level annotations.
    """
    try:
        annotations = _load_annotations()
    except Exception:
        annotations = {"annotations": {}}

    # Get approved annotations for this identity
    identity_anns = [
        ann for ann in annotations.get("annotations", {}).values()
        if ann.get("target_type") == "identity"
        and ann.get("target_id") == identity_id
        and ann.get("status") == "approved"
    ]

    # Pending count for admin badge (includes guest submissions)
    pending_count = sum(
        1 for ann in annotations.get("annotations", {}).values()
        if ann.get("target_type") == "identity"
        and ann.get("target_id") == identity_id
        and ann.get("status") in ("pending", "pending_unverified")
    )

    # Display approved annotations grouped by type
    type_labels = {
        "bio": "Bio",
        "relationship": "Relationship",
        "story": "Story",
        "name_suggestion": "Name Suggestion",
        "caption": "Caption",
    }
    ann_items = []
    for ann in sorted(identity_anns, key=lambda a: a.get("submitted_at", "")):
        label = type_labels.get(ann["type"], ann["type"].title())
        ann_items.append(Div(
            Span(f"{label}: ", cls="text-slate-400 text-xs font-medium"),
            Span(ann["value"], cls="text-slate-300 text-xs"),
            cls="py-1"
        ))

    # Annotation submission form
    form = Div(
        Details(
            Summary("Add annotation", cls="text-xs text-indigo-400 hover:text-indigo-300 cursor-pointer"),
            Form(
                Input(type="hidden", name="target_type", value="identity"),
                Input(type="hidden", name="target_id", value=identity_id),
                Div(
                    Select(
                        Option("Bio", value="bio"),
                        Option("Relationship", value="relationship"),
                        Option("Story", value="story"),
                        Option("Caption", value="caption"),
                        name="annotation_type",
                        cls="bg-slate-700 text-white text-xs rounded px-2 py-1 w-full",
                    ),
                    cls="mt-2"
                ),
                Div(
                    Textarea(
                        name="value",
                        placeholder="Enter annotation...",
                        cls="bg-slate-700 text-white text-xs rounded px-2 py-1 w-full h-16 resize-none",
                        required=True,
                    ),
                    cls="mt-1"
                ),
                Div(
                    Select(
                        Option("Certain", value="certain"),
                        Option("Likely", value="likely", selected=True),
                        Option("Guess", value="guess"),
                        name="confidence",
                        cls="bg-slate-700 text-white text-xs rounded px-2 py-1",
                    ),
                    Button(
                        "Submit",
                        type="submit",
                        cls="bg-indigo-600 hover:bg-indigo-500 text-white text-xs px-3 py-1 rounded",
                    ),
                    cls="mt-1 flex gap-2 items-center"
                ),
                hx_post="/api/annotations/submit",
                hx_target=f"#identity-annotations-{identity_id}",
                hx_swap="outerHTML",
                cls="mt-2",
            ),
            cls="mt-2",
        ),
        cls="mt-2"
    )

    pending_badge = Span(
        f" ({pending_count} pending)",
        cls="text-amber-400 text-xs"
    ) if pending_count and is_admin else None

    return Div(
        *ann_items,
        form,
        pending_badge,
        id=f"identity-annotations-{identity_id}",
        cls="mt-3 border-t border-slate-700 pt-2" if ann_items else "mt-2",
    )


def _merge_annotations(source_id: str, target_id: str):
    """
    BE-006: When identities merge, retarget annotations from source to target.
    Annotations that targeted the source identity are updated to point at the target.
    This preserves contributor work across merges.
    """
    try:
        annotations = _load_annotations()
        changed = False
        for ann in annotations.get("annotations", {}).values():
            if ann.get("target_type") == "identity" and ann.get("target_id") == source_id:
                ann["target_id"] = target_id
                changed = True
        if changed:
            _save_annotations(annotations)
    except Exception:
        # Non-critical — don't block the merge
        pass


@rt("/api/annotations/submit")
def post(target_type: str, target_id: str, annotation_type: str,
         value: str, confidence: str = "likely", reason: str = "", sess=None):
    """
    Submit an annotation. Saves directly for all users — no modal interruption.
    Anonymous users save as pending_unverified; logged-in users save as pending.
    Types: name_suggestion, caption, date, location, story, relationship
    """
    # Validate value BEFORE auth check — empty input is always 400
    if not value or not value.strip():
        return Response(
            to_xml(toast("Please provide a value.", "warning")),
            status_code=400,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    user = get_current_user(sess) if sess is not None else None

    import uuid
    from datetime import datetime, timezone
    ann_id = str(uuid.uuid4())

    # Determine status and submitter based on auth state
    if user:
        submitted_by = user.email
        status = "pending"
    elif is_auth_enabled():
        submitted_by = "anonymous"
        status = "pending_unverified"
    else:
        submitted_by = "local_dev"
        status = "pending"

    annotations = _load_annotations()

    # Dedup: check for existing annotation with same target + value + type (still pending)
    existing_ann = None
    for existing in annotations["annotations"].values():
        if (existing.get("target_id") == target_id
                and existing.get("type") == annotation_type
                and existing.get("value", "").strip().lower() == value.strip().lower()
                and existing.get("status") in ("pending", "pending_unverified")):
            existing_ann = existing
            break

    if existing_ann:
        # Add a confirmation to the existing annotation instead of creating a new one
        if "confirmations" not in existing_ann:
            existing_ann["confirmations"] = []
        # Prevent same user from confirming twice
        already_confirmed = any(
            c.get("by") == submitted_by for c in existing_ann["confirmations"]
        )
        # Also check if they are the original submitter
        is_original_submitter = existing_ann.get("submitted_by") == submitted_by
        if not already_confirmed and not is_original_submitter:
            existing_ann["confirmations"].append({
                "by": submitted_by,
                "timestamp": datetime.now(timezone.utc).isoformat(),
            })
        _save_annotations(annotations)
        ann_id = existing_ann["annotation_id"]
    else:
        annotations["annotations"][ann_id] = {
            "annotation_id": ann_id,
            "type": annotation_type,
            "target_type": target_type,  # "identity" or "photo"
            "target_id": target_id,
            "value": value.strip(),
            "confidence": confidence,
            "reason": reason.strip() if reason else "",
            "submitted_by": submitted_by,
            "submitted_at": datetime.now(timezone.utc).isoformat(),
            "status": status,
            "reviewed_by": None,
            "reviewed_at": None,
            "confirmations": [],
        }
        _save_annotations(annotations)

    # If submitted from face tag dropdown, return inline confirmation + OOB toast
    if reason and reason.startswith("face_tag:") and annotation_type == "name_suggestion":
        parts = reason.split(":")
        face_id_from_reason = parts[1] if len(parts) >= 2 else ""
        confirmation = Div(
            Div(
                Span("You suggested: ", cls="text-emerald-400 text-sm"),
                Span(value.strip(), cls="text-sm font-medium text-white"),
                cls="flex items-center gap-1"
            ),
            Span("Pending review", cls="text-xs text-slate-500"),
            cls="p-2 bg-emerald-900/20 border border-emerald-700/30 rounded-lg text-center"
        )
        oob_toast = Div(
            toast("Thanks! Your suggestion has been submitted for review.", "success"),
            id="toast-container",
            hx_swap_oob="beforeend",
        )
        return Response(to_xml(confirmation) + to_xml(oob_toast))

    return Response(
        to_xml(toast("Thanks! Your suggestion has been submitted for review.", "success")),
        headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
    )


def _submit_pending_annotation(sess, user) -> bool:
    """Submit a stashed annotation from session. Returns True if submitted."""
    pending = sess.get("pending_annotation")
    if not pending:
        return False

    import uuid
    from datetime import datetime, timezone
    ann_id = str(uuid.uuid4())

    annotations = _load_annotations()
    annotations["annotations"][ann_id] = {
        "annotation_id": ann_id,
        "type": pending.get("annotation_type", "name_suggestion"),
        "target_type": pending.get("target_type", "identity"),
        "target_id": pending.get("target_id", ""),
        "value": pending.get("value", "").strip(),
        "confidence": pending.get("confidence", "likely"),
        "reason": pending.get("reason", "").strip(),
        "submitted_by": user.email,
        "submitted_at": datetime.now(timezone.utc).isoformat(),
        "status": "pending",
        "reviewed_by": None,
        "reviewed_at": None,
    }
    _save_annotations(annotations)
    del sess["pending_annotation"]
    return True


@rt("/api/annotations/guest-submit")
def post(target_type: str, target_id: str, annotation_type: str,
         value: str, confidence: str = "likely", reason: str = ""):
    """Save an annotation as anonymous guest. No auth required."""
    if not value or not value.strip():
        return Response(
            to_xml(toast("Please provide a value.", "warning")),
            status_code=400,
            headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"}
        )

    import uuid
    from datetime import datetime, timezone
    ann_id = str(uuid.uuid4())

    annotations = _load_annotations()
    annotations["annotations"][ann_id] = {
        "annotation_id": ann_id,
        "type": annotation_type,
        "target_type": target_type,
        "target_id": target_id,
        "value": value.strip(),
        "confidence": confidence,
        "reason": reason.strip() if reason else "",
        "submitted_by": "anonymous",
        "submitted_at": datetime.now(timezone.utc).isoformat(),
        "status": "pending_unverified",
        "reviewed_by": None,
        "reviewed_at": None,
    }
    _save_annotations(annotations)

    # Clear the modal and show toast
    return Response(
        to_xml(Div(
            toast("Thanks! Your suggestion is pending admin review.", "success"),
            id="guest-or-login-modal",
            hx_swap_oob="true",
        )),
        headers={"HX-Retarget": "#guest-or-login-modal", "HX-Reswap": "innerHTML"}
    )


@rt("/api/annotations/stash-and-login")
def post(target_type: str, target_id: str, annotation_type: str,
         value: str, confidence: str = "likely", reason: str = "", sess=None):
    """Stash annotation in session and show login form."""
    if sess is not None:
        sess["pending_annotation"] = {
            "target_type": target_type,
            "target_id": target_id,
            "annotation_type": annotation_type,
            "value": value,
            "confidence": confidence,
            "reason": reason,
        }

    google_url = get_oauth_url("google")

    return Div(
        Div(
            H2("Sign in to save", cls="text-xl font-bold text-white"),
            Button("X", cls="text-slate-400 hover:text-white text-xl font-bold",
                   **{"_": "on click set #guest-or-login-modal's innerHTML to ''"},
                   type="button", aria_label="Close"),
            cls="flex justify-between items-center mb-4 pb-2 border-b border-slate-700"
        ),
        Div(
            P("Your suggestion:", cls="text-slate-500 text-xs"),
            P(f'"{value}"', cls="text-slate-300 text-sm font-medium"),
            cls="bg-slate-700/50 rounded p-3 mb-4"
        ),
        Form(
            Div(
                Label("Email", fr="guest-email", cls="block text-sm mb-1 text-slate-300"),
                Input(type="email", name="email", id="guest-email", required=True,
                      cls="w-full p-2 rounded bg-slate-700 text-white border border-slate-600"),
                cls="mb-4"
            ),
            Div(
                Label("Password", fr="guest-password", cls="block text-sm mb-1 text-slate-300"),
                Input(type="password", name="password", id="guest-password", required=True,
                      cls="w-full p-2 rounded bg-slate-700 text-white border border-slate-600"),
                cls="mb-4"
            ),
            Button("Sign in & submit", type="submit",
                   cls="w-full p-2 bg-blue-600 hover:bg-blue-700 rounded text-white font-medium"),
            Div(id="guest-login-error", cls="text-red-400 text-sm mt-2"),
            hx_post="/api/annotations/login-and-submit",
            hx_target="#guest-login-error",
            hx_swap="innerHTML",
        ),
        # Google OAuth divider + button
        Div(
            Div(cls="flex-grow border-t border-slate-600"),
            Span("or", cls="px-4 text-slate-500 text-sm"),
            Div(cls="flex-grow border-t border-slate-600"),
            cls="flex items-center my-4"
        ) if google_url else None,
        A(
            NotStr('<svg viewBox="0 0 24 24" width="18" height="18" xmlns="http://www.w3.org/2000/svg"><path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92a5.06 5.06 0 0 1-2.2 3.32v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.1z" fill="#4285F4"/><path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/><path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/><path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/></svg>'),
            Span("Sign in with Google"),
            href=google_url or "#",
            style="display: flex; align-items: center; gap: 12px; padding: 0 16px; height: 40px; "
                  "background: white; border: 1px solid #dadce0; border-radius: 4px; cursor: pointer; "
                  "font-family: 'Roboto', Arial, sans-serif; font-size: 14px; color: #3c4043; "
                  "font-weight: 500; text-decoration: none; justify-content: center; width: 100%;",
        ) if google_url else None,
        Div(
            P(
                "No account? ",
                A("Sign up with invite code", href="/signup", cls="text-blue-400 hover:underline"),
                cls="text-sm text-slate-400"
            ),
            cls="mt-4 text-center"
        ),
        cls="bg-slate-800 rounded-lg shadow-2xl max-w-md w-full p-4 sm:p-8 relative border border-slate-700"
    )


@rt("/api/annotations/login-and-submit")
async def post(email: str, password: str, sess):
    """Authenticate and submit the stashed annotation."""
    user, error = await login_with_supabase(email, password)
    if error:
        return error
    sess['auth'] = user
    _submit_pending_annotation(sess, user)
    return Response("", headers={"HX-Refresh": "true"})


@rt("/my-contributions")
def get(sess=None):
    """User's annotation history."""
    denied = _check_login(sess)
    if denied:
        return RedirectResponse("/login", status_code=303)

    user = get_current_user(sess)
    if not user:
        return RedirectResponse("/login", status_code=303)

    annotations = _load_annotations()
    my_anns = [
        a for a in annotations["annotations"].values()
        if a.get("submitted_by") == user.email
    ]
    my_anns.sort(key=lambda a: a.get("submitted_at", ""), reverse=True)

    rows = []
    for a in my_anns:
        status_cls = {
            "pending": "text-amber-400 bg-amber-900/30",
            "approved": "text-emerald-400 bg-emerald-900/30",
            "rejected": "text-red-400 bg-red-900/30",
        }.get(a["status"], "text-slate-400")

        rows.append(Div(
            Div(
                Span(a["type"].replace("_", " ").title(), cls="text-sm font-medium text-white"),
                Span(a["status"].upper(), cls=f"text-xs px-2 py-0.5 rounded ml-2 {status_cls}"),
                cls="flex items-center"
            ),
            P(f'"{a["value"]}"', cls="text-sm text-slate-300 mt-1"),
            P(f'Submitted {a["submitted_at"][:10]}', cls="text-xs text-slate-500"),
            cls="bg-slate-800 rounded-lg p-4 border border-slate-700"
        ))

    if not rows:
        rows = [Div(
            P("No contributions yet.", cls="text-slate-400"),
            P("Visit a photo or identity page to suggest names, dates, or stories.",
              cls="text-sm text-slate-500 mt-2"),
            cls="text-center py-12"
        )]

    return Title("My Contributions — Rhodesli"), Div(
        Div(
            H1("My Contributions", cls="text-2xl font-bold text-white"),
            A("Back to Dashboard", href="/?section=to_review",
              cls="text-sm text-indigo-400 hover:text-indigo-300"),
            cls="flex items-center justify-between mb-6"
        ),
        Div(*rows, cls="space-y-3"),
        cls="max-w-3xl mx-auto p-6"
    )


def _admin_nav_bar(active: str = "") -> Div:
    """Consistent navigation bar for admin sub-pages.

    Shows links to all admin areas + back to dashboard.
    `active` should be one of: approvals, proposals, gedcom, uploads, audit, ml-dashboard
    """
    links = [
        ("Uploads", "/admin/pending", "uploads"),
        ("Approvals", "/admin/approvals", "approvals"),
        ("Proposals", "/admin/proposals", "proposals"),
        ("Birth Years", "/admin/review/birth-years", "birth-year-review"),
        ("GEDCOM", "/admin/gedcom", "gedcom"),
        ("Audit Log", "/admin/audit", "audit"),
        ("ML Dashboard", "/admin/ml-dashboard", "ml-dashboard"),
    ]
    nav_items = []
    for label, href, key in links:
        is_active = key == active
        cls = ("px-3 py-1.5 text-sm rounded-lg transition-colors " +
               ("bg-indigo-600 text-white" if is_active else "text-slate-400 hover:text-white hover:bg-slate-700/50"))
        nav_items.append(A(label, href=href, cls=cls))
    nav_items.append(
        A("Dashboard", href="/?section=to_review",
          cls="px-3 py-1.5 text-sm text-indigo-400 hover:text-indigo-300 ml-auto"),
    )
    return Div(
        *nav_items,
        cls="flex flex-wrap items-center gap-2 mb-6 pb-4 border-b border-slate-700/50",
        data_testid="admin-nav-bar",
    )


@rt("/admin/approvals")
def get(sess=None):
    """Admin page for reviewing pending annotations."""
    denied = _check_admin(sess)
    if denied:
        return denied

    annotations = _load_annotations()
    pending = [
        a for a in annotations["annotations"].values()
        if a.get("status") in ("pending", "pending_unverified")
    ]
    skipped = [
        a for a in annotations["annotations"].values()
        if a.get("status") == "skipped"
    ]
    # Sort: authenticated ("pending") before guest ("pending_unverified"), newest first within each group
    pending.sort(key=lambda a: a.get("submitted_at", ""), reverse=True)
    pending.sort(key=lambda a: 0 if a.get("status") == "pending" else 1)
    # Append skipped at the end so they appear below pending
    pending = pending + sorted(skipped, key=lambda a: a.get("submitted_at", ""), reverse=True)

    rows = []
    crop_files = get_crop_files()
    registry = load_registry()
    for a in pending:
        ann_id = a["annotation_id"]
        is_guest = a.get("submitted_by") == "anonymous"
        guest_badge = Span(
            "Guest", cls="text-xs bg-amber-500/20 text-amber-400 px-2 py-0.5 rounded-full ml-2"
        ) if is_guest else None

        # Merge suggestions get special rendering with face thumbnails
        if a["type"] == "merge_suggestion":
            try:
                merge_data = json.loads(a["value"])
                t_id = merge_data.get("target_id", a["target_id"])
                s_id = merge_data.get("source_id", "")
                t_identity = registry.get_identity(t_id)
                s_identity = registry.get_identity(s_id)
                t_name = ensure_utf8_display(t_identity.get("name", "")) or f"Identity {t_id[:8]}"
                s_name = ensure_utf8_display(s_identity.get("name", "")) or f"Identity {s_id[:8]}"
                # Get face thumbnails
                t_faces = t_identity.get("anchor_ids", []) + t_identity.get("candidate_ids", [])
                s_faces = s_identity.get("anchor_ids", []) + s_identity.get("candidate_ids", [])
                t_thumb = None
                s_thumb = None
                for fid in t_faces:
                    url = resolve_face_image_url(fid, crop_files)
                    if url:
                        t_thumb = Img(src=url, alt=t_name, cls="w-16 h-16 object-cover rounded border border-slate-600")
                        break
                for fid in s_faces:
                    url = resolve_face_image_url(fid, crop_files)
                    if url:
                        s_thumb = Img(src=url, alt=s_name, cls="w-16 h-16 object-cover rounded border border-slate-600")
                        break
                if not t_thumb:
                    t_thumb = Div(cls="w-16 h-16 bg-slate-600 rounded")
                if not s_thumb:
                    s_thumb = Div(cls="w-16 h-16 bg-slate-600 rounded")

                rows.append(Div(
                    Div(
                        Span("Merge Suggestion", cls="text-sm font-bold text-purple-400"),
                        Span(f"by {a['submitted_by']}", cls="text-xs text-slate-400 ml-2"),
                        guest_badge,
                        cls="flex items-center mb-3"
                    ),
                    # Side-by-side face comparison
                    Div(
                        Div(t_thumb, P(t_name, cls="text-xs text-slate-300 mt-1 text-center truncate w-16"), cls="flex flex-col items-center"),
                        Span("→", cls="text-slate-500 text-xl font-bold mx-4 self-center"),
                        Div(s_thumb, P(s_name, cls="text-xs text-slate-300 mt-1 text-center truncate w-16"), cls="flex flex-col items-center"),
                        cls="flex items-start justify-center mb-3"
                    ),
                    P(f'Confidence: {a["confidence"]}', cls="text-xs text-slate-500"),
                    P(f'Reason: {a.get("reason", "none")}', cls="text-xs text-slate-500") if a.get("reason") else None,
                    Div(
                        Button("Execute Merge",
                               hx_post=f"/admin/approvals/{ann_id}/approve",
                               hx_target=f"#annotation-{ann_id}",
                               hx_swap="outerHTML",
                               cls="px-3 py-1 text-sm bg-blue-600 text-white rounded hover:bg-blue-500"),
                        Button("Compare",
                               hx_get=f"/api/identity/{t_id}/compare/{s_id}",
                               hx_target="#compare-modal-content",
                               hx_swap="innerHTML",
                               cls="px-3 py-1 text-sm border border-amber-400/50 text-amber-400 rounded hover:bg-amber-500/20",
                               **{"_": "on click remove .hidden from #compare-modal"},
                               type="button"),
                        Button("Skip",
                               hx_post=f"/admin/approvals/{ann_id}/reject",
                               hx_target=f"#annotation-{ann_id}",
                               hx_swap="outerHTML",
                               cls="px-3 py-1 text-sm bg-red-600 text-white rounded hover:bg-red-500"),
                        cls="flex gap-2 mt-3"
                    ),
                    cls="bg-slate-800 rounded-lg p-4 border border-purple-500/30",
                    id=f"annotation-{ann_id}"
                ))
                continue
            except (json.JSONDecodeError, KeyError):
                pass  # Fall through to generic rendering

        # Build face thumbnail for identity-targeted annotations
        face_thumb = None
        photo_thumb = None
        target_name = f"{a['target_type']} {a['target_id'][:12]}..."
        if a["target_type"] == "identity":
            try:
                identity = registry.get_identity(a["target_id"])
            except KeyError:
                identity = None
            if identity:
                target_name = ensure_utf8_display(identity.get("name", "")) or f"Identity {a['target_id'][:8]}"
                faces = identity.get("anchor_ids", []) + identity.get("candidate_ids", [])
                for fid in faces:
                    url = resolve_face_image_url(fid, crop_files)
                    if url:
                        face_thumb = Img(src=url, alt=target_name,
                                         cls="w-16 h-16 object-cover rounded border border-slate-600")
                        # Get photo thumbnail for context
                        photo_id = get_photo_id_for_face(fid)
                        if photo_id:
                            photo = _photo_cache.get(photo_id, {}) if _photo_cache else {}
                            if photo.get("path"):
                                photo_thumb = Img(
                                    src=storage.get_photo_url(photo["path"]),
                                    alt="Photo context",
                                    cls="w-12 h-12 object-cover rounded border border-slate-700 opacity-80"
                                )
                        break

        rows.append(Div(
            Div(
                # Thumbnails on the left
                Div(
                    face_thumb or Div(cls="w-16 h-16 bg-slate-700 rounded flex items-center justify-center text-slate-500 text-2xl"),
                    photo_thumb,
                    cls="flex gap-2 items-start flex-shrink-0"
                ) if face_thumb else None,
                # Details on the right
                Div(
                    Div(
                        Span(a["type"].replace("_", " ").title(), cls="text-sm font-bold text-white"),
                        guest_badge,
                        cls="flex items-center"
                    ),
                    P(target_name, cls="text-xs text-slate-400") if a["target_type"] == "identity" else None,
                    P(f'"{a["value"]}"', cls="text-sm text-slate-300 mt-1"),
                    P(f'By: {a["submitted_by"]}' + (
                        f', confirmed by {len(a.get("confirmations", []))} other{"s" if len(a.get("confirmations", [])) != 1 else ""}'
                        if a.get("confirmations") else ""
                    ), cls="text-xs text-slate-500"),
                    P(f'Reason: {a.get("reason", "none")}', cls="text-xs text-slate-500") if a.get("reason") else None,
                    Div(
                        Button("Approve",
                               hx_post=f"/admin/approvals/{ann_id}/approve",
                               hx_target=f"#annotation-{ann_id}",
                               hx_swap="outerHTML",
                               cls="px-3 py-1 text-sm bg-emerald-600 text-white rounded hover:bg-emerald-500"),
                        Button("Skip",
                               hx_post=f"/admin/approvals/{ann_id}/skip",
                               hx_target=f"#annotation-{ann_id}",
                               hx_swap="outerHTML",
                               cls="px-3 py-1 text-sm bg-amber-600 text-white rounded hover:bg-amber-500"),
                        Button("Reject",
                               hx_post=f"/admin/approvals/{ann_id}/reject",
                               hx_target=f"#annotation-{ann_id}",
                               hx_swap="outerHTML",
                               cls="px-3 py-1 text-sm bg-red-600 text-white rounded hover:bg-red-500"),
                        cls="flex gap-2 mt-3"
                    ),
                    cls="flex-1"
                ),
                cls="flex gap-4"
            ),
            cls="bg-slate-800 rounded-lg p-4 border border-slate-700",
            id=f"annotation-{ann_id}",
            data_annotation_id=ann_id,
        ))

    if not rows:
        rows = [Div(
            P("No pending annotations to review.", cls="text-slate-400"),
            cls="text-center py-12"
        )]

    return Title("Annotation Approvals — Rhodesli"), Div(
        _admin_nav_bar("approvals"),
        Div(
            H1("Pending Approvals", cls="text-2xl font-bold text-white"),
            cls="mb-6"
        ),
        Div(f"{len(pending)} pending annotations", cls="text-sm text-slate-400 mb-4"),
        Div(*rows, cls="space-y-3"),
        cls="max-w-3xl mx-auto p-6"
    )


@rt("/admin/approvals/{ann_id}/approve")
def post(ann_id: str, sess=None):
    """Approve an annotation. Updates target record."""
    denied = _check_admin(sess)
    if denied:
        return denied

    user = get_current_user(sess)
    annotations = _load_annotations()
    ann = annotations["annotations"].get(ann_id)
    if not ann:
        return Response(to_xml(toast("Annotation not found.", "error")), status_code=404,
                        headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"})

    from datetime import datetime, timezone
    ann["status"] = "approved"
    ann["reviewed_by"] = user.email if user else "admin"
    ann["reviewed_at"] = datetime.now(timezone.utc).isoformat()
    log_user_action("APPROVE_ANNOTATION", annotation_id=ann_id,
                    type=ann.get("type", "unknown"),
                    target_id=ann.get("target_id", ""),
                    submitted_by=ann.get("submitted_by", ""),
                    admin=user.email if user else "admin")

    # Apply the annotation to the target
    if ann["type"] == "name_suggestion" and ann["target_type"] == "identity":
        registry = load_registry()
        identity = registry._identities.get(ann["target_id"])
        if identity:
            identity["name"] = ann["value"]
            identity["updated_at"] = datetime.now(timezone.utc).isoformat()
            save_registry(registry)
    elif ann["type"] == "merge_suggestion":
        # Execute the merge
        try:
            merge_data = json.loads(ann["value"])
            t_id = merge_data.get("target_id", ann["target_id"])
            s_id = merge_data.get("source_id", "")
            registry = load_registry()
            photo_registry = load_photo_registry()
            result = registry.merge_identities(
                source_id=s_id, target_id=t_id,
                user_source="approved_suggestion",
                photo_registry=photo_registry,
            )
            if result["success"]:
                save_registry(registry)
                actual_target = result.get("actual_target_id") or t_id
                _merge_annotations(s_id, actual_target)
                log_user_action("APPROVE_MERGE_SUGGESTION", target=t_id, source=s_id,
                                suggested_by=ann["submitted_by"],
                                admin=user.email if user else "admin")
            else:
                _save_annotations(annotations)
                return Div(
                    Span("MERGE FAILED", cls="text-sm font-bold text-red-400"),
                    Span(f' — {result["reason"]}', cls="text-sm text-slate-400"),
                    cls="bg-red-900/20 rounded-lg p-4 border border-red-700",
                    id=f"annotation-{ann_id}"
                )
        except (json.JSONDecodeError, KeyError) as e:
            _save_annotations(annotations)
            return Div(
                Span("ERROR", cls="text-sm font-bold text-red-400"),
                Span(f' — Invalid merge data: {e}', cls="text-sm text-slate-400"),
                cls="bg-red-900/20 rounded-lg p-4 border border-red-700",
                id=f"annotation-{ann_id}"
            )

    _save_annotations(annotations)

    merge_label = ""
    if ann["type"] == "merge_suggestion":
        try:
            merge_data = json.loads(ann["value"])
            merge_label = f"Merged {merge_data.get('source_id', '')[:8]} into {merge_data.get('target_id', '')[:8]}"
        except (json.JSONDecodeError, KeyError):
            merge_label = "Merge executed"

    _log_audit("approved", ann_id, user.email if user else "admin",
               merge_label or ann["value"])

    status_label = "APPROVED" if ann["type"] != "merge_suggestion" else "MERGED"
    return Div(
        Div(
            Span(status_label, cls="text-sm font-bold text-emerald-400"),
            Span(f' — {merge_label or ann["value"]} (suggested by {ann["submitted_by"]})', cls="text-sm text-slate-400"),
            cls="flex-1"
        ),
        Button("Undo",
               hx_post=f"/admin/approvals/{ann_id}/undo",
               hx_target=f"#annotation-{ann_id}",
               hx_swap="outerHTML",
               cls="px-3 py-1 text-xs bg-slate-600 text-white rounded hover:bg-slate-500 ml-2 flex-shrink-0"),
        cls="bg-emerald-900/20 rounded-lg p-4 border border-emerald-700 flex items-center",
        id=f"annotation-{ann_id}"
    )


@rt("/activity")
def get(sess=None):
    """
    Public activity feed showing recent identifications and contributions.
    Shows what's happening in the archive — motivates contributors.
    """
    actions = _load_activity_feed(limit=50)

    rows = []
    for a in actions:
        icon = {
            "MERGE": "🔗",
            "CONFIRM": "✓",
            "RENAME": "✏️",
            "SKIP": "⏭",
            "annotation_approved": "📝",
        }.get(a["type"], "•")

        rows.append(Div(
            Span(icon, cls="text-lg mr-2"),
            Span(a["description"], cls="text-sm text-slate-300"),
            Span(a["timestamp"][:10], cls="text-xs text-slate-500 ml-auto"),
            cls="flex items-center gap-2 py-2 border-b border-slate-800"
        ))

    if not rows:
        rows = [Div(
            P("No activity yet. Be the first to identify someone!",
              cls="text-slate-400 text-center py-12"),
        )]

    return Title("Activity — Rhodesli"), Div(
        Div(
            H1("Recent Activity", cls="text-2xl font-bold text-white"),
            A("Back to Archive", href="/",
              cls="text-sm text-indigo-400 hover:text-indigo-300"),
            cls="flex items-center justify-between mb-6"
        ),
        Div(*rows, cls="space-y-0"),
        cls="max-w-3xl mx-auto p-6"
    )


def _load_activity_feed(limit: int = 50) -> list:
    """Load activity from user_actions.log and annotations."""
    activities = []

    # Load from user action log
    action_log = Path(__file__).resolve().parent.parent / "logs" / "user_actions.log"
    if action_log.exists():
        try:
            lines = action_log.read_text().strip().split("\n")
            for line in lines[-limit:]:
                parts = line.split(" | ", 2)
                if len(parts) >= 2:
                    timestamp = parts[0].strip()
                    action_type = parts[1].strip()
                    detail = parts[2].strip() if len(parts) > 2 else ""

                    # Skip internal actions
                    if action_type in ("SKIP",):
                        continue

                    desc_map = {
                        "MERGE": "Two identities were merged",
                        "CONFIRM": "An identity was confirmed",
                        "RENAME": "An identity was renamed",
                        "REJECT_IDENTITY": "A match was rejected",
                        "DETACH": "A face was detached",
                    }
                    description = desc_map.get(action_type, f"Action: {action_type}")
                    if "target_identity_id=" in detail:
                        # Extract a readable fragment
                        for kv in detail.split():
                            if kv.startswith("target_identity_id="):
                                description += f" ({kv.split('=')[1][:8]}...)"
                                break

                    activities.append({
                        "type": action_type,
                        "description": description,
                        "timestamp": timestamp,
                    })
        except Exception:
            pass

    # Load from approved annotations
    try:
        annotations = _load_annotations()
        for ann in annotations.get("annotations", {}).values():
            if ann.get("status") == "approved":
                activities.append({
                    "type": "annotation_approved",
                    "description": f'Name suggestion approved: "{ann["value"]}"',
                    "timestamp": ann.get("reviewed_at", ann.get("submitted_at", "")),
                })
    except Exception:
        pass

    # Sort by timestamp, newest first
    activities.sort(key=lambda a: a.get("timestamp") or "", reverse=True)
    return activities[:limit]


@rt("/admin/approvals/{ann_id}/reject")
def post(ann_id: str, sess=None):
    """Reject an annotation. No data change."""
    denied = _check_admin(sess)
    if denied:
        return denied

    user = get_current_user(sess)
    annotations = _load_annotations()
    ann = annotations["annotations"].get(ann_id)
    if not ann:
        return Response(to_xml(toast("Annotation not found.", "error")), status_code=404,
                        headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"})

    from datetime import datetime, timezone
    ann["status"] = "rejected"
    ann["reviewed_by"] = user.email if user else "admin"
    ann["reviewed_at"] = datetime.now(timezone.utc).isoformat()
    _save_annotations(annotations)
    log_user_action("REJECT_ANNOTATION", annotation_id=ann_id,
                    type=ann.get("type", "unknown"),
                    target_id=ann.get("target_id", ""),
                    admin=user.email if user else "admin")

    _log_audit("rejected", ann_id, user.email if user else "admin", ann["value"])

    return Div(
        Div(
            Span("REJECTED", cls="text-sm font-bold text-red-400"),
            Span(f' — "{ann["value"]}" by {ann["submitted_by"]}', cls="text-sm text-slate-400"),
            cls="flex-1"
        ),
        Button("Undo",
               hx_post=f"/admin/approvals/{ann_id}/undo",
               hx_target=f"#annotation-{ann_id}",
               hx_swap="outerHTML",
               cls="px-3 py-1 text-xs bg-slate-600 text-white rounded hover:bg-slate-500 ml-2 flex-shrink-0"),
        cls="bg-red-900/20 rounded-lg p-4 border border-red-700 flex items-center",
        id=f"annotation-{ann_id}"
    )


@rt("/admin/approvals/{ann_id}/skip")
def post(ann_id: str, sess=None):
    """Skip an annotation for later review."""
    denied = _check_admin(sess)
    if denied:
        return denied

    user = get_current_user(sess)
    annotations = _load_annotations()
    ann = annotations["annotations"].get(ann_id)
    if not ann:
        return Response(to_xml(toast("Annotation not found.", "error")), status_code=404,
                        headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"})

    from datetime import datetime, timezone
    ann["status"] = "skipped"
    ann["reviewed_by"] = user.email if user else "admin"
    ann["reviewed_at"] = datetime.now(timezone.utc).isoformat()
    _save_annotations(annotations)

    _log_audit("skipped", ann_id, user.email if user else "admin", ann["value"])

    return Div(
        Div(
            Span("SKIPPED", cls="text-sm font-bold text-amber-400"),
            Span(f' — "{ann["value"]}" by {ann["submitted_by"]}', cls="text-sm text-slate-400"),
            cls="flex-1"
        ),
        Button("Undo",
               hx_post=f"/admin/approvals/{ann_id}/undo",
               hx_target=f"#annotation-{ann_id}",
               hx_swap="outerHTML",
               cls="px-3 py-1 text-xs bg-slate-600 text-white rounded hover:bg-slate-500 ml-2 flex-shrink-0"),
        cls="bg-amber-900/20 rounded-lg p-4 border border-amber-700 flex items-center",
        id=f"annotation-{ann_id}"
    )


@rt("/admin/approvals/{ann_id}/undo")
def post(ann_id: str, sess=None):
    """Undo a previous approve/reject/skip — reverts annotation to pending."""
    denied = _check_admin(sess)
    if denied:
        return denied

    user = get_current_user(sess)
    annotations = _load_annotations()
    ann = annotations["annotations"].get(ann_id)
    if not ann:
        return Response(to_xml(toast("Annotation not found.", "error")), status_code=404,
                        headers={"HX-Reswap": "beforeend", "HX-Retarget": "#toast-container"})

    from datetime import datetime, timezone
    old_status = ann["status"]
    ann["status"] = "pending" if ann.get("submitted_by") != "anonymous" else "pending_unverified"
    ann["reviewed_by"] = None
    ann["reviewed_at"] = None
    _save_annotations(annotations)

    _log_audit("undone", ann_id, user.email if user else "admin",
               f"Reverted from {old_status} to {ann['status']}")

    # Return the annotation back to its original pending card form
    # Redirect browser to refresh the approvals page
    return Response("", status_code=200,
                    headers={"HX-Redirect": "/admin/approvals"})


def _log_audit(action: str, annotation_id: str, admin: str, details: str = ""):
    """Append an entry to the audit log."""
    from datetime import datetime, timezone
    audit_path = data_path / "audit_log.json"

    audit = {"entries": []}
    if audit_path.exists():
        try:
            audit = json.loads(audit_path.read_text(encoding="utf-8"))
        except (json.JSONDecodeError, ValueError):
            audit = {"entries": []}

    audit["entries"].append({
        "action": action,
        "annotation_id": annotation_id,
        "admin": admin,
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "details": details,
    })

    audit_path.write_text(json.dumps(audit, indent=2, ensure_ascii=False), encoding="utf-8")


# =============================================================================
# ADMIN: ML BIRTH YEAR BULK REVIEW (Gatekeeper Pattern — AD-097)
# =============================================================================

@rt("/admin/review/birth-years")
def get(sess=None):
    """Admin bulk review page for ML birth year estimates."""
    denied = _check_admin(sess)
    if denied:
        return denied

    pending = _get_pending_ml_birth_year_suggestions()
    crop_files = get_crop_files()
    registry = load_registry()

    rows = []
    for item in pending:
        iid = item["identity_id"]
        name = item["name"]
        est = item["birth_year_estimate"]
        conf = (item["birth_year_confidence"] or "low").capitalize()
        est_range = item.get("birth_year_range", [])
        range_str = f"{est_range[0]}\u2013{est_range[1]}" if len(est_range) == 2 else ""
        n_photos = item.get("n_with_age_data", 0)

        conf_cls = {
            "High": "text-emerald-400 bg-emerald-500/10 border-emerald-500/20",
            "Medium": "text-amber-400 bg-amber-500/10 border-amber-500/20",
            "Low": "text-slate-400 bg-slate-500/10 border-slate-500/20",
        }.get(conf, "text-slate-400 bg-slate-500/10 border-slate-500/20")

        # Get face crop
        try:
            identity = registry.get_identity(iid)
            all_faces = identity.get("anchor_ids", []) + identity.get("candidate_ids", [])
            best_fid = get_best_face_id(all_faces)
            crop_url = resolve_face_image_url(best_fid, crop_files) if best_fid and crop_files else None
        except KeyError:
            crop_url = None

        # Evidence preview (top 3)
        evidence = item.get("evidence", [])[:3]
        evidence_items = []
        for ev in evidence:
            py = ev.get("photo_year", "?")
            age = ev.get("estimated_age", "?")
            evidence_items.append(
                Span(f"{py}: age ~{age}", cls="text-xs text-slate-500 block")
            )

        rows.append(
            Div(
                Div(
                    # Face crop
                    Img(src=crop_url, alt=name,
                        cls="w-14 h-14 rounded-lg object-cover border border-slate-700",
                        onerror="this.style.display='none'") if crop_url else Div(
                        Span("?", cls="text-xl text-slate-500"),
                        cls="w-14 h-14 rounded-lg bg-slate-800 border border-slate-700 flex items-center justify-center",
                    ),
                    # Info
                    Div(
                        A(name, href=f"/person/{iid}", cls="text-white text-sm font-medium hover:text-indigo-400"),
                        Div(
                            Span(f"Born c. {est}", cls="text-slate-300 text-sm"),
                            Span(f" ({range_str})" if range_str else "", cls="text-slate-500 text-xs"),
                            cls="mt-0.5",
                        ),
                        Div(
                            Span(conf, cls=f"text-xs px-2 py-0.5 rounded-full border {conf_cls} mr-2"),
                            Span(f"{n_photos} photo{'s' if n_photos != 1 else ''} with age data", cls="text-xs text-slate-500"),
                        ),
                        cls="ml-3 flex-1 min-w-0",
                    ),
                    cls="flex items-center",
                ),
                # Evidence preview (collapsible)
                Details(
                    Summary("Evidence", cls="text-xs text-indigo-400 cursor-pointer hover:text-indigo-300 mt-2"),
                    Div(*evidence_items, cls="mt-1 ml-2") if evidence_items else Span("No evidence", cls="text-xs text-slate-600"),
                    cls="mt-1",
                ) if evidence else None,
                # Actions
                Div(
                    Button("Accept", type="button",
                           hx_post=f"/api/ml-review/birth-year/{iid}/accept",
                           hx_target=f"#review-row-{iid}",
                           hx_swap="outerHTML",
                           hx_vals=json.dumps({"birth_year": est}),
                           cls="px-3 py-1 bg-emerald-600 hover:bg-emerald-500 text-white text-xs rounded"),
                    # Inline edit field with form
                    Form(
                        Input(type="number", name="birth_year", value=str(est),
                              cls="bg-slate-700 border border-slate-600 rounded px-2 py-1 text-xs text-white w-20"),
                        Input(type="hidden", name="source_detail", value="admin_bulk_review"),
                        Button("Save Edit", type="submit",
                               cls="px-2 py-1 bg-indigo-600 hover:bg-indigo-500 text-white text-xs rounded"),
                        hx_post=f"/api/ml-review/birth-year/{iid}/accept",
                        hx_target=f"#review-row-{iid}",
                        hx_swap="outerHTML",
                        cls="inline-flex items-center gap-1",
                    ),
                    Button("Reject", type="button",
                           hx_post=f"/api/ml-review/birth-year/{iid}/reject",
                           hx_target=f"#review-row-{iid}",
                           hx_swap="outerHTML",
                           cls="px-3 py-1 bg-red-600/80 hover:bg-red-500 text-white text-xs rounded"),
                    cls="flex items-center gap-2 mt-3",
                ),
                id=f"review-row-{iid}",
                cls="bg-slate-800/50 border border-slate-700/50 rounded-lg p-4 mb-3",
                data_testid="review-row",
            )
        )

    # Accept all high-confidence button
    high_count = sum(1 for p in pending if p["birth_year_confidence"] == "high")
    accept_all_btn = None
    if high_count > 0:
        accept_all_btn = Div(
            Button(
                f"Accept All High-Confidence ({high_count})",
                hx_post="/api/ml-review/birth-year/accept-all-high",
                hx_target="#review-list",
                hx_swap="innerHTML",
                hx_confirm=f"Accept {high_count} high-confidence birth year estimates?",
                cls="px-4 py-2 bg-emerald-600 hover:bg-emerald-500 text-white text-sm rounded-lg",
            ),
            cls="mb-4",
        )

    page_style = Style("html, body { margin: 0; } body { background-color: #0f172a; }")
    return (
        Title("ML Birth Year Review - Rhodesli Admin"),
        page_style,
        Main(
            _admin_nav_bar("birth-year-review"),
            Div(
                H1("ML Birth Year Estimates", cls="text-2xl font-serif font-bold text-white mb-2"),
                P(f"{len(pending)} pending review", cls="text-slate-400 text-sm mb-6"),
                accept_all_btn,
                Div(*rows, id="review-list") if rows else P("All estimates have been reviewed.", cls="text-slate-500 text-center py-8"),
                cls="max-w-3xl mx-auto px-6 py-8",
            ),
            cls="min-h-screen bg-slate-900",
        ),
    )


@rt("/api/ml-review/birth-year/accept-all-high")
def post(sess=None):
    """Accept all high-confidence ML birth year estimates at once."""
    denied = _check_admin(sess)
    if denied:
        return denied

    pending = _get_pending_ml_birth_year_suggestions()
    high_confidence = [p for p in pending if p["birth_year_confidence"] == "high"]

    registry = load_registry()
    decisions = dict(_load_ml_review_decisions())
    accepted_count = 0

    for item in high_confidence:
        iid = item["identity_id"]
        by = item["birth_year_estimate"]

        try:
            identity = registry.get_identity(iid)
        except KeyError:
            continue

        # Write to canonical identity metadata
        registry.set_metadata(iid, {"birth_year": by}, user_source="admin_ml_bulk_review")

        # Record review decision
        decisions[iid] = {
            "action": "accepted",
            "birth_year": by,
            "original_ml_estimate": by,
            "source": "ml_accepted",
            "source_detail": "bulk_high_confidence_review",
            "decided_at": datetime.now(timezone.utc).isoformat(),
            "decided_by": "admin",
        }

        # Write ground truth
        _save_ground_truth_birth_year(
            identity_id=iid,
            identity=registry.get_identity(iid),
            birth_year=by,
            source="ml_accepted",
            source_detail="bulk_high_confidence_review",
            original_ml_estimate=by,
        )
        accepted_count += 1

    save_registry(registry)
    _save_ml_review_decisions(decisions)

    return Div(
        Div(
            Span(f"\u2705 Accepted {accepted_count} high-confidence estimates", cls="text-emerald-400 text-sm"),
            cls="bg-emerald-500/5 border border-emerald-500/20 rounded-lg p-4 text-center mb-4",
        ),
        A("Refresh page", href="/admin/review/birth-years", cls="text-indigo-400 hover:text-indigo-300 text-sm"),
        data_testid="bulk-accept-result",
    )


@rt("/admin/audit")
def get(sess=None):
    """Admin audit log — shows all annotation review actions."""
    denied = _check_admin(sess)
    if denied:
        return denied

    audit_path = data_path / "audit_log.json"
    entries = []
    if audit_path.exists():
        try:
            audit = json.loads(audit_path.read_text(encoding="utf-8"))
            entries = audit.get("entries", [])
        except (json.JSONDecodeError, ValueError):
            pass

    # Most recent first
    entries = list(reversed(entries))

    rows = []
    for entry in entries[:100]:
        action_colors = {
            "approved": "text-emerald-400",
            "rejected": "text-red-400",
            "skipped": "text-amber-400",
            "undone": "text-slate-400",
        }
        color = action_colors.get(entry.get("action", ""), "text-slate-400")
        rows.append(Div(
            Span(entry.get("action", "unknown").upper(), cls=f"text-sm font-bold {color} w-24"),
            Span(entry.get("details", "")[:80], cls="text-sm text-slate-300 flex-1 truncate"),
            Span(entry.get("admin", ""), cls="text-xs text-slate-500 w-40 text-right"),
            Span(entry.get("timestamp", "")[:19].replace("T", " "), cls="text-xs text-slate-600 w-36 text-right"),
            cls="flex items-center gap-2 py-2 border-b border-slate-800"
        ))

    if not rows:
        rows = [P("No audit entries yet.", cls="text-slate-400 text-center py-12")]

    return Title("Audit Log — Rhodesli"), Div(
        _admin_nav_bar("audit"),
        Div(
            H1("Audit Log", cls="text-2xl font-bold text-white"),
            cls="mb-6"
        ),
        P(f"{len(entries)} audit entries", cls="text-sm text-slate-400 mb-4"),
        Div(*rows, cls="space-y-0"),
        cls="max-w-4xl mx-auto p-6"
    )


# --- GEDCOM Import (Session 35) ---


_gedcom_matches_cache = None


def _load_gedcom_matches():
    """Load GEDCOM match proposals from data/gedcom_matches.json."""
    global _gedcom_matches_cache
    if _gedcom_matches_cache is not None:
        return _gedcom_matches_cache

    matches_path = data_path / "gedcom_matches.json"
    if not matches_path.exists():
        _gedcom_matches_cache = {"schema_version": 1, "matches": [], "source_file": ""}
        return _gedcom_matches_cache

    try:
        _gedcom_matches_cache = json.loads(matches_path.read_text(encoding="utf-8"))
    except (json.JSONDecodeError, ValueError):
        _gedcom_matches_cache = {"schema_version": 1, "matches": [], "source_file": ""}

    return _gedcom_matches_cache


def _load_relationship_graph():
    """Load relationship graph from data/relationships.json."""
    rel_path = data_path / "relationships.json"
    if not rel_path.exists():
        return {"schema_version": 1, "relationships": [], "gedcom_imports": []}
    try:
        return json.loads(rel_path.read_text(encoding="utf-8"))
    except (json.JSONDecodeError, ValueError):
        return {"schema_version": 1, "relationships": [], "gedcom_imports": []}


def _save_relationship_graph(graph: dict):
    """Save relationship graph to data/relationships.json."""
    rel_path = data_path / "relationships.json"
    rel_path.write_text(json.dumps(graph, indent=2), encoding="utf-8")


@rt("/api/relationship/add")
def post(person_a: str, person_b: str, type: str, confidence: str = "confirmed", label: str = "", sess=None):
    """Add a relationship between two people (admin only)."""
    denied = _check_admin(sess)
    if denied:
        return denied
    from rhodesli_ml.graph.relationship_graph import add_relationship as _add_rel
    graph = _load_relationship_graph()
    graph = _add_rel(graph, person_a, person_b, type, "manual", confidence, label=label or None)
    _save_relationship_graph(graph)
    return Response("OK", status_code=200)


@rt("/api/relationship/update")
def post(person_a: str, person_b: str, type: str, confidence: str, sess=None):
    """Update relationship confidence (admin only)."""
    denied = _check_admin(sess)
    if denied:
        return denied
    from rhodesli_ml.graph.relationship_graph import update_relationship_confidence as _update_conf
    graph = _load_relationship_graph()
    graph = _update_conf(graph, person_a, person_b, type, confidence)
    _save_relationship_graph(graph)
    return Response("OK", status_code=200)


@rt("/api/relationship/remove")
def post(person_a: str, person_b: str, type: str, sess=None):
    """Remove a relationship (admin only, non-destructive)."""
    denied = _check_admin(sess)
    if denied:
        return denied
    from rhodesli_ml.graph.relationship_graph import remove_relationship as _remove_rel
    graph = _load_relationship_graph()
    graph = _remove_rel(graph, person_a, person_b, type)
    _save_relationship_graph(graph)
    return Response("OK", status_code=200)


@rt("/admin/gedcom")
def get(sess=None):
    """GEDCOM import admin page — upload + match review combined."""
    denied = _check_admin(sess)
    if denied:
        return denied

    matches_data = _load_gedcom_matches()
    matches = matches_data.get("matches", [])
    source_file = matches_data.get("source_file", "")

    pending = [m for m in matches if m.get("status") == "pending"]
    confirmed = [m for m in matches if m.get("status") == "confirmed"]
    rejected = [m for m in matches if m.get("status") == "rejected"]

    # Relationship graph stats
    rel_graph = _load_relationship_graph()
    rel_count = len(rel_graph.get("relationships", []))
    import_count = len(rel_graph.get("gedcom_imports", []))

    # Co-occurrence graph stats
    cooccur_path = data_path / "co_occurrence_graph.json"
    cooccur_count = 0
    if cooccur_path.exists():
        try:
            cooccur = json.loads(cooccur_path.read_text(encoding="utf-8"))
            cooccur_count = len(cooccur.get("edges", []))
        except (json.JSONDecodeError, ValueError):
            pass

    # Stats section
    stats_cards = Div(
        Div(
            P(str(len(matches)), cls="text-3xl font-bold text-white"),
            P("Total Matches", cls="text-sm text-slate-400"),
            cls="bg-slate-800 rounded-lg p-4 border border-slate-700 text-center"
        ),
        Div(
            P(str(len(pending)), cls="text-3xl font-bold text-amber-400"),
            P("Pending Review", cls="text-sm text-slate-400"),
            cls="bg-slate-800 rounded-lg p-4 border border-slate-700 text-center"
        ),
        Div(
            P(str(len(confirmed)), cls="text-3xl font-bold text-emerald-400"),
            P("Confirmed", cls="text-sm text-slate-400"),
            cls="bg-slate-800 rounded-lg p-4 border border-slate-700 text-center"
        ),
        Div(
            P(str(rel_count), cls="text-3xl font-bold text-indigo-400"),
            P("Relationships", cls="text-sm text-slate-400"),
            cls="bg-slate-800 rounded-lg p-4 border border-slate-700 text-center"
        ),
        Div(
            P(str(cooccur_count), cls="text-3xl font-bold text-purple-400"),
            P("Co-occurrences", cls="text-sm text-slate-400"),
            cls="bg-slate-800 rounded-lg p-4 border border-slate-700 text-center"
        ),
        cls="grid grid-cols-2 md:grid-cols-5 gap-3 mb-6"
    )

    # Upload section
    upload_section = Div(
        H2("Upload GEDCOM File", cls="text-lg font-semibold text-white mb-3"),
        P("Upload a .ged file exported from Ancestry, MyHeritage, FamilySearch, or other genealogy software.",
          cls="text-sm text-slate-400 mb-4"),
        Form(
            Input(type="file", name="gedcom_file", accept=".ged,.gedcom",
                  cls="block w-full text-sm text-slate-300 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-indigo-500 file:text-white hover:file:bg-indigo-400"),
            Button("Upload & Parse", type="submit",
                   cls="mt-3 px-4 py-2 bg-indigo-600 hover:bg-indigo-500 text-white rounded-lg text-sm font-medium"),
            hx_post="/admin/gedcom/upload",
            hx_target="#gedcom-results",
            hx_encoding="multipart/form-data",
            hx_indicator="#upload-spinner",
            cls="space-y-2"
        ),
        Span("Parsing...", id="upload-spinner", cls="htmx-indicator text-sm text-slate-400 ml-2"),
        Div(id="gedcom-results", cls="mt-4"),
        cls="bg-slate-800 rounded-lg p-5 border border-slate-700 mb-6"
    )

    # Pending matches section
    match_rows = []
    for m in sorted(pending, key=lambda x: x.get("match_score", 0), reverse=True):
        score_pct = int(m.get("match_score", 0) * 100)
        score_color = "text-emerald-400" if score_pct >= 90 else "text-amber-400" if score_pct >= 80 else "text-slate-400"

        ged_birth = f"b. {m.get('gedcom_birth_year', '?')}" if m.get('gedcom_birth_year') else ""
        ged_death = f"d. {m.get('gedcom_death_year', '?')}" if m.get('gedcom_death_year') else ""
        ged_place = m.get("gedcom_birth_place", "")

        match_rows.append(Div(
            # Left: GEDCOM person
            Div(
                P(m.get("gedcom_name", "?"), cls="text-white font-medium"),
                P(f"{ged_birth} {ged_death}".strip(), cls="text-sm text-slate-400") if ged_birth or ged_death else None,
                P(ged_place, cls="text-xs text-slate-500") if ged_place else None,
                cls="flex-1"
            ),
            # Arrow
            Span("→", cls="text-slate-500 text-xl px-3 self-center"),
            # Right: Archive identity
            Div(
                P(m.get("identity_name", "?"), cls="text-white font-medium"),
                P(m.get("match_reason", ""), cls="text-xs text-slate-500 mt-1"),
                cls="flex-1"
            ),
            # Score + actions
            Div(
                Span(f"{score_pct}%", cls=f"text-lg font-bold {score_color} mr-4"),
                Button("Confirm", cls="px-3 py-1 bg-emerald-600 hover:bg-emerald-500 text-white text-sm rounded-lg mr-1",
                       hx_post=f"/admin/gedcom/confirm/{m.get('gedcom_xref', '')}",
                       hx_target="closest div.gedcom-match-row", hx_swap="outerHTML"),
                Button("Reject", cls="px-3 py-1 bg-red-600/50 hover:bg-red-600 text-white text-sm rounded-lg mr-1",
                       hx_post=f"/admin/gedcom/reject/{m.get('gedcom_xref', '')}",
                       hx_target="closest div.gedcom-match-row", hx_swap="outerHTML"),
                Button("Skip", cls="px-3 py-1 bg-slate-600 hover:bg-slate-500 text-white text-sm rounded-lg",
                       hx_post=f"/admin/gedcom/skip/{m.get('gedcom_xref', '')}",
                       hx_target="closest div.gedcom-match-row", hx_swap="outerHTML"),
                cls="flex items-center flex-shrink-0"
            ),
            cls="gedcom-match-row flex items-start gap-2 bg-slate-800 rounded-lg p-4 border border-slate-700"
        ))

    matches_section = Div(
        Div(
            H2("Pending Matches", cls="text-lg font-semibold text-white"),
            Span(f"{len(pending)} pending", cls="text-sm text-amber-400 ml-2"),
            cls="flex items-center gap-2 mb-4"
        ),
        Div(*match_rows, cls="space-y-3") if match_rows else P("No pending matches. Upload a GEDCOM file to start.", cls="text-slate-400 text-center py-8"),
        cls="mb-6",
        id="gedcom-matches-list"
    )

    # Confirmed matches summary
    confirmed_section = None
    if confirmed:
        confirmed_rows = []
        for m in confirmed:
            confirmed_rows.append(Div(
                Span(m.get("gedcom_name", "?"), cls="text-emerald-400 font-medium"),
                Span("→", cls="text-slate-500 mx-2"),
                Span(m.get("identity_name", "?"), cls="text-white"),
                cls="text-sm py-1"
            ))
        confirmed_section = Div(
            H2(f"Confirmed ({len(confirmed)})", cls="text-lg font-semibold text-emerald-400 mb-3"),
            *confirmed_rows,
            cls="bg-slate-800/50 rounded-lg p-4 border border-slate-700/50 mb-6"
        )

    # Import history section
    import_history_section = None
    imports = rel_graph.get("gedcom_imports", [])
    if imports:
        import_rows = []
        for imp in imports:
            import_rows.append(Div(
                Span(imp.get("filename", "?"), cls="text-white font-medium text-sm"),
                Span(f" — {imp.get('individuals_count', 0)} individuals, {imp.get('families_count', 0)} families",
                     cls="text-slate-400 text-sm"),
                Span(f" — {imp.get('matches_confirmed', 0)} matched, {imp.get('relationships_added', 0)} relationships",
                     cls="text-emerald-400 text-sm"),
                P(imp.get("imported_at", "")[:10] if imp.get("imported_at") else "",
                  cls="text-xs text-slate-500"),
                cls="py-2 border-b border-slate-700/50 last:border-0",
            ))
        import_history_section = Div(
            H2("Import History", cls="text-lg font-semibold text-white mb-3"),
            *import_rows,
            cls="bg-slate-800/50 rounded-lg p-4 border border-slate-700/50 mb-6",
            data_testid="import-history",
        )

    # Enrichment status for confirmed matches
    enrichment_section = None
    if confirmed:
        registry = load_registry()
        enrichment_rows = []
        for m in confirmed:
            identity_id = m.get("identity_id", "")
            badges = []
            try:
                ident = registry.get_identity(identity_id)
                if ident:
                    meta = ident.get("metadata", {})
                    if meta.get("birth_date_full"):
                        badges.append(Span("birth", cls="text-[10px] px-1.5 py-0.5 rounded bg-emerald-900/40 text-emerald-400"))
                    if meta.get("death_date_full"):
                        badges.append(Span("death", cls="text-[10px] px-1.5 py-0.5 rounded bg-emerald-900/40 text-emerald-400"))
                    if meta.get("gender"):
                        badges.append(Span("gender", cls="text-[10px] px-1.5 py-0.5 rounded bg-emerald-900/40 text-emerald-400"))
                    if meta.get("birth_place"):
                        badges.append(Span("place", cls="text-[10px] px-1.5 py-0.5 rounded bg-emerald-900/40 text-emerald-400"))
                    if not badges:
                        badges.append(Span("no metadata", cls="text-[10px] px-1.5 py-0.5 rounded bg-slate-800 text-slate-500"))
            except (KeyError, TypeError):
                badges.append(Span("error", cls="text-[10px] px-1.5 py-0.5 rounded bg-red-900/40 text-red-400"))

            enrichment_rows.append(Div(
                Span(m.get("identity_name", "?"), cls="text-white text-sm mr-2"),
                *badges,
                cls="flex items-center gap-1.5 py-1",
                data_testid="enrichment-status",
            ))

        enrichment_section = Div(
            H2("Enrichment Status", cls="text-lg font-semibold text-white mb-3"),
            P("Metadata fields applied from GEDCOM data:", cls="text-xs text-slate-500 mb-2"),
            *enrichment_rows,
            cls="bg-slate-800/50 rounded-lg p-4 border border-slate-700/50 mb-6",
        )

    # Test data warning
    test_data_warning = None
    if source_file and "test" in source_file.lower():
        test_data_warning = Div(
            P("This is test data — upload your real GEDCOM file to replace it.",
              cls="text-sm text-amber-200"),
            cls="bg-amber-900/30 border border-amber-700/50 rounded-lg px-4 py-3 mb-6",
            data_testid="test-data-warning",
        )

    return Title("GEDCOM Import — Rhodesli"), Div(
        _admin_nav_bar("gedcom"),
        Div(
            H1("GEDCOM Import", cls="text-2xl font-bold text-white"),
            P(f"Source: {source_file}" if source_file else "No GEDCOM file imported yet",
              cls="text-sm text-slate-400"),
            cls="mb-6"
        ),
        test_data_warning,
        stats_cards,
        import_history_section,
        upload_section,
        matches_section,
        confirmed_section,
        enrichment_section,
        cls="max-w-4xl mx-auto p-6"
    )


@rt("/admin/gedcom/upload")
async def post(gedcom_file: UploadFile = None, sess=None):
    """Handle GEDCOM file upload — parse and generate match proposals."""
    denied = _check_admin(sess)
    if denied:
        return denied

    if not gedcom_file or not gedcom_file.filename:
        return Div(P("No file selected.", cls="text-red-400"), cls="mt-4")

    # Save uploaded file temporarily
    import tempfile
    content = await gedcom_file.read()
    with tempfile.NamedTemporaryFile(suffix=".ged", delete=False, mode="wb") as tmp:
        tmp.write(content)
        tmp_path = tmp.name

    try:
        from rhodesli_ml.importers.gedcom_parser import parse_gedcom
        from rhodesli_ml.importers.identity_matcher import match_gedcom_to_identities
        from rhodesli_ml.importers.gedcom_matches import save_gedcom_matches

        # Parse GEDCOM
        parsed = parse_gedcom(tmp_path)

        # Load identities for matching
        registry = load_registry()
        identities = {iid: registry.get_identity(iid) for iid in registry.list_identities()}

        # Load ML birth year estimates
        estimates = _load_birth_year_estimates()

        # Match
        result = match_gedcom_to_identities(
            parsed, identities,
            surname_variants_path=str(data_path / "surname_variants.json"),
            birth_year_estimates=estimates,
        )

        # Save match proposals
        save_gedcom_matches(
            result.proposals,
            filepath=str(data_path / "gedcom_matches.json"),
            source_file=gedcom_file.filename,
        )

        # Invalidate cache
        global _gedcom_matches_cache
        _gedcom_matches_cache = None

        return Div(
            P(f"Parsed {parsed.individual_count} individuals, {parsed.family_count} families",
              cls="text-emerald-400 font-medium"),
            P(f"Found {result.match_count} potential matches with archive identities",
              cls="text-white mt-1"),
            P(f"{len(result.unmatched_gedcom)} GEDCOM individuals unmatched",
              cls="text-sm text-slate-400 mt-1") if result.unmatched_gedcom else None,
            A("Refresh to review matches", href="/admin/gedcom",
              cls="inline-block mt-3 text-indigo-400 hover:text-indigo-300 underline text-sm"),
            cls="bg-emerald-900/20 border border-emerald-700/50 rounded-lg p-4 mt-4"
        )
    except Exception as e:
        logging.exception("GEDCOM parse error")
        return Div(P(f"Error parsing GEDCOM: {e}", cls="text-red-400"), cls="mt-4")
    finally:
        import os as _os
        try:
            _os.unlink(tmp_path)
        except OSError:
            pass


@rt("/admin/gedcom/confirm/{xref}")
def post(xref: str, sess=None):
    """Confirm a GEDCOM-to-identity match and apply enrichment."""
    denied = _check_admin(sess)
    if denied:
        return denied

    from rhodesli_ml.importers.gedcom_matches import update_match_status

    # Update status
    matches_data = update_match_status(
        filepath=str(data_path / "gedcom_matches.json"),
        gedcom_xref=xref,
        status="confirmed",
    )

    # Find the confirmed match
    match = None
    for m in matches_data.get("matches", []):
        if m.get("gedcom_xref") == xref:
            match = m
            break

    if not match:
        return Div(P("Match not found.", cls="text-red-400"))

    # Apply enrichment to identity
    registry = load_registry()
    identity_id = match.get("identity_id", "")
    updates = {}

    if match.get("gedcom_birth_year"):
        updates["birth_year"] = match["gedcom_birth_year"]
    if match.get("gedcom_death_year"):
        updates["death_year"] = match["gedcom_death_year"]
    if match.get("gedcom_birth_place"):
        updates["birth_place"] = match["gedcom_birth_place"]

    if updates:
        registry.set_metadata(identity_id, updates, user_source="gedcom")
        save_registry(registry)

    # Invalidate caches
    global _gedcom_matches_cache, _birth_year_cache
    _gedcom_matches_cache = None
    _birth_year_cache = None

    return Div(
        Span(match.get("gedcom_name", "?"), cls="text-emerald-400 font-medium"),
        Span("→", cls="text-slate-500 mx-2"),
        Span(match.get("identity_name", "?"), cls="text-white font-medium"),
        Span("Confirmed", cls="ml-3 px-2 py-0.5 bg-emerald-600/30 text-emerald-400 text-xs rounded"),
        cls="flex items-center py-3 px-4 bg-emerald-900/10 rounded-lg border border-emerald-700/30"
    )


@rt("/admin/gedcom/reject/{xref}")
def post(xref: str, sess=None):
    """Reject a GEDCOM-to-identity match."""
    denied = _check_admin(sess)
    if denied:
        return denied

    from rhodesli_ml.importers.gedcom_matches import update_match_status

    matches_data = update_match_status(
        filepath=str(data_path / "gedcom_matches.json"),
        gedcom_xref=xref,
        status="rejected",
    )

    match = None
    for m in matches_data.get("matches", []):
        if m.get("gedcom_xref") == xref:
            match = m
            break

    global _gedcom_matches_cache
    _gedcom_matches_cache = None

    return Div(
        Span(match.get("gedcom_name", "?") if match else "?", cls="text-red-400/50 line-through"),
        Span("→", cls="text-slate-600 mx-2"),
        Span(match.get("identity_name", "?") if match else "?", cls="text-slate-500 line-through"),
        Span("Rejected", cls="ml-3 px-2 py-0.5 bg-red-600/20 text-red-400 text-xs rounded"),
        cls="flex items-center py-3 px-4 bg-red-900/5 rounded-lg border border-red-700/20 opacity-60"
    )


@rt("/admin/gedcom/skip/{xref}")
def post(xref: str, sess=None):
    """Skip a GEDCOM match for later review."""
    denied = _check_admin(sess)
    if denied:
        return denied

    from rhodesli_ml.importers.gedcom_matches import update_match_status

    update_match_status(
        filepath=str(data_path / "gedcom_matches.json"),
        gedcom_xref=xref,
        status="skipped",
    )

    global _gedcom_matches_cache
    _gedcom_matches_cache = None

    return Div(
        Span("Skipped — will reappear on refresh", cls="text-slate-500 text-sm italic"),
        cls="py-3 px-4"
    )


# --- Admin Review Queue (Feature 5: Active Learning Priority Queue) ---


def _compute_correction_priority(label: dict) -> float:
    """Compute priority score for a photo date label.

    Higher score = more urgent to review.
    Score formula from PRD 005:
      (1 - confidence_numeric) * range_width_normalized * (1 + temporal_conflict_flag)
    """
    confidence = label.get("confidence", "medium")
    conf_numeric = {"high": 0.9, "medium": 0.6, "low": 0.3}.get(confidence, 0.5)

    prob_range = label.get("probable_range", [])
    if len(prob_range) == 2:
        range_width = abs(prob_range[1] - prob_range[0])
    else:
        range_width = 20  # Default wide range if unknown
    range_normalized = range_width / 50.0

    # temporal_conflict_flag would come from audit data — for now, default to 0
    temporal_flag = 0

    return (1.0 - conf_numeric) * range_normalized * (1.0 + temporal_flag)


def _get_priority_reason(label: dict) -> str:
    """Generate human-readable reason for review priority."""
    reasons = []
    confidence = label.get("confidence", "medium")
    if confidence == "low":
        reasons.append("Low confidence")
    prob_range = label.get("probable_range", [])
    if len(prob_range) == 2:
        width = abs(prob_range[1] - prob_range[0])
        if width >= 15:
            reasons.append(f"Wide date range ({prob_range[0]}\u2013{prob_range[1]})")
    return " \u00b7 ".join(reasons) if reasons else "Routine review"


@rt("/admin/review-queue")
def get(sess=None):
    """Admin review queue — photos sorted by correction priority score."""
    denied = _check_admin(sess)
    if denied:
        return denied

    labels = _load_date_labels()
    _build_caches()

    # Score all photos, exclude already-verified ones and duplicates
    scored = []
    seen_labels = set()  # Track by label id() to skip dual-keyed duplicates
    for photo_id, label in labels.items():
        if id(label) in seen_labels:
            continue
        seen_labels.add(id(label))
        if label.get("source") == "human":
            continue  # Already verified
        # Prefer SHA256 cache ID for display (matches _photo_cache and /photo/{id} URLs)
        cache_id = photo_id
        if photo_id.startswith("inbox_"):
            # Check if there's a SHA256 alias that maps to a _photo_cache entry
            for k, v in labels.items():
                if v is label and not k.startswith("inbox_"):
                    cache_id = k
                    break
        photo_id = cache_id
        score = _compute_correction_priority(label)
        scored.append((photo_id, label, score))

    # Sort by priority (highest first)
    scored.sort(key=lambda x: -x[2])

    # Build review items
    items = []
    for photo_id, label, score in scored[:50]:  # Show top 50
        decade = label.get("estimated_decade", "")
        best_year = label.get("best_year_estimate", "")
        confidence = label.get("confidence", "medium")
        reason = _get_priority_reason(label)

        # Get photo filename for thumbnail
        photo_data = (_photo_cache or {}).get(photo_id)
        if not photo_data:
            # Try looking up by cache_photo_id
            for pid, pdata in (_photo_cache or {}).items():
                if pid == photo_id:
                    photo_data = pdata
                    break
        filename = photo_data.get("filename", "") if photo_data else ""

        conf_cls = {
            "high": "text-emerald-400",
            "medium": "text-amber-400",
            "low": "text-red-400",
        }.get(confidence, "text-slate-400")

        items.append(
            Div(
                A(
                    Img(
                        src=photo_url(filename) if filename else "",
                        cls="w-20 h-20 object-cover rounded",
                        loading="lazy",
                    ),
                    href=f"/photo/{photo_id}",
                    cls="shrink-0",
                ) if filename else Div(cls="w-20 h-20 bg-slate-800 rounded"),
                Div(
                    Div(
                        Span(f"c. {best_year}" if best_year else f"{decade}s", cls="font-serif text-amber-200"),
                        Span(f" ({confidence})", cls=f"text-xs {conf_cls} ml-1"),
                        cls="mb-1",
                    ),
                    P(reason, cls="text-xs text-slate-400 mb-2"),
                    Div(
                        A("Confirm AI", href=f"/api/photo/{photo_id}/confirm-date",
                          cls="text-xs px-2 py-1 bg-emerald-600/30 text-emerald-400 rounded hover:bg-emerald-600/50 transition-colors",
                          hx_post=f"/api/photo/{photo_id}/confirm-date",
                          hx_target=f"#review-{photo_id[:8]}",
                          hx_swap="outerHTML"),
                        A("View & Correct", href=f"/photo/{photo_id}",
                          cls="text-xs px-2 py-1 bg-indigo-600/30 text-indigo-400 rounded hover:bg-indigo-600/50 transition-colors"),
                        cls="flex gap-2",
                    ),
                    cls="flex-1",
                ),
                Div(
                    Span(f"{score:.3f}", cls="text-[10px] text-slate-600 font-mono"),
                    cls="shrink-0",
                ),
                cls="flex items-start gap-3 p-3 bg-slate-800/50 rounded-lg border border-slate-700/50",
                id=f"review-{photo_id[:8]}",
                data_testid="review-item",
                data_priority=f"{score:.4f}",
            )
        )

    if not items:
        items = [P("All photos have been reviewed!", cls="text-slate-400 text-center py-12")]

    return Title("Review Queue \u2014 Rhodesli"), Div(
        Div(
            H1("Date Review Queue", cls="text-2xl font-bold text-white"),
            P(f"{len(scored)} photos need review", cls="text-sm text-slate-400"),
            cls="mb-6",
        ),
        Div(*items, cls="space-y-2"),
        cls="max-w-3xl mx-auto p-6",
    )


@rt("/api/photo/{photo_id}/confirm-date")
async def post(photo_id: str, sess=None):
    """Confirm AI date estimate — sets source to 'human' without changing the value."""
    denied = _check_admin(sess)
    if denied:
        return denied

    labels = _load_date_labels()
    label = labels.get(photo_id)
    if not label:
        return Div(Span("Label not found", cls="text-red-400"), id=f"review-{photo_id[:8]}")

    # Log confirmation
    import uuid
    from datetime import datetime, timezone
    user = get_current_user(sess or {}) if is_auth_enabled() else None
    correction_entry = {
        "id": f"corr_{uuid.uuid4().hex[:12]}",
        "photo_id": photo_id,
        "field": "estimated_decade",
        "old_value": {"decade": label.get("estimated_decade"), "year": label.get("best_year_estimate")},
        "new_value": {"decade": label.get("estimated_decade"), "year": label.get("best_year_estimate")},
        "old_source": label.get("source", "gemini"),
        "new_source": "human",
        "contributor_email": user.email if user else "local",
        "contributor_type": "admin",
        "status": "confirmed",
        "timestamp": datetime.now(timezone.utc).isoformat(),
    }
    log = _load_corrections_log()
    log["corrections"].append(correction_entry)
    _save_corrections_log(log)

    # Update in-memory label
    label["source"] = "human"

    return Div(
        Span("\u2713 Confirmed", cls="text-emerald-400 text-sm"),
        cls="p-3 bg-emerald-950/30 rounded-lg border border-emerald-700/30 text-center",
        id=f"review-{photo_id[:8]}",
    )


# --- Sync API Endpoints (token-authenticated, for scripts/sync_from_production.py) ---

def _check_sync_token(request):
    """Validate Bearer token for sync API. Returns None if valid, Response if not."""
    if not SYNC_API_TOKEN:
        return Response("Sync API not configured (RHODESLI_SYNC_TOKEN not set)", status_code=503)
    auth_header = request.headers.get("authorization", "")
    token = auth_header.replace("Bearer ", "") if auth_header.startswith("Bearer ") else ""
    if token != SYNC_API_TOKEN:
        return Response("Unauthorized", status_code=401)
    return None


@rt("/api/sync/status")
def get(request):
    """Public endpoint — shows data stats without requiring auth."""
    registry = load_registry()
    identities = registry.list_identities()
    confirmed = sum(1 for i in identities if i.get("state") == "CONFIRMED")
    proposed = sum(1 for i in identities if i.get("state") == "PROPOSED")
    inbox = sum(1 for i in identities if i.get("state") == "INBOX")

    photo_count = 0
    photo_index_path = data_path / "photo_index.json"
    if photo_index_path.exists():
        with open(photo_index_path) as f:
            index = json.load(f)
            photo_count = len(index.get("photos", {}))

    return {
        "identities": len(identities),
        "confirmed": confirmed,
        "proposed": proposed,
        "inbox": inbox,
        "photos": photo_count,
        "timestamp": datetime.now(timezone.utc).isoformat(),
    }


@rt("/api/sync/identities")
def get(request):
    """Download identities.json via sync token. For scripts/sync_from_production.py."""
    denied = _check_sync_token(request)
    if denied:
        return denied
    fpath = data_path / "identities.json"
    if not fpath.exists():
        return Response("File not found", status_code=404)
    with open(fpath) as f:
        data = json.load(f)
    return data


@rt("/api/sync/photo-index")
def get(request):
    """Download photo_index.json via sync token. For scripts/sync_from_production.py."""
    denied = _check_sync_token(request)
    if denied:
        return denied
    fpath = data_path / "photo_index.json"
    if not fpath.exists():
        return Response("File not found", status_code=404)
    with open(fpath) as f:
        data = json.load(f)
    return data


@rt("/api/sync/annotations")
def get(request):
    """Download annotations.json via sync token. For scripts/sync_from_production.py."""
    denied = _check_sync_token(request)
    if denied:
        return denied
    annotations = _load_annotations()
    return annotations


# --- Staged Files API (for downloading uploads from production to local ML) ---

@rt("/api/sync/staged")
def get(request):
    """List all staged upload files awaiting local ML processing."""
    denied = _check_sync_token(request)
    if denied:
        return denied

    staging_dir = data_path / "staging"
    if not staging_dir.exists():
        return {"files": [], "total_files": 0, "total_size_bytes": 0}

    files = []
    total_size = 0
    for fpath in staging_dir.rglob("*"):
        if not fpath.is_file():
            continue
        rel = fpath.relative_to(staging_dir)
        size = fpath.stat().st_size
        mtime = datetime.fromtimestamp(fpath.stat().st_mtime, tz=timezone.utc).isoformat()
        files.append({
            "filename": fpath.name,
            "path": str(rel),
            "size_bytes": size,
            "uploaded_at": mtime,
        })
        total_size += size

    return {"files": files, "total_files": len(files), "total_size_bytes": total_size}


@app.get("/api/sync/staged/download/{filepath:path}")
async def download_staged_file(request, filepath: str):
    """Download a single staged file. Path is relative to staging root."""
    denied = _check_sync_token(request)
    if denied:
        return denied

    # Security: block path traversal
    if ".." in filepath or filepath.startswith("/"):
        return Response("Invalid path", status_code=400)

    staging_dir = data_path / "staging"
    target = (staging_dir / filepath).resolve()

    # Ensure resolved path is still inside staging dir
    if not str(target).startswith(str(staging_dir.resolve())):
        return Response("Invalid path", status_code=400)

    if not target.exists() or not target.is_file():
        return Response("File not found", status_code=404)

    return FileResponse(
        str(target),
        filename=target.name,
        media_type="application/octet-stream",
    )

# Move staged download route before FastHTML's catch-all static route
# (same issue as /photos/{filename:path} — the /{fname:path}.{ext:static}
# catch-all would intercept .jpg/.png paths before our handler)
for i, route in enumerate(app.routes):
    if getattr(route, "path", None) == "/api/sync/staged/download/{filepath:path}":
        _staged_route = app.routes.pop(i)
        app.routes.insert(0, _staged_route)
        break


@rt("/api/sync/staged/clear")
async def post(request):
    """Remove staged files after successful download and processing."""
    denied = _check_sync_token(request)
    if denied:
        return denied

    import shutil

    body = await request.json()
    staging_dir = data_path / "staging"

    if body.get("all"):
        # Clear entire staging directory
        removed = []
        if staging_dir.exists():
            for item in list(staging_dir.iterdir()):
                if item.is_dir():
                    shutil.rmtree(item, ignore_errors=True)
                else:
                    item.unlink(missing_ok=True)
                removed.append(str(item.relative_to(staging_dir)))
        return {"cleared": "all", "removed": removed, "count": len(removed)}

    file_list = body.get("files", [])
    if not file_list:
        return Response("No files specified", status_code=400)

    removed = []
    errors = []
    for rel_path in file_list:
        if ".." in rel_path or rel_path.startswith("/"):
            errors.append({"path": rel_path, "error": "invalid path"})
            continue
        target = (staging_dir / rel_path).resolve()
        if not str(target).startswith(str(staging_dir.resolve())):
            errors.append({"path": rel_path, "error": "invalid path"})
            continue
        if target.exists():
            if target.is_dir():
                shutil.rmtree(target, ignore_errors=True)
            else:
                target.unlink(missing_ok=True)
            removed.append(rel_path)
            # Clean up empty parent directories
            parent = target.parent
            while parent != staging_dir and parent.exists():
                if not any(parent.iterdir()):
                    parent.rmdir()
                    parent = parent.parent
                else:
                    break
        else:
            errors.append({"path": rel_path, "error": "not found"})

    return {"removed": removed, "errors": errors, "count": len(removed)}


@rt("/api/sync/staged/mark-processed")
async def post(request):
    """Mark staging jobs as processed in pending_uploads.json.

    Called by the pipeline after successful processing to remove jobs from
    the Pending Uploads admin page.

    Accepts JSON body with:
        job_ids: list of job IDs to mark as processed
        all: bool — mark ALL staged jobs as processed
    """
    denied = _check_sync_token(request)
    if denied:
        return denied

    body = await request.json()
    pending = _load_pending_uploads()

    marked = []
    if body.get("all"):
        for job_id, upload in pending["uploads"].items():
            if upload.get("status") == "staged":
                upload["status"] = "processed"
                upload["processed_at"] = datetime.now(timezone.utc).isoformat()
                marked.append(job_id)
    else:
        job_ids = body.get("job_ids", [])
        if not job_ids:
            return Response("Must provide 'job_ids' or 'all'", status_code=400)
        for job_id in job_ids:
            if job_id in pending["uploads"]:
                upload = pending["uploads"][job_id]
                if upload.get("status") in ("staged", "approved"):
                    upload["status"] = "processed"
                    upload["processed_at"] = datetime.now(timezone.utc).isoformat()
                    marked.append(job_id)

    if marked:
        _save_pending_uploads(pending)

    return {"marked_processed": marked, "count": len(marked)}


# --- Push API (for pushing locally-processed data back to production) ---


@rt("/api/sync/push")
async def post(request):
    """Push updated identities.json and/or photo_index.json to production.

    Accepts JSON body with keys:
        identities: full identities.json content (optional)
        photo_index: full photo_index.json content (optional)

    Creates timestamped backups before overwriting.
    Protected by sync token (same as pull endpoints).
    """
    denied = _check_sync_token(request)
    if denied:
        return denied

    import shutil
    import time

    body = await request.json()

    if not body.get("identities") and not body.get("photo_index") and not body.get("annotations"):
        return Response(
            "Must provide 'identities', 'photo_index', and/or 'annotations' in request body",
            status_code=400,
        )

    results = {}
    ts = int(time.time())

    # Push identities.json
    if body.get("identities"):
        identities_data = body["identities"]
        # Basic validation: must have identities key or be a dict of identities
        if not isinstance(identities_data, dict):
            return Response("identities must be a JSON object", status_code=400)

        fpath = data_path / "identities.json"
        backup_path = data_path / f"identities.json.bak.{ts}"

        if fpath.exists():
            shutil.copy2(fpath, backup_path)

        with open(fpath, "w") as f:
            json.dump(identities_data, f, indent=2)

        # Count what we received
        id_data = identities_data.get("identities", identities_data)
        results["identities"] = {
            "status": "written",
            "count": len(id_data),
            "backup": backup_path.name,
        }

    # Push photo_index.json
    if body.get("photo_index"):
        photo_data = body["photo_index"]
        if not isinstance(photo_data, dict):
            return Response("photo_index must be a JSON object", status_code=400)

        fpath = data_path / "photo_index.json"
        backup_path = data_path / f"photo_index.json.bak.{ts}"

        if fpath.exists():
            shutil.copy2(fpath, backup_path)

        with open(fpath, "w") as f:
            json.dump(photo_data, f, indent=2)

        photos = photo_data.get("photos", {})
        results["photo_index"] = {
            "status": "written",
            "count": len(photos),
            "backup": backup_path.name,
        }

    # Push annotations.json
    if body.get("annotations"):
        ann_data = body["annotations"]
        if not isinstance(ann_data, dict):
            return Response("annotations must be a JSON object", status_code=400)

        fpath = data_path / "annotations.json"
        backup_path = data_path / f"annotations.json.bak.{ts}"

        if fpath.exists():
            shutil.copy2(fpath, backup_path)

        with open(fpath, "w") as f:
            json.dump(ann_data, f, indent=2, ensure_ascii=False)

        ann_count = len(ann_data.get("annotations", {}))
        results["annotations"] = {
            "status": "written",
            "count": ann_count,
            "backup": backup_path.name,
        }

    # Invalidate ALL in-memory caches so subsequent requests see the new data
    global _photo_registry_cache, _face_data_cache, _proposals_cache, _skipped_neighbor_cache, _skipped_neighbor_cache_key, _photo_cache, _face_to_photo_cache, _annotations_cache, _date_labels_cache, _search_index_cache, _context_events_cache, _birth_year_cache, _ml_review_decisions_cache, _gedcom_matches_cache, _photo_locations_cache, _comparison_results_cache
    _photo_registry_cache = None
    _face_data_cache = None
    _proposals_cache = None
    _skipped_neighbor_cache = None
    _skipped_neighbor_cache_key = None
    _photo_cache = None
    _face_to_photo_cache = None
    _annotations_cache = None
    _date_labels_cache = None
    _search_index_cache = None
    _context_events_cache = None
    _birth_year_cache = None
    _ml_review_decisions_cache = None
    _gedcom_matches_cache = None
    _photo_locations_cache = None
    _comparison_results_cache = None

    return {"status": "ok", "results": results, "timestamp": ts}


# =============================================================================
# ROUTES - MATCH MODE (Gamified Pairing)
# =============================================================================


def _log_match_decision(identity_a: str, identity_b: str, decision: str,
                        confidence: int, sess=None):
    """
    Log a match decision for audit trail and future ML training.

    Appends to data/match_decisions.jsonl (one JSON object per line).
    """
    import json as _json
    from datetime import datetime, timezone

    user_email = ""
    if sess:
        user = get_current_user(sess)
        if user:
            user_email = user.email

    entry = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "identity_a": identity_a,
        "identity_b": identity_b,
        "decision": decision,
        "confidence_pct": confidence,
        "user": user_email,
    }

    log_path = Path(DATA_DIR) / "match_decisions.jsonl"
    try:
        with open(log_path, "a") as f:
            f.write(_json.dumps(entry) + "\n")
    except Exception as e:
        print(f"[match] Failed to log decision: {e}")


def _get_best_match_pair(triage_filter: str = ""):
    """
    Find the best pair of identities to show in match mode.

    Returns (identity_a, identity_b, distance) or None if no pairs available.

    Args:
        triage_filter: Optional filter to scope pairs:
            - "ready": Only proposal pairs (skip NN fallback)
            - "rediscovered": Only pairs where source has promoted_from
            - "unmatched": Skip proposals, NN search only for non-proposal faces
            - "": All pairs (default behavior)

    Priority:
    1. Clustering proposals (pre-computed, highest confidence first)
    2. Live nearest-neighbor search (fallback when proposals exhausted)
    """
    registry = load_registry()
    face_data = get_face_data()
    photo_registry = load_photo_registry()

    ids_with_proposals = _get_identities_with_proposals()

    # Priority 1: Check clustering proposals (skip for "unmatched" filter)
    if triage_filter != "unmatched":
        proposals_data = _load_proposals()
        for proposal in proposals_data.get("proposals", []):
            source_id = proposal["source_identity_id"]
            target_id = proposal["target_identity_id"]
            source = registry.get_identity(source_id)
            target = registry.get_identity(target_id)
            if not source or not target:
                continue
            # Skip if already merged or resolved
            if source.get("merged_into") or target.get("merged_into"):
                continue
            # Skip confirmed-confirmed pairs (already resolved)
            if source.get("state") == "CONFIRMED" and target.get("state") == "CONFIRMED":
                continue
            # Apply rediscovered filter: source must have promoted_from
            if triage_filter == "rediscovered" and not source.get("promoted_from"):
                continue
            # Valid proposal — return as match pair
            neighbor_info = {
                "identity_id": target_id,
                "name": target.get("name", "Unknown"),
                "state": target.get("state", ""),
                "distance": proposal["distance"],
                "face_count": len(target.get("anchor_ids", []) + target.get("candidate_ids", [])),
                "confidence": proposal.get("confidence", ""),
                "from_proposal": True,
            }
            return (source, neighbor_info, proposal["distance"])

    # Priority 2: Fallback to live nearest-neighbor search
    # Skip for "ready" filter (only proposals matter)
    if triage_filter == "ready":
        return None

    inbox = registry.list_identities(state=IdentityState.INBOX)
    proposed = registry.list_identities(state=IdentityState.PROPOSED)
    to_review = inbox + proposed

    # Apply filter to NN candidates
    if triage_filter == "rediscovered":
        to_review = [i for i in to_review if i.get("promoted_from") is not None]
    elif triage_filter == "unmatched":
        to_review = [i for i in to_review
                     if i.get("identity_id", "") not in ids_with_proposals
                     and not i.get("promoted_from")]

    if len(to_review) < 2:
        return None

    best_pair = None
    best_distance = float('inf')

    to_review.sort(
        key=lambda x: len(x.get("anchor_ids", []) + x.get("candidate_ids", [])),
        reverse=True
    )

    for identity in to_review[:20]:
        try:
            from core.neighbors import find_nearest_neighbors
            neighbors = find_nearest_neighbors(
                identity["identity_id"], registry, photo_registry, face_data, limit=1
            )
            if neighbors and neighbors[0]["distance"] < best_distance:
                best_distance = neighbors[0]["distance"]
                best_pair = (identity, neighbors[0], best_distance)
        except Exception:
            continue

    return best_pair


@rt("/api/match/next-pair")
def get(filter: str = "", sess=None):
    """
    Get the next pair of faces to compare in Match mode.

    Returns an HTMX partial with two large face crops side by side,
    confidence bar, clickable photos, and action buttons.

    Args:
        filter: Triage filter (ready/rediscovered/unmatched) to scope pairs.
    """
    pair = _get_best_match_pair(triage_filter=filter)

    if pair is None:
        _back_url = f"/?section=to_review&view=focus&filter={filter}" if filter else "/?section=to_review&view=focus"
        return Div(
            H3("No more pairs to match!", cls="text-lg font-medium text-white"),
            P("All available identities have been reviewed.", cls="text-slate-400 mt-2"),
            A("Back to Focus mode", href=_back_url,
              cls="inline-block mt-4 text-indigo-400 hover:text-indigo-300 font-medium"),
            cls="text-center py-12"
        )

    identity_a, neighbor_b, distance = pair
    identity_id_a = identity_a["identity_id"]
    identity_id_b = neighbor_b["identity_id"]

    crop_files = get_crop_files()

    # Get face data for both identities
    def _get_face_info(identity_data):
        face_ids = identity_data.get("anchor_ids", []) + identity_data.get("candidate_ids", [])
        if not face_ids:
            return None, None, None
        first = face_ids[0]
        fid = first if isinstance(first, str) else first.get("face_id", "")
        crop_url = resolve_face_image_url(fid, crop_files)
        photo_id = get_photo_id_for_face(fid)
        return fid, crop_url, photo_id

    face_id_a, crop_url_a, photo_id_a = _get_face_info(identity_a)
    try:
        registry = load_registry()
        identity_b_full = registry.get_identity(identity_id_b)
        face_id_b, crop_url_b, photo_id_b = _get_face_info(identity_b_full)
    except KeyError:
        face_id_b, crop_url_b, photo_id_b = None, None, None

    name_a = ensure_utf8_display(identity_a.get("name")) or f"Person {identity_id_a[:8]}..."
    name_b = ensure_utf8_display(neighbor_b.get("name")) or f"Person {identity_id_b[:8]}..."
    faces_a = len(identity_a.get("anchor_ids", []) + identity_a.get("candidate_ids", []))
    faces_b = neighbor_b.get("face_count", 0)

    # Confidence calculation (inverse distance, clamped 0-100)
    # Distance 0.0 = 100% confidence, distance 2.0 = 0%
    confidence_pct = max(0, min(100, int((1 - distance / 2.0) * 100)))

    # Color based on confidence
    if confidence_pct >= 70:
        bar_color = "bg-emerald-500"
        conf_label = "High"
        conf_text_cls = "text-emerald-400"
    elif confidence_pct >= 40:
        bar_color = "bg-amber-500"
        conf_label = "Medium"
        conf_text_cls = "text-amber-400"
    else:
        bar_color = "bg-red-500"
        conf_label = "Low"
        conf_text_cls = "text-red-400"

    # Build clickable face card
    def _face_card(name, crop_url, face_id, photo_id, face_count, iid=None):
        img_el = Img(
            src=crop_url or "", alt=name,
            cls="w-full h-full object-cover"
        ) if crop_url else Span("?", cls="text-6xl text-slate-500")

        # Make clickable to view source photo (with identity nav context)
        if photo_id:
            _fc_url = f"/photo/{photo_id}/partial?face={face_id}" if face_id else f"/photo/{photo_id}/partial"
            if iid:
                _fc_url += f"&identity_id={iid}"
            face_el = Button(
                Div(
                    img_el,
                    cls="w-full aspect-square rounded-xl overflow-hidden bg-slate-700 flex items-center justify-center"
                ),
                cls="p-0 bg-transparent cursor-pointer hover:ring-2 hover:ring-indigo-400 rounded-xl transition-all w-full",
                hx_get=_fc_url,
                hx_target="#photo-modal-content",
                **{"_": "on click remove .hidden from #photo-modal"},
                type="button",
                title="Click to view source photo",
            )
        else:
            face_el = Div(
                img_el,
                cls="w-full aspect-square rounded-xl overflow-hidden bg-slate-700 flex items-center justify-center"
            )

        return Div(
            face_el,
            P(name, cls="text-sm font-medium text-slate-200 mt-3 text-center truncate"),
            P(f"{face_count} face{'s' if face_count != 1 else ''}", cls="text-xs text-slate-500 text-center"),
            P("Click to view photo", cls="text-xs text-indigo-400 text-center mt-1") if photo_id else None,
            cls="flex-1 max-w-[280px]"
        )

    # Build filter query suffix for URL propagation
    filter_suffix = f"&filter={filter}" if filter else ""

    return Div(
        # Confidence bar
        Div(
            Div(
                Span(f"Match Confidence: {confidence_pct}%", cls=f"text-sm font-medium {conf_text_cls}"),
                Span(f"({conf_label})", cls=f"text-xs {conf_text_cls} ml-1"),
                Span(f"dist: {distance:.3f}", cls="text-xs font-data text-slate-500 ml-3"),
                cls="flex items-center justify-center mb-2"
            ),
            # Progress bar
            Div(
                Div(cls=f"{bar_color} h-full rounded-full transition-all", style=f"width: {confidence_pct}%"),
                cls="w-full max-w-md mx-auto h-2 bg-slate-700 rounded-full overflow-hidden"
            ),
            cls="mb-6"
        ),
        # Side by side faces — large display
        Div(
            _face_card(name_a, crop_url_a, face_id_a, photo_id_a, faces_a, iid=identity_id_a),
            # VS divider
            Div(
                Span("vs", cls="text-slate-500 text-xl font-bold"),
                cls="flex items-center justify-center px-6 pt-8"
            ),
            _face_card(name_b, crop_url_b, face_id_b, photo_id_b, faces_b, iid=identity_id_b),
            cls="flex flex-col sm:flex-row items-center sm:items-start justify-center gap-2"
        ),
        # Action buttons -- role-aware
        Div(
            Button(
                "Suggest Same" if _get_user_role(sess) == "contributor" else "Same Person",
                cls=f"px-8 py-3 text-sm font-bold {'bg-purple-600 hover:bg-purple-500' if _get_user_role(sess) == 'contributor' else 'bg-emerald-600 hover:bg-emerald-500'} text-white rounded-lg transition-colors min-h-[44px]",
                hx_post=f"/api/match/decide?identity_a={identity_id_a}&identity_b={identity_id_b}&decision=same&confidence={confidence_pct}{filter_suffix}",
                hx_target="#match-pair-container",
                hx_swap="innerHTML",
                type="button",
                id="match-btn-same",
                data_auth_action="identify these faces",
            ),
            Button(
                "Different People",
                cls="px-8 py-3 text-sm font-bold border-2 border-red-500 text-red-400 rounded-lg hover:bg-red-500/20 transition-colors min-h-[44px]",
                hx_post=f"/api/match/decide?identity_a={identity_id_a}&identity_b={identity_id_b}&decision=different&confidence={confidence_pct}{filter_suffix}",
                hx_target="#match-pair-container",
                hx_swap="innerHTML",
                type="button",
                id="match-btn-diff",
            ),
            Button(
                "Skip",
                cls="px-4 py-3 text-sm text-slate-400 hover:text-slate-300 transition-colors min-h-[44px]",
                hx_get=f"/api/match/next-pair?filter={filter}" if filter else "/api/match/next-pair",
                hx_target="#match-pair-container",
                hx_swap="innerHTML",
                type="button",
                id="match-btn-skip",
            ),
            Button(
                "Share This Match",
                cls="px-3 py-2 text-xs text-indigo-400 hover:text-indigo-300 border border-indigo-600/50 rounded-lg transition-colors min-h-[44px]",
                data_action="share-photo",
                data_share_url=f"{SITE_URL}/identify/{identity_id_a}/match/{identity_id_b}",
                data_share_title="Are these the same person?",
                data_share_text="Help us confirm if these two faces from the Rhodesli Heritage Archive are the same person.",
                type="button",
            ),
            Span(
                "Keyboard: Y N S",
                cls="text-xs text-slate-600 hidden sm:inline",
                title="Y=Same Person, N=Different People, S=Skip"
            ),
            cls="flex flex-wrap items-center justify-center gap-4 mt-8 pt-4 border-t border-slate-700"
        ),
        # Community response summary (if any)
        _match_community_summary(identity_id_a, identity_id_b),
        cls="match-pair"
    )


@rt("/api/match/decide")
def post(identity_a: str, identity_b: str, decision: str, confidence: int = 0, filter: str = "", sess=None):
    """
    Record a match decision, log it, and return the next pair.

    Args:
        identity_a: First identity ID
        identity_b: Second identity ID
        decision: "same" (merge) or "different" (reject pair)
        confidence: Match confidence percentage at time of decision
    """
    # Allow contributors to suggest (they can't merge but can say "same")
    user_role = _get_user_role(sess)
    if user_role == "contributor":
        denied = _check_contributor(sess)
    else:
        denied = _check_admin(sess)
    if denied:
        return denied

    # Log the decision
    _log_match_decision(identity_a, identity_b, decision, confidence, sess)

    # Contributors create merge suggestions instead of executing merges
    if decision == "same" and user_role == "contributor":
        user = get_current_user(sess)
        _create_merge_suggestion(
            target_id=identity_a, source_id=identity_b,
            submitted_by=user.email if user else "contributor",
            confidence="certain" if confidence >= 80 else "likely" if confidence >= 50 else "guess",
            reason=f"Matched in match mode (confidence: {confidence}%)",
        )
        oob_toast = Div(
            toast("Suggestion recorded! An admin will review it.", "success"),
            hx_swap_oob="beforeend:#toast-container",
        )
        counter_script = Div(
            Script("if (typeof incrementMatchCount === 'function') incrementMatchCount();"),
            hx_swap_oob="beforeend:body",
        )
        pair = _get_best_match_pair(triage_filter=filter)
        if pair is None:
            return (Div(
                H3("No more pairs!", cls="text-lg font-medium text-white"),
                P("You have reviewed all available pairs.", cls="text-slate-400 mt-2"),
                cls="text-center py-12"
            ), oob_toast, counter_script)
        _next_url = f"/api/match/next-pair?filter={filter}" if filter else "/api/match/next-pair"
        next_pair_html = Div(
            P("Loading next pair...", cls="text-slate-400 text-center py-4"),
            hx_get=_next_url, hx_trigger="load", hx_swap="outerHTML",
        )
        return (next_pair_html, oob_toast, counter_script)

    if decision == "same":
        # Merge identity_b into identity_a
        try:
            registry = load_registry()
            photo_registry = load_photo_registry()
            result = registry.merge_identities(
                source_id=identity_b,
                target_id=identity_a,
                user_source="match_mode",
                photo_registry=photo_registry,
            )
            if result["success"]:
                save_registry(registry)
                oob_toast = Div(
                    toast(f"Merged! {_pl(result['faces_merged'], 'face')} combined.", "success"),
                    hx_swap_oob="beforeend:#toast-container",
                )
            else:
                oob_toast = Div(
                    toast(f"Cannot merge: {result['reason']}", "warning"),
                    hx_swap_oob="beforeend:#toast-container",
                )
        except Exception as e:
            oob_toast = Div(
                toast(f"Error: {str(e)}", "error"),
                hx_swap_oob="beforeend:#toast-container",
            )
    elif decision == "different":
        # Mark as not same person
        try:
            registry = load_registry()
            registry.reject_identity_pair(identity_a, identity_b, user_source="match_mode")
            save_registry(registry)
            oob_toast = Div(
                toast("Marked as different people.", "info"),
                hx_swap_oob="beforeend:#toast-container",
            )
        except Exception as e:
            oob_toast = Div(
                toast(f"Error: {str(e)}", "error"),
                hx_swap_oob="beforeend:#toast-container",
            )
    else:
        oob_toast = Div(
            toast("Invalid decision.", "error"),
            hx_swap_oob="beforeend:#toast-container",
        )

    # Increment counter script (OOB)
    counter_script = Div(
        Script("if (typeof incrementMatchCount === 'function') incrementMatchCount();"),
        hx_swap_oob="beforeend:body",
    )

    # Get next pair (respecting active filter)
    pair = _get_best_match_pair(triage_filter=filter)
    if pair is None:
        _back_url = f"/?section=to_review&view=focus&filter={filter}" if filter else "/?section=to_review&view=focus"
        next_content = Div(
            H3("No more pairs!", cls="text-lg font-medium text-white"),
            P("You have matched all available pairs.", cls="text-slate-400 mt-2"),
            A("Back to Focus mode", href=_back_url,
              cls="inline-block mt-4 text-indigo-400 hover:text-indigo-300 font-medium"),
            cls="text-center py-12"
        )
        return (next_content, oob_toast, counter_script)

    _next_url = f"/api/match/next-pair?filter={filter}" if filter else "/api/match/next-pair"
    next_pair_html = Div(
        P("Loading next pair...", cls="text-slate-400 text-center py-4"),
        hx_get=_next_url,
        hx_trigger="load",
        hx_swap="outerHTML",
    )
    return (next_pair_html, oob_toast, counter_script)


if __name__ == "__main__":
    # Startup diagnostics
    print("=" * 60)
    print("RHODESLI STARTUP")
    print("=" * 60)
    print(f"[config] Host: {HOST}")
    print(f"[config] Port: {PORT}")
    print(f"[config] Debug: {DEBUG}")
    print(f"[config] Processing enabled: {PROCESSING_ENABLED}")
    print(f"[config] Auth enabled: {is_auth_enabled()}")
    print(f"[paths] Data directory: {data_path.resolve()}")
    print(f"[paths] Photos directory: {photos_path.resolve()}")

    # Check photos directory
    if photos_path.exists():
        photo_count = len(list(photos_path.iterdir()))
        print(f"[data] Photos found: {photo_count}")
    else:
        print("[data] WARNING: raw_photos directory does not exist")

    # Check data files
    registry = load_registry()
    print(f"[data] Identities loaded: {len(registry.list_identities())}")

    # Count photos from photo_index.json
    photo_index_path = data_path / "photo_index.json"
    if photo_index_path.exists():
        with open(photo_index_path) as f:
            index = json.load(f)
            photo_count = len(index.get("photos", {}))
        print(f"[data] Photos indexed: {photo_count}")
    else:
        print("[data] WARNING: photo_index.json not found")

    # Ensure staging directory exists for production uploads
    staging_dir = data_path / "staging"
    staging_dir.mkdir(parents=True, exist_ok=True)

    print("=" * 60)
    print(f"Server starting at http://{HOST}:{PORT}")
    print("=" * 60)

    serve(host=HOST, port=PORT, reload=DEBUG)